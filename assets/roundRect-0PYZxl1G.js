(()=>{var R,m,C;(R=Path2D.prototype).roundRect??(R.roundRect=P),globalThis.CanvasRenderingContext2D&&((m=globalThis.CanvasRenderingContext2D.prototype).roundRect??(m.roundRect=P)),globalThis.OffscreenCanvasRenderingContext2D&&((C=globalThis.OffscreenCanvasRenderingContext2D.prototype).roundRect??(C.roundRect=P));function P(t,s,u,a,o){if(![t,s,u,a].every(n=>Number.isFinite(n)))return;o=O(o);let e,r,i,h;if(o.length===4)e=l(o[0]),r=l(o[1]),i=l(o[2]),h=l(o[3]);else if(o.length===3)e=l(o[0]),r=l(o[1]),h=l(o[1]),i=l(o[2]);else if(o.length===2)e=l(o[0]),i=l(o[0]),r=l(o[1]),h=l(o[1]);else if(o.length===1)e=l(o[0]),r=l(o[0]),i=l(o[0]),h=l(o[0]);else throw new RangeError(`${b(this)} ${o.length} is not a valid size for radii sequence.`);const g=[e,r,i,h],p=g.find(({x:n,y:f})=>n<0||f<0);if((p==null?void 0:p.x)<0?p.x:p==null||p.y,g.some(({x:n,y:f})=>!Number.isFinite(n)||!Number.isFinite(f)))return;if(p)throw new RangeError(`${b(this)} Radius value ${p} is negative.`);v(g),u<0&&a<0?(this.moveTo(t-e.x,s),this.ellipse(t+u+r.x,s-r.y,r.x,r.y,0,-Math.PI*1.5,-Math.PI),this.ellipse(t+u+i.x,s+a+i.y,i.x,i.y,0,-Math.PI,-Math.PI/2),this.ellipse(t-h.x,s+a+h.y,h.x,h.y,0,-Math.PI/2,0),this.ellipse(t-e.x,s-e.y,e.x,e.y,0,0,-Math.PI/2)):u<0?(this.moveTo(t-e.x,s),this.ellipse(t+u+r.x,s+r.y,r.x,r.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(t+u+i.x,s+a-i.y,i.x,i.y,0,-Math.PI,-Math.PI*1.5,1),this.ellipse(t-h.x,s+a-h.y,h.x,h.y,0,Math.PI/2,0,1),this.ellipse(t-e.x,s+e.y,e.x,e.y,0,0,-Math.PI/2,1)):a<0?(this.moveTo(t+e.x,s),this.ellipse(t+u-r.x,s-r.y,r.x,r.y,0,Math.PI/2,0,1),this.ellipse(t+u-i.x,s+a+i.y,i.x,i.y,0,0,-Math.PI/2,1),this.ellipse(t+h.x,s+a+h.y,h.x,h.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(t+e.x,s-e.y,e.x,e.y,0,-Math.PI,-Math.PI*1.5,1)):(this.moveTo(t+e.x,s),this.ellipse(t+u-r.x,s+r.y,r.x,r.y,0,-Math.PI/2,0),this.ellipse(t+u-i.x,s+a-i.y,i.x,i.y,0,0,Math.PI/2),this.ellipse(t+h.x,s+a-h.y,h.x,h.y,0,Math.PI/2,Math.PI),this.ellipse(t+e.x,s+e.y,e.x,e.y,0,Math.PI,Math.PI*1.5)),this.closePath(),this.moveTo(t,s);function N(n){const{x:f,y:x,z:c,w:M}=n;return{x:f,y:x,z:c,w:M}}function O(n){const f=typeof n;return f==="undefined"||n===null?[0]:f==="function"?[NaN]:f==="object"?typeof n[Symbol.iterator]=="function"?[...n].map(x=>{const c=typeof x;return c==="undefined"||x===null?0:c==="function"?NaN:c==="object"?N(x):y(x)}):[N(n)]:[y(n)]}function y(n){return+n}function l(n){const f=y(n);return Number.isFinite(f)?{x:f,y:f}:Object(n)===n?{x:y(n.x??0),y:y(n.y??0)}:{x:NaN,y:NaN}}function v(n){const[f,x,c,M]=n,F=[Math.abs(u)/(f.x+x.x),Math.abs(a)/(x.y+c.y),Math.abs(u)/(c.x+M.x),Math.abs(a)/(f.y+M.y)],I=Math.min(...F);if(I<=1)for(const D of n)D.x*=I,D.y*=I}}function b(t){return`Failed to execute 'roundRect' on '${T(t)}':`}function T(t){return Object(t)===t&&t instanceof Path2D?"Path2D":t instanceof(globalThis==null?void 0:globalThis.CanvasRenderingContext2D)?"CanvasRenderingContext2D":t instanceof(globalThis==null?void 0:globalThis.OffscreenCanvasRenderingContext2D)?"OffscreenCanvasRenderingContext2D":(t==null?void 0:t.constructor.name)||t}})();
