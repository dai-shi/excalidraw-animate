{"version":3,"sources":["excalidraw/src/data/encode.ts","excalidraw/src/data/image.ts"],"names":["toByteString","data","Promise","resolve","reject","blob","Blob","TextEncoder","encode","reader","FileReader","onload","event","target","result","Error","readAsBinaryString","byteStringToArrayBuffer","byteString","buffer","ArrayBuffer","length","bufferView","Uint8Array","i","len","charCodeAt","byteStringToString","TextDecoder","decode","stringToBase64","str","a","btoa","base64ToString","base64","isByteString","atob","text","compress","deflate","deflated","console","error","version","encoding","compressed","encoded","decoded","inflate","to","blobToArrayBuffer","arrayBuffer","readAsArrayBuffer","getTEXtChunk","decodePng","chunks","metadataChunk","find","chunk","name","tEXt","encodePngMetadata","metadata","MIME_TYPES","excalidraw","JSON","stringify","splice","encodePng","type","decodePngMetadata","keyword","encodedData","parse","encodeSvgMetadata","decodeSvgMetadata","svg","includes","match","versionMatch","json"],"mappings":"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","file":"static/js/image.1b990d7c.chunk.js","sourcesContent":["import { deflate, inflate } from \"pako\";\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n\n// fast, Buffer-compatible implem\nexport const toByteString = (data: string | Uint8Array): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const blob =\n      typeof data === \"string\"\n        ? new Blob([new TextEncoder().encode(data)])\n        : new Blob([data]);\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = (byteString: string) => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n};\n\nconst byteStringToString = (byteString: string) => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nexport const stringToBase64 = async (str: string, isByteString = false) => {\n  return isByteString ? btoa(str) : btoa(await toByteString(str));\n};\n\n// async to align with stringToBase64\nexport const base64ToString = async (base64: string, isByteString = false) => {\n  return isByteString ? atob(base64) : byteStringToString(atob(base64));\n};\n\n// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\ntype EncodedData = {\n  encoded: string;\n  encoding: \"bstring\";\n  /** whether text is compressed (zlib) */\n  compressed: boolean;\n  /** version for potential migration purposes */\n  version?: string;\n};\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress,\n}: {\n  text: string;\n  /** defaults to `true`. If compression fails, falls back to bstring alone. */\n  compress?: boolean;\n}): Promise<EncodedData> => {\n  let deflated!: string;\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text)),\n  };\n};\n\nexport const decode = async (data: EncodedData): Promise<string> => {\n  let decoded: string;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed\n        ? data.encoded\n        : await byteStringToString(data.encoded);\n      break;\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\",\n    });\n  }\n\n  return decoded;\n};\n","import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { MIME_TYPES } from \"../constants\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nconst blobToArrayBuffer = (blob: Blob): Promise<ArrayBuffer> => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target?.result) {\n        return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result as ArrayBuffer);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: \"image/png\" });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"],"sourceRoot":""}