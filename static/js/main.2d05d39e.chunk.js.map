{"version":3,"sources":["vendor/loadLibraryFromBlob.ts","vendor/loadFromJSON.ts","GitHubCorner.tsx","vendor/getFreeDrawSvgPath.ts","animate.ts","export.ts","vendor/loadScene.ts","useLoadSvg.ts","Toolbar.tsx","Viewer.tsx","App.tsx","index.tsx"],"names":["EXPORT_DATA_TYPES","parseFileContents","blob","a","Blob","text","contents","Promise","resolve","reader","FileReader","readAsText","onloadend","readyState","DONE","result","loadLibraryFromBlob","data","JSON","parse","type","Error","isValidExcalidrawData","elements","Array","isArray","appState","loadFromBlob","localAppState","restore","console","error","message","loadFromJSON","fileOpen","description","GitHubCorner","link","size","fill","color","href","className","aria-label","target","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","getFreeDrawSvgPath","element","inputPoints","simulatePressure","points","length","map","i","pressures","options","strokeWidth","thinning","smoothing","streamline","easing","t","last","getFreeDrawShape","p0","p1","push","join","SVG_NS","hideBeforeAnimation","svg","ele","currentMs","durationMs","freeze","setAttribute","animate","ownerDocument","createElementNS","appendChild","animatePointer","path","pointerImg","img","pointerWidth","pointerHeight","animateMotion","items","match","reduce","prev","item","index","x1","y1","x2","y2","Math","hypot","Number","pickOnePathItem","parentNode","animatePath","dTo","getAttribute","mCount","repeat","dLast","dFrom","replace","RegExp","slice","x","y","animateFillPath","includes","animatePolygon","cCount","dups","min","keys","pathForTextIndex","animateFromToPath","patchSvgText","childNodes","len","forEach","child","toOpacity","textPath","textContent","name","tagName","findNode","animateText","patchSvgEle","excalidraElement","strokeSharpness","animateLine","patchSvgLine","numParts","numChildren","j","patchSvgArrow","patchSvgRectangle","patchSvgEllipse","freeDrawElement","childNode","p","patchSvgFreedraw","createGroups","groups","groupIds","groupId","filterGroupNodes","nodes","filter","node","extractNumberFromElement","key","id","sortSvgNodes","sort","b","aIndex","indexOf","bIndex","exportToSvgFile","savedMs","getCurrentTime","setCurrentTime","svgStr","XMLSerializer","serializeToString","fileSave","fileName","extensions","exportToWebmFile","prepareWebmData","svgList","reject","navigator","mediaDevices","getDisplayMedia","video","cursor","displaySurface","stream","recorder","MediaRecorder","ondataavailable","e","maxFinishedMs","finishedMs","max","pauseAnimations","start","unpauseAnimations","setTimeout","stop","getVideoTracks","getImportedKey","usage","window","crypto","subtle","importKey","alg","ext","k","key_ops","kty","decryptImported","iv","encrypted","privateKey","decrypt","importFromBackend","fetch","response","ok","alert","arrayBuffer","buffer","byteLength","decrypted","fixedIv","Uint8Array","string","TextDecoder","decode","json","loadScene","localDataState","commitToHistory","getNonDeletedElements","isDeleted","importLibraryFromUrl","url","request","libraryFile","library","libraryItem","restoreElements","useLoadSvg","useState","loading","setLoading","loadedSvgList","setLoadedSvgList","loadDataList","useCallback","dataList","inSequence","hash","location","searchParams","URLSearchParams","startMs","undefined","get","exportToSvg","exportBackground","viewBackgroundColor","shouldAddWatermark","exportPadding","finished","Map","current","groupDur","individualDur","groupNodes","groupElement2Element","has","group","dur","set","childEle","childIndex","animateSvg","log","useEffect","matchIdKey","exec","matchLibrary","linkRegex","getCombinedBeginTimeList","beginTimeList","concat","tmpTimeList","findAnimate","splice","getBeginTimeList","n","floor","Set","Toolbar","showToolbar","setShowToolbar","paused","setPaused","processing","setProcessing","setLink","webmData","setWebmData","loadFile","loadLibrary","mimeTypes","togglePausedAnimations","timer","useRef","stepForwardAnimations","currentTime","nextTime","find","clearTimeout","resetAnimations","onKeydown","toLowerCase","s","document","addEventListener","removeEventListener","exportToWebm","onClick","onSubmit","event","preventDefault","reload","placeholder","value","onChange","disabled","test","Viewer","ref","remove","callback","ceil","sqrt","grids","gridTemplateColumns","gridTemplateRows","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.2d05d39e.chunk.js","sourcesContent":["import type { ImportedLibraryData } from \"@excalidraw/excalidraw/types/data/types\";\n\nconst t = (s: string) => s;\n\nconst EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n  return contents;\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: ImportedLibraryData = JSON.parse(contents);\n  if (data.type !== EXPORT_DATA_TYPES.excalidrawLibrary) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n","import { fileOpen } from \"browser-fs-access\";\n\nimport { restore } from \"@excalidraw/excalidraw\";\nimport type { ImportedDataState } from \"@excalidraw/excalidraw/types/data/types\";\nimport type { AppState } from \"@excalidraw/excalidraw/types/types\";\n\nconst t = (s: string) => s;\n\nconst EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nconst isValidExcalidrawData = (data?: {\n  type?: any;\n  elements?: any;\n  appState?: any;\n}): data is ImportedDataState => {\n  return (\n    data?.type === EXPORT_DATA_TYPES.excalidraw &&\n    (!data.elements ||\n      (Array.isArray(data.elements) &&\n        (!data.appState || typeof data.appState === \"object\")))\n  );\n};\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n  return contents;\n};\n\nconst loadFromBlob = async (blob: Blob, localAppState: AppState | null) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (!isValidExcalidrawData(data)) {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore({ elements: data.elements || [] }, localAppState);\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadFromJSON = async (localAppState: AppState | null) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n  });\n  return loadFromBlob(blob, localAppState);\n};\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\ntype Props = {\n  link: string;\n  size?: number;\n  fill?: string;\n  color?: string;\n};\n\n// http://tholman.com/github-corners/\nconst GitHubCorner: React.FC<Props> = ({ link, size, fill, color }) => (\n  <a\n    href={link}\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n);\n\nexport default GitHubCorner;\n","import getFreeDrawShape from \"perfect-freehand\";\nimport type {\n  ExcalidrawFreeDrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 6,\n    thinning: 0.5,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t: number) => t * (2 - t),\n    last: true,\n  };\n\n  const points = getFreeDrawShape(inputPoints as number[][], options);\n  const d: (string | number)[] = [];\n\n  let [p0, p1] = points;\n\n  d.push(\"M\", p0[0], p0[1], \"Q\");\n\n  for (let i = 0; i < points.length; i++) {\n    d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n    p0 = p1;\n    p1 = points[i];\n  }\n\n  p1 = points[0];\n  d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n\n  d.push(\"Z\");\n\n  return d.join(\" \");\n}\n","import type {\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { getFreeDrawSvgPath } from \"./vendor/getFreeDrawSvgPath\";\n\ntype AnimateOptions = {\n  startMs?: number;\n  pointerImg?: string;\n  pointerWidth?: string;\n  pointerHeight?: string;\n};\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst findNode = (ele: SVGElement, name: string) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  for (let i = 0; i < childNodes.length; ++i) {\n    if (childNodes[i].tagName === name) {\n      return childNodes[i];\n    }\n  }\n  return null;\n};\n\nconst hideBeforeAnimation = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  freeze?: boolean\n) => {\n  ele.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"1\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  if (freeze) {\n    animate.setAttribute(\"fill\", \"freeze\");\n  }\n  ele.appendChild(animate);\n};\n\nconst pickOnePathItem = (path: string) => {\n  const items = path.match(/(M[^C]*C[^M]*)/g);\n  if (!items) {\n    return path;\n  }\n  if (items.length <= 2) {\n    return items[items.length - 1];\n  }\n  const [longestIndex] = items.reduce(\n    (prev, item, index) => {\n      const [, x1, y1, x2, y2] =\n        item.match(/M([\\d.-]+) ([\\d.-]+) C([\\d.-]+) ([\\d.-]+)/) || [];\n      const d = Math.hypot(Number(x2) - Number(x1), Number(y2) - Number(y1));\n      if (d > prev[1]) {\n        return [index, d];\n      }\n      return prev;\n    },\n    [0, 0]\n  );\n  return items[longestIndex];\n};\n\nconst animatePointer = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  path: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (!options.pointerImg) return;\n  const img = svg.ownerDocument.createElementNS(SVG_NS, \"image\");\n  img.setAttribute(\"href\", options.pointerImg);\n  if (options.pointerWidth) {\n    img.setAttribute(\"width\", options.pointerWidth);\n  }\n  if (options.pointerHeight) {\n    img.setAttribute(\"height\", options.pointerHeight);\n  }\n  hideBeforeAnimation(svg, img, currentMs, durationMs);\n  const animateMotion = svg.ownerDocument.createElementNS(\n    SVG_NS,\n    \"animateMotion\"\n  );\n  animateMotion.setAttribute(\"path\", pickOnePathItem(path));\n  animateMotion.setAttribute(\"begin\", `${currentMs}ms`);\n  animateMotion.setAttribute(\"dur\", `${durationMs}ms`);\n  img.appendChild(animateMotion);\n  ele.parentNode?.appendChild(img);\n};\n\nconst animatePath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  const repeat = cCount / mCount;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"M(\\\\S+) (\\\\S+)\",\n          \"((?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){\",\n          `${i}`, // skip count\n          \"})\",\n          \"(?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){1,}\",\n        ].join(\"\"),\n        \"g\"\n      ),\n      (...a) => {\n        const [x, y] = a[3]\n          ? a[3].match(/.* (\\S+) (\\S+)$/).slice(1, 3)\n          : [a[1], a[2]];\n        return (\n          `M${a[1]} ${a[2]}${a[3]}` +\n          ` C${x} ${y}, ${x} ${y}, ${x} ${y}`.repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n  animatePointer(svg, ele, dTo, currentMs, durationMs, options);\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nconst animateFillPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  if (dTo.includes(\"C\")) {\n    animatePath(svg, ele, currentMs, durationMs, options);\n    return;\n  }\n  const dFrom = dTo.replace(\n    new RegExp([\"M(\\\\S+) (\\\\S+)\", \"((?: L\\\\S+ \\\\S+){1,})\"].join(\"\")),\n    (...a) => {\n      return `M${a[1]} ${a[2]}` + a[3].replace(/L\\S+ \\S+/g, `L${a[1]} ${a[2]}`);\n    }\n  );\n  ele.setAttribute(\"d\", dFrom);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  ele.appendChild(animate);\n};\n\nconst animatePolygon = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  let dTo = ele.getAttribute(\"d\") || \"\";\n  let mCount = dTo.match(/M/g)?.length || 0;\n  let cCount = dTo.match(/C/g)?.length || 0;\n  if (mCount === cCount + 1) {\n    // workaround for round rect\n    dTo = dTo.replace(/^M\\S+ \\S+ M/, \"M\");\n    mCount = dTo.match(/M/g)?.length || 0;\n    cCount = dTo.match(/C/g)?.length || 0;\n  }\n  if (mCount !== cCount) throw new Error(\"unexpected m/c counts\");\n  const dups = ele.getAttribute(\"stroke-dasharray\") ? 1 : Math.min(2, mCount);\n  const repeat = mCount / dups;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"((?:\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \"){\",\n          `${i}`, // skip count\n          \"})\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \".*\",\n        ].join(\"\")\n      ),\n      (...a) => {\n        return (\n          `${a[1]}` +\n          [...Array(dups).keys()]\n            .map((d) => {\n              const [x, y] = a.slice(2 + dups * 2 + d * 2);\n              return `M${x} ${y} C${x} ${y}, ${x} ${y}, ${x} ${y} `;\n            })\n            .join(\"\")\n            .repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n    animatePointer(\n      svg,\n      ele,\n      dTo.replace(\n        new RegExp(\n          [\n            \"(?:\",\n            \"M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n            \"){\",\n            `${i}`, // skip count\n            \"}\",\n            \"(M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+) ?\".repeat(dups),\n            \".*\",\n          ].join(\"\")\n        ),\n        \"$1\"\n      ),\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat,\n      options\n    );\n  }\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nlet pathForTextIndex = 0;\n\nconst animateText = (\n  svg: SVGSVGElement,\n  width: number,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const anchor = ele.getAttribute(\"text-anchor\") || \"start\";\n  if (anchor !== \"start\") {\n    // Not sure how to support it, fallback with opacity\n    const toOpacity = ele.getAttribute(\"opacity\") || \"1.0\";\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"opacity\");\n    animate.setAttribute(\"from\", \"0.0\");\n    animate.setAttribute(\"to\", toOpacity);\n    animate.setAttribute(\"begin\", `${currentMs}ms`);\n    animate.setAttribute(\"dur\", `${durationMs}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    ele.setAttribute(\"opacity\", \"0.0\");\n    return;\n  }\n  const x = Number(ele.getAttribute(\"x\") || 0);\n  const y = Number(ele.getAttribute(\"y\") || 0);\n  pathForTextIndex += 1;\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  path.setAttribute(\"id\", \"pathForText\" + pathForTextIndex);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", `m${x} ${y} h0`);\n  animate.setAttribute(\"to\", `m${x} ${y} h${width}`);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  path.appendChild(animate);\n  const textPath = svg.ownerDocument.createElementNS(SVG_NS, \"textPath\");\n  textPath.setAttribute(\"href\", \"#pathForText\" + pathForTextIndex);\n  textPath.textContent = ele.textContent;\n  ele.textContent = \" \"; // HACK for Firebox as `null` does not work\n  findNode(svg, \"defs\")?.appendChild(path);\n  ele.appendChild(textPath);\n  animatePointer(\n    svg,\n    ele,\n    `m${x} ${y} h${width}`,\n    currentMs,\n    durationMs,\n    options\n  );\n};\n\nconst animateFromToPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  dFrom: string,\n  dTo: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  path.appendChild(animate);\n  ele.appendChild(path);\n};\n\nconst patchSvgLine = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  if (childNodes[0].getAttribute(\"fill-rule\")) {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgArrow = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const numParts = ele.childNodes.length;\n  animateLine(\n    svg,\n    ele.childNodes[0].childNodes[0] as SVGElement,\n    currentMs,\n    (durationMs / (numParts + 2)) * 3,\n    options\n  );\n  currentMs += (durationMs / (numParts + 2)) * 3;\n  for (let i = 1; i < numParts; i += 1) {\n    const numChildren = ele.childNodes[i].childNodes.length;\n    for (let j = 0; j < numChildren; j += 1) {\n      animatePath(\n        svg,\n        ele.childNodes[i].childNodes[j] as SVGElement,\n        currentMs,\n        durationMs / (numParts + 2) / numChildren,\n        options\n      );\n      currentMs += durationMs / (numParts + 2) / numChildren;\n    }\n  }\n};\n\nconst patchSvgRectangle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (ele.childNodes[1]) {\n    animatePolygon(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animatePolygon(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgEllipse = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (ele.childNodes[1]) {\n    animatePath(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animatePath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgText = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  width: number,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  const len = childNodes.length;\n  childNodes.forEach((child) => {\n    animateText(svg, width, child, currentMs, durationMs / len, options);\n    currentMs += durationMs / len;\n  });\n};\n\nconst patchSvgFreedraw = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  freeDrawElement: NonDeleted<ExcalidrawFreeDrawElement>,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const childNode = ele.childNodes[0] as SVGPathElement;\n  childNode.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"0\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"calcMode\", \"discrete\");\n  animate.setAttribute(\"begin\", `${currentMs + durationMs - 1}ms`);\n  animate.setAttribute(\"dur\", `${1}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  childNode.appendChild(animate);\n  animatePointer(\n    svg,\n    childNode,\n    freeDrawElement.points.reduce(\n      (p, [x, y]) => (p ? p + ` T ${x} ${y}` : `M ${x} ${y}`),\n      \"\"\n    ),\n    currentMs,\n    durationMs,\n    options\n  );\n\n  // interporation\n  const repeat = freeDrawElement.points.length;\n  let dTo = childNode.getAttribute(\"d\") as string;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom =\n      i > 0\n        ? getFreeDrawSvgPath({\n            ...freeDrawElement,\n            points: freeDrawElement.points.slice(0, i),\n          })\n        : \"M 0 0\";\n    animateFromToPath(\n      svg,\n      ele,\n      dFrom,\n      dTo,\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n    dTo = dFrom;\n  }\n};\n\nconst patchSvgEle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  excalidraElement: NonDeletedExcalidrawElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const { type, strokeSharpness, width } = excalidraElement;\n  if (type === \"line\") {\n    patchSvgLine(svg, ele, strokeSharpness, currentMs, durationMs, options);\n  } else if (type === \"arrow\") {\n    patchSvgArrow(svg, ele, strokeSharpness, currentMs, durationMs, options);\n  } else if (type === \"rectangle\" || type === \"diamond\") {\n    patchSvgRectangle(svg, ele, currentMs, durationMs, options);\n  } else if (type === \"ellipse\") {\n    patchSvgEllipse(svg, ele, currentMs, durationMs, options);\n  } else if (type === \"text\") {\n    patchSvgText(svg, ele, width, currentMs, durationMs, options);\n  } else if (excalidraElement.type === \"freedraw\") {\n    patchSvgFreedraw(\n      svg,\n      ele,\n      excalidraElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst createGroups = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  const groups: { [groupId: string]: (readonly [SVGElement, number])[] } = {};\n  let index = 0;\n  const childNodes = svg.childNodes as NodeListOf<SVGElement>;\n  childNodes.forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { groupIds } = elements[index];\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        groups[groupId] = groups[groupId] || [];\n        groups[groupId].push([ele, index] as const);\n      }\n      index += 1;\n    }\n  });\n  return groups;\n};\n\nconst filterGroupNodes = (nodes: NodeListOf<SVGElement>) =>\n  [...nodes].filter((node) => node.tagName === \"g\");\n\nconst extractNumberFromElement = (\n  element: NonDeletedExcalidrawElement,\n  key: string\n) => {\n  const match = element.id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return (match && Number(match[1])) || 0;\n};\n\nconst sortSvgNodes = (\n  nodes: SVGElement[],\n  elements: readonly NonDeletedExcalidrawElement[]\n) =>\n  [...nodes].sort((a, b) => {\n    const aIndex = nodes.indexOf(a);\n    const bIndex = nodes.indexOf(b);\n    const aOrder = extractNumberFromElement(elements[aIndex], \"animateOrder\");\n    const bOrder = extractNumberFromElement(elements[bIndex], \"animateOrder\");\n    return aOrder - bOrder;\n  });\n\nexport const animateSvg = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[],\n  options: AnimateOptions = {}\n) => {\n  let finishedMs;\n  const groups = createGroups(svg, elements);\n  const finished = new Map();\n  let current = options.startMs ?? 1000; // 1 sec margin\n  const groupDur = 5000;\n  const individualDur = 500;\n  const groupNodes = filterGroupNodes(svg.childNodes as NodeListOf<SVGElement>);\n  if (groupNodes.length !== elements.length) {\n    throw new Error(\"element length mismatch\");\n  }\n  const groupElement2Element = new Map(\n    groupNodes.map((ele, index) => [ele, elements[index]])\n  );\n  sortSvgNodes(groupNodes, elements).forEach((ele) => {\n    const element = groupElement2Element.get(\n      ele\n    ) as NonDeletedExcalidrawElement;\n    const { groupIds } = element;\n    if (!finished.has(ele)) {\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        const group = groups[groupId];\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") ||\n          groupDur / (group.length + 1);\n        patchSvgEle(svg, ele, element, current, dur, options);\n        current += dur;\n        finished.set(ele, true);\n        group.forEach(([childEle, childIndex]) => {\n          const dur =\n            extractNumberFromElement(elements[childIndex], \"animateDuration\") ||\n            groupDur / (group.length + 1);\n          if (!finished.has(childEle)) {\n            patchSvgEle(\n              svg,\n              childEle,\n              elements[childIndex],\n              current,\n              dur,\n              options\n            );\n            current += dur;\n            finished.set(childEle, true);\n          }\n        });\n        delete groups[groupId];\n      } else {\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") || individualDur;\n        patchSvgEle(svg, ele, element, current, dur, options);\n        current += dur;\n        finished.set(ele, true);\n      }\n    }\n  });\n  finishedMs = current + 1000; // 1 sec margin\n  return { finishedMs };\n};\n\nexport const getBeginTimeList = (svg: SVGSVGElement) => {\n  const beginTimeList: number[] = [];\n  const tmpTimeList: number[] = [];\n  const findAnimate = (ele: SVGElement) => {\n    if (ele.tagName === \"animate\") {\n      const match = /([0-9.]+)ms/.exec(ele.getAttribute(\"begin\") || \"\");\n      if (match) {\n        tmpTimeList.push(Number(match[1]));\n      }\n    }\n    (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n      findAnimate(ele);\n    });\n  };\n  (svg.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      findAnimate(ele);\n      if (tmpTimeList.length) {\n        beginTimeList.push(Math.min(...tmpTimeList));\n        tmpTimeList.splice(0);\n      }\n    } else if (ele.tagName === \"defs\") {\n      (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n        findAnimate(ele);\n        if (tmpTimeList.length) {\n          beginTimeList.push(Math.min(...tmpTimeList));\n          tmpTimeList.splice(0);\n        }\n      });\n    }\n  });\n  return beginTimeList;\n};\n","import { fileSave } from \"browser-fs-access\";\n\nexport const exportToSvgFile = async (svg: SVGSVGElement) => {\n  const savedMs = svg.getCurrentTime();\n  svg.setCurrentTime(0);\n  const svgStr = new XMLSerializer().serializeToString(svg);\n  svg.setCurrentTime(savedMs);\n  await fileSave(new Blob([svgStr], { type: \"image/svg+xml\" }), {\n    fileName: \"excalidraw-animate.svg\",\n    extensions: [\".svg\"],\n  });\n};\n\nexport const exportToWebmFile = async (data: Blob) => {\n  await fileSave(new Blob([data], { type: \"video/webm\" }), {\n    fileName: \"excalidraw-animate.webm\",\n    extensions: [\".webm\"],\n  });\n};\n\nexport const prepareWebmData = (\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[]\n) =>\n  new Promise<Blob>(async (resolve, reject) => {\n    try {\n      const stream = (await (navigator.mediaDevices as any).getDisplayMedia({\n        video: {\n          cursor: \"never\",\n          displaySurface: \"browser\",\n        },\n      })) as MediaStream;\n      const recorder = new MediaRecorder(stream);\n      recorder.ondataavailable = (e) => {\n        resolve(e.data);\n      };\n      let maxFinishedMs = 0;\n      svgList.forEach(({ svg, finishedMs }) => {\n        maxFinishedMs = Math.max(maxFinishedMs, finishedMs);\n        svg.pauseAnimations();\n        svg.setCurrentTime(0);\n      });\n      recorder.start();\n      svgList.forEach(({ svg }) => {\n        svg.unpauseAnimations();\n      });\n      setTimeout(() => {\n        recorder.stop();\n        stream.getVideoTracks()[0].stop();\n      }, maxFinishedMs);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","import { restore } from \"@excalidraw/excalidraw\";\nimport type {\n  ImportedDataState\n} from \"@excalidraw/excalidraw/types/data/types\";\n\nconst t = (s: string) => s;\n\nconst BACKEND_GET = \"https://json.excalidraw.com/api/v1/\";\nconst BACKEND_V2_GET = \"https://json.excalidraw.com/api/v2/\";\nconst IV_LENGTH_BYTES = 12; // 96 bits\n\nconst getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\nconst decryptImported = async (\n  iv: ArrayBuffer,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n\n      let decrypted: ArrayBuffer;\n      try {\n        // Buffer should contain both the IV (fixed length) and encrypted data\n        const iv = buffer.slice(0, IV_LENGTH_BYTES);\n        const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n        decrypted = await decryptImported(iv, encrypted, privateKey);\n      } catch (error) {\n        // Fixed IV (old format, backward compatibility)\n        const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n        decrypted = await decryptImported(fixedIv, buffer, privateKey);\n      }\n\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data: ReturnType<typeof restore>;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n    );\n  } else {\n    data = restore(localDataState || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { exportToSvg, restoreElements } from \"@excalidraw/excalidraw\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { loadScene } from \"./vendor/loadScene\";\nimport { loadLibraryFromBlob } from \"./vendor/loadLibraryFromBlob\";\n\nimport { animateSvg } from \"./animate\";\n\nexport const getNonDeletedElements = (\n  elements: readonly ExcalidrawElement[]\n): NonDeletedExcalidrawElement[] =>\n  elements.filter(\n    (element): element is NonDeletedExcalidrawElement => !element.isDeleted\n  );\n\nconst importLibraryFromUrl = async (url: string) => {\n  try {\n    const request = await fetch(url);\n    const blob = await request.blob();\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      throw new Error();\n    }\n    return libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n  } catch (error) {\n    window.alert(\"Unable to load library\");\n    return [];\n  }\n};\n\nexport const useLoadSvg = () => {\n  const [loading, setLoading] = useState(true);\n  const [loadedSvgList, setLoadedSvgList] = useState<\n    {\n      svg: SVGSVGElement;\n      finishedMs: number;\n    }[]\n  >([]);\n\n  const loadDataList = useCallback(\n    (\n      dataList: {\n        elements: readonly ExcalidrawElement[];\n      }[],\n      inSequence?: boolean\n    ) => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const options = {\n        startMs: undefined as number | undefined,\n        pointerImg: searchParams.get(\"pointerImg\") || undefined,\n        pointerWidth: searchParams.get(\"pointerWidth\") || undefined,\n        pointerHeight: searchParams.get(\"pointerHeight\") || undefined,\n      };\n      const svgList = dataList.map((data) => {\n        const elements = getNonDeletedElements(data.elements);\n        const svg = exportToSvg({\n          elements,\n          appState: {\n            exportBackground: true,\n            viewBackgroundColor: \"white\",\n            shouldAddWatermark: false,\n          },\n          exportPadding: 30,\n        });\n        const result = animateSvg(svg, elements, options);\n        console.log(svg);\n        if (inSequence) {\n          options.startMs = result.finishedMs;\n        }\n        return { svg, finishedMs: result.finishedMs };\n      });\n      setLoadedSvgList(svgList);\n      return svgList;\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const matchIdKey = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (matchIdKey) {\n        const [, id, key] = matchIdKey;\n        const data = await loadScene(id, key, null);\n        const [{ svg, finishedMs }] = loadDataList([data]);\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svg.setCurrentTime(finishedMs);\n        }\n      }\n      const matchLibrary = /(.*\\.excalidrawlib)/.exec(\n        searchParams.get(\"library\") || \"\"\n      );\n      if (matchLibrary) {\n        const [, url] = matchLibrary;\n        const dataList = await importLibraryFromUrl(url);\n        const svgList = loadDataList(\n          dataList.map((elements) => ({ elements })),\n          searchParams.has(\"sequence\")\n        );\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svgList.forEach(({ svg, finishedMs }) => {\n            svg.setCurrentTime(finishedMs);\n          });\n        }\n      }\n      setLoading(false);\n    })();\n  }, [loadDataList]);\n\n  return { loading, loadedSvgList, loadDataList };\n};\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { fileOpen } from \"browser-fs-access\";\n\nimport { restoreElements } from \"@excalidraw/excalidraw\";\nimport type { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { loadLibraryFromBlob } from \"./vendor/loadLibraryFromBlob\";\nimport { loadFromJSON } from \"./vendor/loadFromJSON\";\n\nimport \"./Toolbar.css\";\nimport GitHubCorner from \"./GitHubCorner\";\nimport { getBeginTimeList } from \"./animate\";\nimport { exportToSvgFile, exportToWebmFile, prepareWebmData } from \"./export\";\nimport { getNonDeletedElements } from \"./useLoadSvg\";\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)|^http.*\\.excalidrawlib$/;\n\nconst getCombinedBeginTimeList = (svgList: Props[\"svgList\"]) => {\n  const beginTimeList = ([] as number[]).concat(\n    ...svgList.map(({ svg }) =>\n      getBeginTimeList(svg).map((n) => Math.floor(n * 100) / 100)\n    )\n  );\n  return [...new Set(beginTimeList)].sort((a, b) => a - b);\n};\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n  loadDataList: (data: { elements: readonly ExcalidrawElement[] }[]) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ svgList, loadDataList }) => {\n  const [showToolbar, setShowToolbar] = useState<boolean | \"never\">(false);\n  const [paused, setPaused] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [link, setLink] = useState(\"\");\n  const [webmData, setWebmData] = useState<Blob>();\n  useEffect(() => {\n    setWebmData(undefined);\n  }, [svgList]);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (paused) {\n        svg.pauseAnimations();\n      } else {\n        svg.unpauseAnimations();\n      }\n    });\n  }, [svgList, paused]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    } else {\n      setShowToolbar(\"never\");\n    }\n  }, []);\n\n  const loadFile = async () => {\n    const data = await loadFromJSON(null);\n    loadDataList([data]);\n  };\n\n  const loadLibrary = async () => {\n    const blob = await fileOpen({\n      description: \"Excalidraw library files\",\n      extensions: [\".json\", \".excalidrawlib\"],\n      mimeTypes: [\"application/json\"],\n    });\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      window.alert(\"Unable to load library\");\n      return;\n    }\n    const dataList = libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n    loadDataList(dataList.map((elements) => ({ elements })));\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    if (match[1]) {\n      window.location.hash = match[0];\n    } else {\n      window.location.hash = `library=${match[0]}`;\n    }\n    window.location.reload();\n  };\n\n  const togglePausedAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    setPaused((p) => !p);\n  }, [svgList]);\n\n  const timer = useRef<NodeJS.Timeout>();\n  const stepForwardAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    const beginTimeList = getCombinedBeginTimeList(svgList);\n    const currentTime = svgList[0].svg.getCurrentTime() * 1000;\n    let nextTime = beginTimeList.find((t) => t >= currentTime + 100);\n    if (!nextTime) {\n      nextTime = currentTime + 500;\n    }\n    clearTimeout(timer.current as NodeJS.Timeout);\n    svgList.forEach(({ svg }) => {\n      svg.unpauseAnimations();\n    });\n    timer.current = setTimeout(() => {\n      svgList.forEach(({ svg }) => {\n        svg.pauseAnimations();\n        svg.setCurrentTime((nextTime as number) / 1000);\n      });\n      setPaused(true);\n    }, nextTime - currentTime);\n  }, [svgList]);\n\n  const resetAnimations = useCallback(() => {\n    svgList.forEach(({ svg }) => {\n      svg.setCurrentTime(0);\n    });\n  }, [svgList]);\n\n  useEffect(() => {\n    const onKeydown = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === \"p\") {\n        togglePausedAnimations();\n      } else if (e.key.toLowerCase() === \"s\") {\n        stepForwardAnimations();\n      } else if (e.key.toLowerCase() === \"r\") {\n        resetAnimations();\n      } else if (e.key.toLowerCase() === \"q\") {\n        // toggle toolbar\n        setShowToolbar((s) => (typeof s === \"boolean\" ? !s : s));\n      } else {\n        // show toolbar otherwise\n        setShowToolbar((s) => (typeof s === \"boolean\" ? true : s));\n      }\n    };\n    document.addEventListener(\"keydown\", onKeydown);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeydown);\n    };\n  }, [togglePausedAnimations, stepForwardAnimations, resetAnimations]);\n\n  const hideToolbar = () => {\n    setShowToolbar((s) => (typeof s === \"boolean\" ? false : s));\n  };\n\n  const exportToSvg = () => {\n    if (!svgList.length) {\n      return;\n    }\n    svgList.forEach(({ svg }) => {\n      exportToSvgFile(svg);\n    });\n  };\n\n  const exportToWebm = async () => {\n    if (!svgList.length) {\n      return;\n    }\n    if (webmData) {\n      await exportToWebmFile(webmData);\n      return;\n    }\n    setProcessing(true);\n    setShowToolbar(false);\n    try {\n      const data = await prepareWebmData(svgList);\n      setWebmData(data);\n    } catch (e) {\n      console.log(e);\n    }\n    setShowToolbar(true);\n    setProcessing(false);\n  };\n\n  if (showToolbar !== true) {\n    return null;\n  }\n\n  return (\n    <div className=\"Toolbar\">\n      <div className=\"Toolbar-loader\">\n        <button type=\"button\" onClick={loadFile}>\n          Load File\n        </button>\n        <span>OR</span>\n        <button type=\"button\" onClick={loadLibrary}>\n          Load Library\n        </button>\n        <span>OR</span>\n        <form onSubmit={loadLink}>\n          <input\n            placeholder=\"Enter link...\"\n            value={link}\n            onChange={(e) => setLink(e.target.value)}\n          />\n          <button type=\"submit\" disabled={!linkRegex.test(link)}>\n            Animate!\n          </button>\n        </form>\n      </div>\n      {!!svgList.length && (\n        <div className=\"Toolbar-controller\">\n          <button type=\"button\" onClick={togglePausedAnimations}>\n            {paused ? \"Play (P)\" : \"Pause (P)\"}\n          </button>\n          <button type=\"button\" onClick={stepForwardAnimations}>\n            Step (S)\n          </button>\n          <button type=\"button\" onClick={resetAnimations}>\n            Reset (R)\n          </button>\n          <button type=\"button\" onClick={hideToolbar}>\n            Hide Toolbar (Q)\n          </button>\n          <button type=\"button\" onClick={exportToSvg}>\n            Export to SVG\n          </button>\n          <button type=\"button\" onClick={exportToWebm} disabled={processing}>\n            {processing\n              ? \"Processing...\"\n              : webmData\n              ? \"Export to WebM\"\n              : \"Prepare WebM\"}\n          </button>\n        </div>\n      )}\n      <GitHubCorner\n        link=\"https://github.com/dai-shi/excalidraw-animate\"\n        size={40}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n};\n\nconst Viewer: React.FC<Props> = ({ svgList }) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (ref.current) {\n        ref.current.appendChild(svg);\n      }\n    });\n    return () => {\n      svgList.forEach(({ svg }) => {\n        svg.remove();\n      });\n    };\n  }, [svgList]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"autoplay\") === \"no\") {\n      if (ref.current) {\n        const ele = ref.current;\n        const callback = () => {\n          svgList.forEach(({ svg }) => {\n            svg.setCurrentTime(0);\n            svg.unpauseAnimations();\n          });\n        };\n        ele.addEventListener(\"click\", callback);\n        return () => {\n          ele.removeEventListener(\"click\", callback);\n        };\n      }\n    }\n  }, [svgList]);\n\n  const repeat = Math.ceil(Math.sqrt(svgList.length));\n  const grids = `repeat(${repeat}, ${100 / repeat}%)`;\n\n  return (\n    <div\n      className=\"Viewer\"\n      style={{\n        gridTemplateColumns: grids,\n        gridTemplateRows: grids,\n      }}\n      ref={ref}\n    ></div>\n  );\n};\n\nexport default Viewer;\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadSvg } from \"./useLoadSvg\";\n\nconst App: React.FC = () => {\n  const { loading, loadedSvgList, loadDataList } = useLoadSvg();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      <Toolbar svgList={loadedSvgList} loadDataList={loadDataList} />\n      {!!loadedSvgList.length && <Viewer svgList={loadedSvgList} />}\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}