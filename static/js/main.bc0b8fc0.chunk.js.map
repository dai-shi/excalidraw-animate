{"version":3,"sources":["vendor/loadLibraryFromBlob.ts","vendor/loadFromJSON.ts","GitHubCorner.tsx","vendor/getFreeDrawSvgPath.ts","animate.ts","export.ts","vendor/loadScene.ts","useLoadSvg.ts","Toolbar.tsx","Viewer.tsx","App.tsx","index.tsx"],"names":["EXPORT_DATA_TYPES","parseFileContents","blob","a","Blob","text","contents","Promise","resolve","reader","FileReader","readAsText","onloadend","readyState","DONE","result","loadLibraryFromBlob","data","JSON","parse","type","Error","isValidExcalidrawData","elements","Array","isArray","appState","loadFromBlob","localAppState","restore","console","error","message","loadFromJSON","fileOpen","description","GitHubCorner","link","size","fill","color","href","className","aria-label","target","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","getFreeDrawSvgPath","element","inputPoints","simulatePressure","points","length","map","i","pressures","options","strokeWidth","thinning","smoothing","streamline","easing","t","last","getFreeDrawShape","p0","p1","push","join","SVG_NS","hideBeforeAnimation","svg","ele","currentMs","durationMs","freeze","setAttribute","animate","ownerDocument","createElementNS","appendChild","animatePointer","path","pointer","hash","window","location","slice","searchParams","URLSearchParams","img","get","getPointer","animateMotion","items","match","reduce","prev","item","index","x1","y1","x2","y2","Math","hypot","Number","pickOnePathItem","parentNode","animatePath","dTo","getAttribute","mCount","repeat","dLast","dFrom","replace","RegExp","x","y","animateFillPath","includes","animatePolygon","cCount","dups","min","keys","pathForTextIndex","animateFromToPath","patchSvgText","childNodes","len","forEach","child","toOpacity","textPath","textContent","name","tagName","findNode","animateText","patchSvgEle","excalidraElement","strokeSharpness","animateLine","patchSvgLine","numParts","numChildren","j","patchSvgArrow","patchSvgRectangle","patchSvgEllipse","freeDrawElement","childNode","p","patchSvgFreedraw","extractNumberFromElement","key","id","animateSvg","startMs","nodes","groups","groupIds","groupId","createGroups","finished","Map","current","groupNodes","filter","node","groupElement2Element","sort","b","aIndex","indexOf","bIndex","sortSvgNodes","has","group","dur","set","childEle","childIndex","finishedMs","exportToSvgFile","savedMs","getCurrentTime","setCurrentTime","svgStr","XMLSerializer","serializeToString","fileSave","fileName","extensions","exportToWebmFile","prepareWebmData","svgList","reject","navigator","mediaDevices","getDisplayMedia","video","cursor","displaySurface","stream","recorder","MediaRecorder","ondataavailable","e","maxFinishedMs","max","pauseAnimations","start","unpauseAnimations","setTimeout","stop","getVideoTracks","getImportedKey","usage","crypto","subtle","importKey","alg","ext","k","key_ops","kty","decryptImported","iv","encrypted","privateKey","decrypt","importFromBackend","fetch","response","ok","alert","arrayBuffer","buffer","byteLength","decrypted","fixedIv","Uint8Array","string","TextDecoder","decode","json","loadScene","localDataState","commitToHistory","getNonDeletedElements","isDeleted","importLibraryFromUrl","url","request","libraryFile","library","libraryItem","restoreElements","linkRegex","getCombinedBeginTimeList","beginTimeList","concat","tmpTimeList","findAnimate","exec","splice","getBeginTimeList","n","floor","Set","Toolbar","loadDataList","useState","showToolbar","setShowToolbar","paused","setPaused","processing","setProcessing","setLink","webmData","setWebmData","useEffect","undefined","loadFile","loadLibrary","mimeTypes","dataList","togglePausedAnimations","useCallback","timer","useRef","stepForwardAnimations","currentTime","nextTime","find","clearTimeout","resetAnimations","onKeydown","toLowerCase","s","document","addEventListener","removeEventListener","exportToWebm","log","onClick","onSubmit","event","preventDefault","reload","placeholder","value","onChange","disabled","test","Viewer","ref","remove","callback","ceil","sqrt","grids","gridTemplateColumns","gridTemplateRows","App","loading","setLoading","loadedSvgList","setLoadedSvgList","inSequence","exportToSvg","exportBackground","viewBackgroundColor","shouldAddWatermark","exportPadding","matchIdKey","matchLibrary","useLoadSvg","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.bc0b8fc0.chunk.js","sourcesContent":["import type { ImportedLibraryData } from \"@excalidraw/excalidraw/types/data/types\";\n\nconst t = (s: string) => s;\n\nconst EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n  return contents;\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: ImportedLibraryData = JSON.parse(contents);\n  if (data.type !== EXPORT_DATA_TYPES.excalidrawLibrary) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n","import { fileOpen } from \"browser-fs-access\";\n\nimport { restore } from \"@excalidraw/excalidraw\";\nimport type { ImportedDataState } from \"@excalidraw/excalidraw/types/data/types\";\nimport type { AppState } from \"@excalidraw/excalidraw/types/types\";\n\nconst t = (s: string) => s;\n\nconst EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nconst isValidExcalidrawData = (data?: {\n  type?: any;\n  elements?: any;\n  appState?: any;\n}): data is ImportedDataState => {\n  return (\n    data?.type === EXPORT_DATA_TYPES.excalidraw &&\n    (!data.elements ||\n      (Array.isArray(data.elements) &&\n        (!data.appState || typeof data.appState === \"object\")))\n  );\n};\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n  return contents;\n};\n\nconst loadFromBlob = async (blob: Blob, localAppState: AppState | null) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (!isValidExcalidrawData(data)) {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore({ elements: data.elements || [] }, localAppState);\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadFromJSON = async (localAppState: AppState | null) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n  });\n  return loadFromBlob(blob, localAppState);\n};\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\ntype Props = {\n  link: string;\n  size?: number;\n  fill?: string;\n  color?: string;\n};\n\n// http://tholman.com/github-corners/\nconst GitHubCorner: React.FC<Props> = ({ link, size, fill, color }) => (\n  <a\n    href={link}\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n);\n\nexport default GitHubCorner;\n","import getFreeDrawShape from \"perfect-freehand\";\nimport type {\n  ExcalidrawFreeDrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 6,\n    thinning: 0.5,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t: number) => t * (2 - t),\n    last: true,\n  };\n\n  const points = getFreeDrawShape(inputPoints as number[][], options);\n  const d: (string | number)[] = [];\n\n  let [p0, p1] = points;\n\n  d.push(\"M\", p0[0], p0[1], \"Q\");\n\n  for (let i = 0; i < points.length; i++) {\n    d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n    p0 = p1;\n    p1 = points[i];\n  }\n\n  p1 = points[0];\n  d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n\n  d.push(\"Z\");\n\n  return d.join(\" \");\n}\n","import type {\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { getFreeDrawSvgPath } from \"./vendor/getFreeDrawSvgPath\";\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst findNode = (ele: SVGElement, name: string) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  for (let i = 0; i < childNodes.length; ++i) {\n    if (childNodes[i].tagName === name) {\n      return childNodes[i];\n    }\n  }\n  return null;\n};\n\nconst hideBeforeAnimation = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  freeze?: boolean\n) => {\n  ele.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"1\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  if (freeze) {\n    animate.setAttribute(\"fill\", \"freeze\");\n  }\n  ele.appendChild(animate);\n};\n\nconst getPointer = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const img = searchParams.get(\"pointerImg\");\n  const width = searchParams.get(\"pointerWidth\");\n  const height = searchParams.get(\"pointerHeight\");\n  if (!img) {\n    return null;\n  }\n  return {\n    img,\n    width,\n    height,\n  };\n};\n\nconst pickOnePathItem = (path: string) => {\n  const items = path.match(/(M[^C]*C[^M]*)/g);\n  if (!items) {\n    return path;\n  }\n  if (items.length <= 2) {\n    return items[items.length - 1];\n  }\n  const [longestIndex] = items.reduce(\n    (prev, item, index) => {\n      const [, x1, y1, x2, y2] =\n        item.match(/M([\\d.-]+) ([\\d.-]+) C([\\d.-]+) ([\\d.-]+)/) || [];\n      const d = Math.hypot(Number(x2) - Number(x1), Number(y2) - Number(y1));\n      if (d > prev[1]) {\n        return [index, d];\n      }\n      return prev;\n    },\n    [0, 0]\n  );\n  return items[longestIndex];\n};\n\nconst animatePointer = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  path: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const pointer = getPointer();\n  if (!pointer) return;\n  const img = svg.ownerDocument.createElementNS(SVG_NS, \"image\");\n  img.setAttribute(\"href\", pointer.img);\n  if (pointer.width) {\n    img.setAttribute(\"width\", pointer.width);\n  }\n  if (pointer.height) {\n    img.setAttribute(\"height\", pointer.height);\n  }\n  hideBeforeAnimation(svg, img, currentMs, durationMs);\n  const animateMotion = svg.ownerDocument.createElementNS(\n    SVG_NS,\n    \"animateMotion\"\n  );\n  animateMotion.setAttribute(\"path\", pickOnePathItem(path));\n  animateMotion.setAttribute(\"begin\", `${currentMs}ms`);\n  animateMotion.setAttribute(\"dur\", `${durationMs}ms`);\n  img.appendChild(animateMotion);\n  ele.parentNode?.appendChild(img);\n};\n\nconst animatePath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  const repeat = cCount / mCount;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"M(\\\\S+) (\\\\S+)\",\n          \"((?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){\",\n          `${i}`, // skip count\n          \"})\",\n          \"(?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){1,}\",\n        ].join(\"\"),\n        \"g\"\n      ),\n      (...a) => {\n        const [x, y] = a[3]\n          ? a[3].match(/.* (\\S+) (\\S+)$/).slice(1, 3)\n          : [a[1], a[2]];\n        return (\n          `M${a[1]} ${a[2]}${a[3]}` +\n          ` C${x} ${y}, ${x} ${y}, ${x} ${y}`.repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n  animatePointer(svg, ele, dTo, currentMs, durationMs);\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nconst animateFillPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  if (dTo.includes(\"C\")) {\n    animatePath(svg, ele, currentMs, durationMs);\n    return;\n  }\n  const dFrom = dTo.replace(\n    new RegExp([\"M(\\\\S+) (\\\\S+)\", \"((?: L\\\\S+ \\\\S+){1,})\"].join(\"\")),\n    (...a) => {\n      return `M${a[1]} ${a[2]}` + a[3].replace(/L\\S+ \\S+/g, `L${a[1]} ${a[2]}`);\n    }\n  );\n  ele.setAttribute(\"d\", dFrom);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  ele.appendChild(animate);\n};\n\nconst animatePolygon = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  let dTo = ele.getAttribute(\"d\") || \"\";\n  let mCount = dTo.match(/M/g)?.length || 0;\n  let cCount = dTo.match(/C/g)?.length || 0;\n  if (mCount === cCount + 1) {\n    // workaround for round rect\n    dTo = dTo.replace(/^M\\S+ \\S+ M/, \"M\");\n    mCount = dTo.match(/M/g)?.length || 0;\n    cCount = dTo.match(/C/g)?.length || 0;\n  }\n  if (mCount !== cCount) throw new Error(\"unexpected m/c counts\");\n  const dups = ele.getAttribute(\"stroke-dasharray\") ? 1 : Math.min(2, mCount);\n  const repeat = mCount / dups;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"((?:\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \"){\",\n          `${i}`, // skip count\n          \"})\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \".*\",\n        ].join(\"\")\n      ),\n      (...a) => {\n        return (\n          `${a[1]}` +\n          [...Array(dups).keys()]\n            .map((d) => {\n              const [x, y] = a.slice(2 + dups * 2 + d * 2);\n              return `M${x} ${y} C${x} ${y}, ${x} ${y}, ${x} ${y} `;\n            })\n            .join(\"\")\n            .repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n    animatePointer(\n      svg,\n      ele,\n      dTo.replace(\n        new RegExp(\n          [\n            \"(?:\",\n            \"M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n            \"){\",\n            `${i}`, // skip count\n            \"}\",\n            \"(M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+) ?\".repeat(dups),\n            \".*\",\n          ].join(\"\")\n        ),\n        \"$1\"\n      ),\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n  }\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nlet pathForTextIndex = 0;\n\nconst animateText = (\n  svg: SVGSVGElement,\n  width: number,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const anchor = ele.getAttribute(\"text-anchor\") || \"start\";\n  if (anchor !== \"start\") {\n    // Not sure how to support it, fallback with opacity\n    const toOpacity = ele.getAttribute(\"opacity\") || \"1.0\";\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"opacity\");\n    animate.setAttribute(\"from\", \"0.0\");\n    animate.setAttribute(\"to\", toOpacity);\n    animate.setAttribute(\"begin\", `${currentMs}ms`);\n    animate.setAttribute(\"dur\", `${durationMs}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    ele.setAttribute(\"opacity\", \"0.0\");\n    return;\n  }\n  const x = Number(ele.getAttribute(\"x\") || 0);\n  const y = Number(ele.getAttribute(\"y\") || 0);\n  pathForTextIndex += 1;\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  path.setAttribute(\"id\", \"pathForText\" + pathForTextIndex);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", `m${x} ${y} h0`);\n  animate.setAttribute(\"to\", `m${x} ${y} h${width}`);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  path.appendChild(animate);\n  const textPath = svg.ownerDocument.createElementNS(SVG_NS, \"textPath\");\n  textPath.setAttribute(\"href\", \"#pathForText\" + pathForTextIndex);\n  textPath.textContent = ele.textContent;\n  ele.textContent = \" \"; // HACK for Firebox as `null` does not work\n  findNode(svg, \"defs\")?.appendChild(path);\n  ele.appendChild(textPath);\n  animatePointer(svg, ele, `m${x} ${y} h${width}`, currentMs, durationMs);\n};\n\nconst animateFromToPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  dFrom: string,\n  dTo: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  path.appendChild(animate);\n  ele.appendChild(path);\n};\n\nconst patchSvgLine = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  if (childNodes[0].getAttribute(\"fill-rule\")) {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs\n    );\n  }\n};\n\nconst patchSvgArrow = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const numParts = ele.childNodes.length;\n  animateLine(\n    svg,\n    ele.childNodes[0].childNodes[0] as SVGElement,\n    currentMs,\n    (durationMs / (numParts + 2)) * 3\n  );\n  currentMs += (durationMs / (numParts + 2)) * 3;\n  for (let i = 1; i < numParts; i += 1) {\n    const numChildren = ele.childNodes[i].childNodes.length;\n    for (let j = 0; j < numChildren; j += 1) {\n      animatePath(\n        svg,\n        ele.childNodes[i].childNodes[j] as SVGElement,\n        currentMs,\n        durationMs / (numParts + 2) / numChildren\n      );\n      currentMs += durationMs / (numParts + 2) / numChildren;\n    }\n  }\n};\n\nconst patchSvgRectangle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animatePolygon(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePolygon(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgEllipse = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animatePath(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePath(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgText = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  width: number,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  const len = childNodes.length;\n  childNodes.forEach((child) => {\n    animateText(svg, width, child, currentMs, durationMs / len);\n    currentMs += durationMs / len;\n  });\n};\n\nconst patchSvgFreedraw = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  freeDrawElement: NonDeleted<ExcalidrawFreeDrawElement>,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNode = ele.childNodes[0] as SVGPathElement;\n  childNode.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"0\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"calcMode\", \"discrete\");\n  animate.setAttribute(\"begin\", `${currentMs + durationMs - 1}ms`);\n  animate.setAttribute(\"dur\", `${1}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  childNode.appendChild(animate);\n  animatePointer(\n    svg,\n    childNode,\n    freeDrawElement.points.reduce(\n      (p, [x, y]) => (p ? p + ` T ${x} ${y}` : `M ${x} ${y}`),\n      \"\"\n    ),\n    currentMs,\n    durationMs\n  );\n\n  // interporation\n  const repeat = freeDrawElement.points.length;\n  let dTo = childNode.getAttribute(\"d\") as string;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom =\n      i > 0\n        ? getFreeDrawSvgPath({\n            ...freeDrawElement,\n            points: freeDrawElement.points.slice(0, i),\n          })\n        : \"M 0 0\";\n    animateFromToPath(\n      svg,\n      ele,\n      dFrom,\n      dTo,\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n    dTo = dFrom;\n  }\n};\n\nconst patchSvgEle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  excalidraElement: NonDeletedExcalidrawElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const { type, strokeSharpness, width } = excalidraElement;\n  if (type === \"line\") {\n    patchSvgLine(svg, ele, strokeSharpness, currentMs, durationMs);\n  } else if (type === \"arrow\") {\n    patchSvgArrow(svg, ele, strokeSharpness, currentMs, durationMs);\n  } else if (type === \"rectangle\" || type === \"diamond\") {\n    patchSvgRectangle(svg, ele, currentMs, durationMs);\n  } else if (type === \"ellipse\") {\n    patchSvgEllipse(svg, ele, currentMs, durationMs);\n  } else if (type === \"text\") {\n    patchSvgText(svg, ele, width, currentMs, durationMs);\n  } else if (excalidraElement.type === \"freedraw\") {\n    patchSvgFreedraw(svg, ele, excalidraElement, currentMs, durationMs);\n  }\n};\n\nconst createGroups = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  const groups: { [groupId: string]: (readonly [SVGElement, number])[] } = {};\n  let index = 0;\n  const childNodes = svg.childNodes as NodeListOf<SVGElement>;\n  childNodes.forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { groupIds } = elements[index];\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        groups[groupId] = groups[groupId] || [];\n        groups[groupId].push([ele, index] as const);\n      }\n      index += 1;\n    }\n  });\n  return groups;\n};\n\nconst filterGroupNodes = (nodes: NodeListOf<SVGElement>) =>\n  [...nodes].filter((node) => node.tagName === \"g\");\n\nconst extractNumberFromElement = (\n  element: NonDeletedExcalidrawElement,\n  key: string\n) => {\n  const match = element.id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return (match && Number(match[1])) || 0;\n};\n\nconst sortSvgNodes = (\n  nodes: SVGElement[],\n  elements: readonly NonDeletedExcalidrawElement[]\n) =>\n  [...nodes].sort((a, b) => {\n    const aIndex = nodes.indexOf(a);\n    const bIndex = nodes.indexOf(b);\n    const aOrder = extractNumberFromElement(elements[aIndex], \"animateOrder\");\n    const bOrder = extractNumberFromElement(elements[bIndex], \"animateOrder\");\n    return aOrder - bOrder;\n  });\n\nexport const animateSvg = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[],\n  startMs?: number\n) => {\n  let finishedMs;\n  const groups = createGroups(svg, elements);\n  const finished = new Map();\n  let current = startMs ?? 1000; // 1 sec margin\n  const groupDur = 5000;\n  const individualDur = 500;\n  const groupNodes = filterGroupNodes(svg.childNodes as NodeListOf<SVGElement>);\n  if (groupNodes.length !== elements.length) {\n    throw new Error(\"element length mismatch\");\n  }\n  const groupElement2Element = new Map(\n    groupNodes.map((ele, index) => [ele, elements[index]])\n  );\n  sortSvgNodes(groupNodes, elements).forEach((ele) => {\n    const element = groupElement2Element.get(\n      ele\n    ) as NonDeletedExcalidrawElement;\n    const { groupIds } = element;\n    if (!finished.has(ele)) {\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        const group = groups[groupId];\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") ||\n          groupDur / (group.length + 1);\n        patchSvgEle(svg, ele, element, current, dur);\n        current += dur;\n        finished.set(ele, true);\n        group.forEach(([childEle, childIndex]) => {\n          const dur =\n            extractNumberFromElement(elements[childIndex], \"animateDuration\") ||\n            groupDur / (group.length + 1);\n          if (!finished.has(childEle)) {\n            patchSvgEle(svg, childEle, elements[childIndex], current, dur);\n            current += dur;\n            finished.set(childEle, true);\n          }\n        });\n        delete groups[groupId];\n      } else {\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") || individualDur;\n        patchSvgEle(svg, ele, element, current, dur);\n        current += dur;\n        finished.set(ele, true);\n      }\n    }\n  });\n  finishedMs = current + 1000; // 1 sec margin\n  return { finishedMs };\n};\n\nexport const getBeginTimeList = (svg: SVGSVGElement) => {\n  const beginTimeList: number[] = [];\n  const tmpTimeList: number[] = [];\n  const findAnimate = (ele: SVGElement) => {\n    if (ele.tagName === \"animate\") {\n      const match = /([0-9.]+)ms/.exec(ele.getAttribute(\"begin\") || \"\");\n      if (match) {\n        tmpTimeList.push(Number(match[1]));\n      }\n    }\n    (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n      findAnimate(ele);\n    });\n  };\n  (svg.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      findAnimate(ele);\n      if (tmpTimeList.length) {\n        beginTimeList.push(Math.min(...tmpTimeList));\n        tmpTimeList.splice(0);\n      }\n    } else if (ele.tagName === \"defs\") {\n      (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n        findAnimate(ele);\n        if (tmpTimeList.length) {\n          beginTimeList.push(Math.min(...tmpTimeList));\n          tmpTimeList.splice(0);\n        }\n      });\n    }\n  });\n  return beginTimeList;\n};\n","import { fileSave } from \"browser-fs-access\";\n\nexport const exportToSvgFile = async (svg: SVGSVGElement) => {\n  const savedMs = svg.getCurrentTime();\n  svg.setCurrentTime(0);\n  const svgStr = new XMLSerializer().serializeToString(svg);\n  svg.setCurrentTime(savedMs);\n  await fileSave(new Blob([svgStr], { type: \"image/svg+xml\" }), {\n    fileName: \"excalidraw-animate.svg\",\n    extensions: [\".svg\"],\n  });\n};\n\nexport const exportToWebmFile = async (data: Blob) => {\n  await fileSave(new Blob([data], { type: \"video/webm\" }), {\n    fileName: \"excalidraw-animate.webm\",\n    extensions: [\".webm\"],\n  });\n};\n\nexport const prepareWebmData = (\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[]\n) =>\n  new Promise<Blob>(async (resolve, reject) => {\n    try {\n      const stream = (await (navigator.mediaDevices as any).getDisplayMedia({\n        video: {\n          cursor: \"never\",\n          displaySurface: \"browser\",\n        },\n      })) as MediaStream;\n      const recorder = new MediaRecorder(stream);\n      recorder.ondataavailable = (e) => {\n        resolve(e.data);\n      };\n      let maxFinishedMs = 0;\n      svgList.forEach(({ svg, finishedMs }) => {\n        maxFinishedMs = Math.max(maxFinishedMs, finishedMs);\n        svg.pauseAnimations();\n        svg.setCurrentTime(0);\n      });\n      recorder.start();\n      svgList.forEach(({ svg }) => {\n        svg.unpauseAnimations();\n      });\n      setTimeout(() => {\n        recorder.stop();\n        stream.getVideoTracks()[0].stop();\n      }, maxFinishedMs);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","import { restore } from \"@excalidraw/excalidraw\";\nimport type {\n  ImportedDataState\n} from \"@excalidraw/excalidraw/types/data/types\";\n\nconst t = (s: string) => s;\n\nconst BACKEND_GET = \"https://json.excalidraw.com/api/v1/\";\nconst BACKEND_V2_GET = \"https://json.excalidraw.com/api/v2/\";\nconst IV_LENGTH_BYTES = 12; // 96 bits\n\nconst getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\nconst decryptImported = async (\n  iv: ArrayBuffer,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n\n      let decrypted: ArrayBuffer;\n      try {\n        // Buffer should contain both the IV (fixed length) and encrypted data\n        const iv = buffer.slice(0, IV_LENGTH_BYTES);\n        const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n        decrypted = await decryptImported(iv, encrypted, privateKey);\n      } catch (error) {\n        // Fixed IV (old format, backward compatibility)\n        const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n        decrypted = await decryptImported(fixedIv, buffer, privateKey);\n      }\n\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data: ReturnType<typeof restore>;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n    );\n  } else {\n    data = restore(localDataState || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { exportToSvg, restoreElements } from \"@excalidraw/excalidraw\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { loadScene } from \"./vendor/loadScene\";\nimport { loadLibraryFromBlob } from \"./vendor/loadLibraryFromBlob\";\n\nimport { animateSvg } from \"./animate\";\n\nexport const getNonDeletedElements = (\n  elements: readonly ExcalidrawElement[]\n): NonDeletedExcalidrawElement[] =>\n  elements.filter(\n    (element): element is NonDeletedExcalidrawElement => !element.isDeleted\n  );\n\nconst importLibraryFromUrl = async (url: string) => {\n  try {\n    const request = await fetch(url);\n    const blob = await request.blob();\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      throw new Error();\n    }\n    return libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n  } catch (error) {\n    window.alert(\"Unable to load library\");\n    return [];\n  }\n};\n\nexport const useLoadSvg = () => {\n  const [loading, setLoading] = useState(true);\n  const [loadedSvgList, setLoadedSvgList] = useState<\n    {\n      svg: SVGSVGElement;\n      finishedMs: number;\n    }[]\n  >([]);\n\n  const loadDataList = useCallback(\n    (\n      dataList: {\n        elements: readonly ExcalidrawElement[];\n      }[],\n      inSequence?: boolean\n    ) => {\n      let startMs: number | undefined;\n      const svgList = dataList.map((data) => {\n        const elements = getNonDeletedElements(data.elements);\n        const svg = exportToSvg({\n          elements,\n          appState: {\n            exportBackground: true,\n            viewBackgroundColor: \"white\",\n            shouldAddWatermark: false,\n          },\n          exportPadding: 30,\n        });\n        const result = animateSvg(svg, elements, startMs);\n        console.log(svg);\n        if (inSequence) {\n          startMs = result.finishedMs;\n        }\n        return { svg, finishedMs: result.finishedMs };\n      });\n      setLoadedSvgList(svgList);\n      return svgList;\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const matchIdKey = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (matchIdKey) {\n        const [, id, key] = matchIdKey;\n        const data = await loadScene(id, key, null);\n        const [{ svg, finishedMs }] = loadDataList([data]);\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svg.setCurrentTime(finishedMs);\n        }\n      }\n      const matchLibrary = /(.*\\.excalidrawlib)/.exec(\n        searchParams.get(\"library\") || \"\"\n      );\n      if (matchLibrary) {\n        const [, url] = matchLibrary;\n        const dataList = await importLibraryFromUrl(url);\n        const svgList = loadDataList(\n          dataList.map((elements) => ({ elements })),\n          searchParams.has(\"sequence\")\n        );\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svgList.forEach(({ svg, finishedMs }) => {\n            svg.setCurrentTime(finishedMs);\n          });\n        }\n      }\n      setLoading(false);\n    })();\n  }, [loadDataList]);\n\n  return { loading, loadedSvgList, loadDataList };\n};\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { fileOpen } from \"browser-fs-access\";\n\nimport { restoreElements } from \"@excalidraw/excalidraw\";\nimport type { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { loadLibraryFromBlob } from \"./vendor/loadLibraryFromBlob\";\nimport { loadFromJSON } from \"./vendor/loadFromJSON\";\n\nimport \"./Toolbar.css\";\nimport GitHubCorner from \"./GitHubCorner\";\nimport { getBeginTimeList } from \"./animate\";\nimport { exportToSvgFile, exportToWebmFile, prepareWebmData } from \"./export\";\nimport { getNonDeletedElements } from \"./useLoadSvg\";\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)|^http.*\\.excalidrawlib$/;\n\nconst getCombinedBeginTimeList = (svgList: Props[\"svgList\"]) => {\n  const beginTimeList = ([] as number[]).concat(\n    ...svgList.map(({ svg }) =>\n      getBeginTimeList(svg).map((n) => Math.floor(n * 100) / 100)\n    )\n  );\n  return [...new Set(beginTimeList)].sort((a, b) => a - b);\n};\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n  loadDataList: (data: { elements: readonly ExcalidrawElement[] }[]) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ svgList, loadDataList }) => {\n  const [showToolbar, setShowToolbar] = useState<boolean | \"never\">(false);\n  const [paused, setPaused] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [link, setLink] = useState(\"\");\n  const [webmData, setWebmData] = useState<Blob>();\n  useEffect(() => {\n    setWebmData(undefined);\n  }, [svgList]);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (paused) {\n        svg.pauseAnimations();\n      } else {\n        svg.unpauseAnimations();\n      }\n    });\n  }, [svgList, paused]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    } else {\n      setShowToolbar(\"never\");\n    }\n  }, []);\n\n  const loadFile = async () => {\n    const data = await loadFromJSON(null);\n    loadDataList([data]);\n  };\n\n  const loadLibrary = async () => {\n    const blob = await fileOpen({\n      description: \"Excalidraw library files\",\n      extensions: [\".json\", \".excalidrawlib\"],\n      mimeTypes: [\"application/json\"],\n    });\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      window.alert(\"Unable to load library\");\n      return;\n    }\n    const dataList = libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n    loadDataList(dataList.map((elements) => ({ elements })));\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    if (match[1]) {\n      window.location.hash = match[0];\n    } else {\n      window.location.hash = `library=${match[0]}`;\n    }\n    window.location.reload();\n  };\n\n  const togglePausedAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    setPaused((p) => !p);\n  }, [svgList]);\n\n  const timer = useRef<NodeJS.Timeout>();\n  const stepForwardAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    const beginTimeList = getCombinedBeginTimeList(svgList);\n    const currentTime = svgList[0].svg.getCurrentTime() * 1000;\n    let nextTime = beginTimeList.find((t) => t >= currentTime + 100);\n    if (!nextTime) {\n      nextTime = currentTime + 500;\n    }\n    clearTimeout(timer.current as NodeJS.Timeout);\n    svgList.forEach(({ svg }) => {\n      svg.unpauseAnimations();\n    });\n    timer.current = setTimeout(() => {\n      svgList.forEach(({ svg }) => {\n        svg.pauseAnimations();\n        svg.setCurrentTime((nextTime as number) / 1000);\n      });\n      setPaused(true);\n    }, nextTime - currentTime);\n  }, [svgList]);\n\n  const resetAnimations = useCallback(() => {\n    svgList.forEach(({ svg }) => {\n      svg.setCurrentTime(0);\n    });\n  }, [svgList]);\n\n  useEffect(() => {\n    const onKeydown = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === \"p\") {\n        togglePausedAnimations();\n      } else if (e.key.toLowerCase() === \"s\") {\n        stepForwardAnimations();\n      } else if (e.key.toLowerCase() === \"r\") {\n        resetAnimations();\n      } else if (e.key.toLowerCase() === \"q\") {\n        // toggle toolbar\n        setShowToolbar((s) => (typeof s === \"boolean\" ? !s : s));\n      } else {\n        // show toolbar otherwise\n        setShowToolbar((s) => (typeof s === \"boolean\" ? true : s));\n      }\n    };\n    document.addEventListener(\"keydown\", onKeydown);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeydown);\n    };\n  }, [togglePausedAnimations, stepForwardAnimations, resetAnimations]);\n\n  const hideToolbar = () => {\n    setShowToolbar((s) => (typeof s === \"boolean\" ? false : s));\n  };\n\n  const exportToSvg = () => {\n    if (!svgList.length) {\n      return;\n    }\n    svgList.forEach(({ svg }) => {\n      exportToSvgFile(svg);\n    });\n  };\n\n  const exportToWebm = async () => {\n    if (!svgList.length) {\n      return;\n    }\n    if (webmData) {\n      await exportToWebmFile(webmData);\n      return;\n    }\n    setProcessing(true);\n    setShowToolbar(false);\n    try {\n      const data = await prepareWebmData(svgList);\n      setWebmData(data);\n    } catch (e) {\n      console.log(e);\n    }\n    setShowToolbar(true);\n    setProcessing(false);\n  };\n\n  if (showToolbar !== true) {\n    return null;\n  }\n\n  return (\n    <div className=\"Toolbar\">\n      <div className=\"Toolbar-loader\">\n        <button type=\"button\" onClick={loadFile}>\n          Load File\n        </button>\n        <span>OR</span>\n        <button type=\"button\" onClick={loadLibrary}>\n          Load Library\n        </button>\n        <span>OR</span>\n        <form onSubmit={loadLink}>\n          <input\n            placeholder=\"Enter link...\"\n            value={link}\n            onChange={(e) => setLink(e.target.value)}\n          />\n          <button type=\"submit\" disabled={!linkRegex.test(link)}>\n            Animate!\n          </button>\n        </form>\n      </div>\n      {!!svgList.length && (\n        <div className=\"Toolbar-controller\">\n          <button type=\"button\" onClick={togglePausedAnimations}>\n            {paused ? \"Play (P)\" : \"Pause (P)\"}\n          </button>\n          <button type=\"button\" onClick={stepForwardAnimations}>\n            Step (S)\n          </button>\n          <button type=\"button\" onClick={resetAnimations}>\n            Reset (R)\n          </button>\n          <button type=\"button\" onClick={hideToolbar}>\n            Hide Toolbar (Q)\n          </button>\n          <button type=\"button\" onClick={exportToSvg}>\n            Export to SVG\n          </button>\n          <button type=\"button\" onClick={exportToWebm} disabled={processing}>\n            {processing\n              ? \"Processing...\"\n              : webmData\n              ? \"Export to WebM\"\n              : \"Prepare WebM\"}\n          </button>\n        </div>\n      )}\n      <GitHubCorner\n        link=\"https://github.com/dai-shi/excalidraw-animate\"\n        size={40}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n};\n\nconst Viewer: React.FC<Props> = ({ svgList }) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (ref.current) {\n        ref.current.appendChild(svg);\n      }\n    });\n    return () => {\n      svgList.forEach(({ svg }) => {\n        svg.remove();\n      });\n    };\n  }, [svgList]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"autoplay\") === \"no\") {\n      if (ref.current) {\n        const ele = ref.current;\n        const callback = () => {\n          svgList.forEach(({ svg }) => {\n            svg.setCurrentTime(0);\n            svg.unpauseAnimations();\n          });\n        };\n        ele.addEventListener(\"click\", callback);\n        return () => {\n          ele.removeEventListener(\"click\", callback);\n        };\n      }\n    }\n  }, [svgList]);\n\n  const repeat = Math.ceil(Math.sqrt(svgList.length));\n  const grids = `repeat(${repeat}, ${100 / repeat}%)`;\n\n  return (\n    <div\n      className=\"Viewer\"\n      style={{\n        gridTemplateColumns: grids,\n        gridTemplateRows: grids,\n      }}\n      ref={ref}\n    ></div>\n  );\n};\n\nexport default Viewer;\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadSvg } from \"./useLoadSvg\";\n\nconst App: React.FC = () => {\n  const { loading, loadedSvgList, loadDataList } = useLoadSvg();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      <Toolbar svgList={loadedSvgList} loadDataList={loadDataList} />\n      {!!loadedSvgList.length && <Viewer svgList={loadedSvgList} />}\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}