{"version":3,"sources":["GitHubCorner.tsx","animate.ts","export.ts","vendor/loadScene.ts","useLoadSvg.ts","Toolbar.tsx","Viewer.tsx","App.tsx","index.tsx"],"names":["GitHubCorner","link","size","fill","color","href","className","target","rel","width","height","viewBox","style","position","top","border","right","d","transformOrigin","SVG_NS","hideBeforeAnimation","svg","ele","currentMs","durationMs","freeze","setAttribute","animate","ownerDocument","createElementNS","appendChild","animatePointer","path","options","pointerImg","img","pointerWidth","pointerHeight","animateMotion","items","match","length","reduce","prev","item","index","x1","y1","x2","y2","Math","hypot","Number","pickOnePathItem","parentNode","animatePath","dTo","getAttribute","mCount","repeat","dLast","i","dFrom","replace","RegExp","join","a","slice","x","y","animateFillPath","includes","animatePolygon","cCount","Error","dups","min","Array","keys","map","pathForTextIndex","animateFromToPath","patchSvgText","childNodes","len","forEach","child","toOpacity","textPath","textContent","name","tagName","findNode","animateText","patchSvgEle","excalidraElement","type","strokeSharpness","animateLine","patchSvgLine","numParts","numChildren","j","patchSvgArrow","patchSvgRectangle","patchSvgEllipse","freeDrawElement","childNode","points","p","getFreeDrawSvgPath","patchSvgFreedraw","createGroups","elements","groups","groupIds","groupId","push","filterGroupNodes","nodes","filter","node","extractNumberFromElement","element","key","id","sortSvgNodes","sort","b","aIndex","indexOf","bIndex","animateSvg","finished","Map","current","startMs","groupDur","individualDur","groupNodes","groupElement2Element","get","has","group","dur","set","childEle","childIndex","finishedMs","exportToSvgFile","savedMs","getCurrentTime","setCurrentTime","svgStr","XMLSerializer","serializeToString","fileSave","Blob","fileName","extensions","exportToWebmFile","data","prepareWebmData","svgList","Promise","resolve","reject","navigator","mediaDevices","getDisplayMedia","video","cursor","displaySurface","stream","recorder","MediaRecorder","ondataavailable","e","maxFinishedMs","max","pauseAnimations","start","unpauseAnimations","setTimeout","stop","getVideoTracks","getImportedKey","usage","window","crypto","subtle","importKey","alg","ext","k","key_ops","kty","decryptImported","iv","encrypted","privateKey","decrypt","importFromBackend","fetch","response","ok","alert","arrayBuffer","buffer","byteLength","decrypted","fixedIv","Uint8Array","string","TextDecoder","decode","JSON","parse","json","appState","console","error","loadScene","localDataState","restore","commitToHistory","getNonDeletedElements","isDeleted","importLibraryFromUrl","url","request","blob","loadLibraryFromBlob","libraryFile","library","libraryItem","restoreElements","loadFromJSON","fileOpen","description","loadFromBlob","linkRegex","getCombinedBeginTimeList","beginTimeList","concat","tmpTimeList","findAnimate","exec","splice","getBeginTimeList","n","floor","Set","Toolbar","loadDataList","useState","showToolbar","setShowToolbar","paused","setPaused","processing","setProcessing","setLink","webmData","setWebmData","useEffect","undefined","hash","location","URLSearchParams","loadFile","loadLibrary","mimeTypes","dataList","togglePausedAnimations","useCallback","timer","useRef","stepForwardAnimations","currentTime","nextTime","find","t","clearTimeout","resetAnimations","onKeydown","toLowerCase","s","document","addEventListener","removeEventListener","exportToWebm","log","onClick","onSubmit","event","preventDefault","reload","placeholder","value","onChange","disabled","test","Viewer","ref","remove","callback","ceil","sqrt","grids","gridTemplateColumns","gridTemplateRows","App","loading","setLoading","loadedSvgList","setLoadedSvgList","inSequence","searchParams","all","exportToSvg","exportBackground","viewBackgroundColor","exportPadding","result","matchIdKey","matchLibrary","useLoadSvg","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.816e3b95.chunk.js","sourcesContent":["import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\ntype Props = {\n  link: string;\n  size?: number;\n  fill?: string;\n  color?: string;\n};\n\n// http://tholman.com/github-corners/\nconst GitHubCorner: React.FC<Props> = ({ link, size, fill, color }) => (\n  <a\n    href={link}\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n);\n\nexport default GitHubCorner;\n","import type {\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { getFreeDrawSvgPath } from \"@excalidraw/excalidraw\";\n\ntype AnimateOptions = {\n  startMs?: number;\n  pointerImg?: string;\n  pointerWidth?: string;\n  pointerHeight?: string;\n};\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst findNode = (ele: SVGElement, name: string) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  for (let i = 0; i < childNodes.length; ++i) {\n    if (childNodes[i].tagName === name) {\n      return childNodes[i];\n    }\n  }\n  return null;\n};\n\nconst hideBeforeAnimation = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  freeze?: boolean\n) => {\n  ele.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"1\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  if (freeze) {\n    animate.setAttribute(\"fill\", \"freeze\");\n  }\n  ele.appendChild(animate);\n};\n\nconst pickOnePathItem = (path: string) => {\n  const items = path.match(/(M[^C]*C[^M]*)/g);\n  if (!items) {\n    return path;\n  }\n  if (items.length <= 2) {\n    return items[items.length - 1];\n  }\n  const [longestIndex] = items.reduce(\n    (prev, item, index) => {\n      const [, x1, y1, x2, y2] =\n        item.match(/M([\\d.-]+) ([\\d.-]+) C([\\d.-]+) ([\\d.-]+)/) || [];\n      const d = Math.hypot(Number(x2) - Number(x1), Number(y2) - Number(y1));\n      if (d > prev[1]) {\n        return [index, d];\n      }\n      return prev;\n    },\n    [0, 0]\n  );\n  return items[longestIndex];\n};\n\nconst animatePointer = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  path: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (!options.pointerImg) return;\n  const img = svg.ownerDocument.createElementNS(SVG_NS, \"image\");\n  img.setAttribute(\"href\", options.pointerImg);\n  if (options.pointerWidth) {\n    img.setAttribute(\"width\", options.pointerWidth);\n  }\n  if (options.pointerHeight) {\n    img.setAttribute(\"height\", options.pointerHeight);\n  }\n  hideBeforeAnimation(svg, img, currentMs, durationMs);\n  const animateMotion = svg.ownerDocument.createElementNS(\n    SVG_NS,\n    \"animateMotion\"\n  );\n  animateMotion.setAttribute(\"path\", pickOnePathItem(path));\n  animateMotion.setAttribute(\"begin\", `${currentMs}ms`);\n  animateMotion.setAttribute(\"dur\", `${durationMs}ms`);\n  img.appendChild(animateMotion);\n  ele.parentNode?.appendChild(img);\n};\n\nconst animatePath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  const repeat = cCount / mCount;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"M(\\\\S+) (\\\\S+)\",\n          \"((?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){\",\n          `${i}`, // skip count\n          \"})\",\n          \"(?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){1,}\",\n        ].join(\"\"),\n        \"g\"\n      ),\n      (...a) => {\n        const [x, y] = a[3]\n          ? a[3].match(/.* (\\S+) (\\S+)$/).slice(1, 3)\n          : [a[1], a[2]];\n        return (\n          `M${a[1]} ${a[2]}${a[3]}` +\n          ` C${x} ${y}, ${x} ${y}, ${x} ${y}`.repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n  animatePointer(svg, ele, dTo, currentMs, durationMs, options);\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nconst animateFillPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  if (dTo.includes(\"C\")) {\n    animatePath(svg, ele, currentMs, durationMs, options);\n    return;\n  }\n  const dFrom = dTo.replace(\n    new RegExp([\"M(\\\\S+) (\\\\S+)\", \"((?: L\\\\S+ \\\\S+){1,})\"].join(\"\")),\n    (...a) => {\n      return `M${a[1]} ${a[2]}` + a[3].replace(/L\\S+ \\S+/g, `L${a[1]} ${a[2]}`);\n    }\n  );\n  ele.setAttribute(\"d\", dFrom);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  ele.appendChild(animate);\n};\n\nconst animatePolygon = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  let dTo = ele.getAttribute(\"d\") || \"\";\n  let mCount = dTo.match(/M/g)?.length || 0;\n  let cCount = dTo.match(/C/g)?.length || 0;\n  if (mCount === cCount + 1) {\n    // workaround for round rect\n    dTo = dTo.replace(/^M\\S+ \\S+ M/, \"M\");\n    mCount = dTo.match(/M/g)?.length || 0;\n    cCount = dTo.match(/C/g)?.length || 0;\n  }\n  if (mCount !== cCount) throw new Error(\"unexpected m/c counts\");\n  const dups = ele.getAttribute(\"stroke-dasharray\") ? 1 : Math.min(2, mCount);\n  const repeat = mCount / dups;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"((?:\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \"){\",\n          `${i}`, // skip count\n          \"})\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \".*\",\n        ].join(\"\")\n      ),\n      (...a) => {\n        return (\n          `${a[1]}` +\n          [...Array(dups).keys()]\n            .map((d) => {\n              const [x, y] = a.slice(2 + dups * 2 + d * 2);\n              return `M${x} ${y} C${x} ${y}, ${x} ${y}, ${x} ${y} `;\n            })\n            .join(\"\")\n            .repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n    animatePointer(\n      svg,\n      ele,\n      dTo.replace(\n        new RegExp(\n          [\n            \"(?:\",\n            \"M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n            \"){\",\n            `${i}`, // skip count\n            \"}\",\n            \"(M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+) ?\".repeat(dups),\n            \".*\",\n          ].join(\"\")\n        ),\n        \"$1\"\n      ),\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat,\n      options\n    );\n  }\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nlet pathForTextIndex = 0;\n\nconst animateText = (\n  svg: SVGSVGElement,\n  width: number,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const anchor = ele.getAttribute(\"text-anchor\") || \"start\";\n  if (anchor !== \"start\") {\n    // Not sure how to support it, fallback with opacity\n    const toOpacity = ele.getAttribute(\"opacity\") || \"1.0\";\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"opacity\");\n    animate.setAttribute(\"from\", \"0.0\");\n    animate.setAttribute(\"to\", toOpacity);\n    animate.setAttribute(\"begin\", `${currentMs}ms`);\n    animate.setAttribute(\"dur\", `${durationMs}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    ele.setAttribute(\"opacity\", \"0.0\");\n    return;\n  }\n  const x = Number(ele.getAttribute(\"x\") || 0);\n  const y = Number(ele.getAttribute(\"y\") || 0);\n  pathForTextIndex += 1;\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  path.setAttribute(\"id\", \"pathForText\" + pathForTextIndex);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", `m${x} ${y} h0`);\n  animate.setAttribute(\"to\", `m${x} ${y} h${width}`);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  path.appendChild(animate);\n  const textPath = svg.ownerDocument.createElementNS(SVG_NS, \"textPath\");\n  textPath.setAttribute(\"href\", \"#pathForText\" + pathForTextIndex);\n  textPath.textContent = ele.textContent;\n  ele.textContent = \" \"; // HACK for Firebox as `null` does not work\n  findNode(svg, \"defs\")?.appendChild(path);\n  ele.appendChild(textPath);\n  animatePointer(\n    svg,\n    ele,\n    `m${x} ${y} h${width}`,\n    currentMs,\n    durationMs,\n    options\n  );\n};\n\nconst animateFromToPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  dFrom: string,\n  dTo: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  path.appendChild(animate);\n  ele.appendChild(path);\n};\n\nconst patchSvgLine = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  if (childNodes[0].getAttribute(\"fill-rule\")) {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgArrow = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const numParts = ele.childNodes.length;\n  animateLine(\n    svg,\n    ele.childNodes[0].childNodes[0] as SVGElement,\n    currentMs,\n    (durationMs / (numParts + 2)) * 3,\n    options\n  );\n  currentMs += (durationMs / (numParts + 2)) * 3;\n  for (let i = 1; i < numParts; i += 1) {\n    const numChildren = ele.childNodes[i].childNodes.length;\n    for (let j = 0; j < numChildren; j += 1) {\n      animatePath(\n        svg,\n        ele.childNodes[i].childNodes[j] as SVGElement,\n        currentMs,\n        durationMs / (numParts + 2) / numChildren,\n        options\n      );\n      currentMs += durationMs / (numParts + 2) / numChildren;\n    }\n  }\n};\n\nconst patchSvgRectangle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (ele.childNodes[1]) {\n    animatePolygon(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animatePolygon(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgEllipse = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  if (ele.childNodes[1]) {\n    animatePath(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75,\n      options\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25,\n      options\n    );\n  } else {\n    animatePath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst patchSvgText = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  width: number,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  const len = childNodes.length;\n  childNodes.forEach((child) => {\n    animateText(svg, width, child, currentMs, durationMs / len, options);\n    currentMs += durationMs / len;\n  });\n};\n\nconst patchSvgFreedraw = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  freeDrawElement: NonDeleted<ExcalidrawFreeDrawElement>,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const childNode = ele.childNodes[0] as SVGPathElement;\n  childNode.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"0\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"calcMode\", \"discrete\");\n  animate.setAttribute(\"begin\", `${currentMs + durationMs - 1}ms`);\n  animate.setAttribute(\"dur\", `${1}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  childNode.appendChild(animate);\n  animatePointer(\n    svg,\n    childNode,\n    freeDrawElement.points.reduce(\n      (p, [x, y]) => (p ? p + ` T ${x} ${y}` : `M ${x} ${y}`),\n      \"\"\n    ),\n    currentMs,\n    durationMs,\n    options\n  );\n\n  // interporation\n  const repeat = freeDrawElement.points.length;\n  let dTo = childNode.getAttribute(\"d\") as string;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom =\n      i > 0\n        ? getFreeDrawSvgPath({\n            ...freeDrawElement,\n            points: freeDrawElement.points.slice(0, i),\n          })\n        : \"M 0 0\";\n    animateFromToPath(\n      svg,\n      ele,\n      dFrom,\n      dTo,\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n    dTo = dFrom;\n  }\n};\n\nconst patchSvgEle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  excalidraElement: NonDeletedExcalidrawElement,\n  currentMs: number,\n  durationMs: number,\n  options: AnimateOptions\n) => {\n  const { type, strokeSharpness, width } = excalidraElement;\n  if (type === \"line\") {\n    patchSvgLine(svg, ele, strokeSharpness, currentMs, durationMs, options);\n  } else if (type === \"arrow\") {\n    patchSvgArrow(svg, ele, strokeSharpness, currentMs, durationMs, options);\n  } else if (type === \"rectangle\" || type === \"diamond\") {\n    patchSvgRectangle(svg, ele, currentMs, durationMs, options);\n  } else if (type === \"ellipse\") {\n    patchSvgEllipse(svg, ele, currentMs, durationMs, options);\n  } else if (type === \"text\") {\n    patchSvgText(svg, ele, width, currentMs, durationMs, options);\n  } else if (excalidraElement.type === \"freedraw\") {\n    patchSvgFreedraw(\n      svg,\n      ele,\n      excalidraElement,\n      currentMs,\n      durationMs,\n      options\n    );\n  }\n};\n\nconst createGroups = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  const groups: { [groupId: string]: (readonly [SVGElement, number])[] } = {};\n  let index = 0;\n  const childNodes = svg.childNodes as NodeListOf<SVGElement>;\n  childNodes.forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { groupIds } = elements[index];\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        groups[groupId] = groups[groupId] || [];\n        groups[groupId].push([ele, index] as const);\n      }\n      index += 1;\n    }\n  });\n  return groups;\n};\n\nconst filterGroupNodes = (nodes: NodeListOf<SVGElement>) =>\n  [...nodes].filter((node) => node.tagName === \"g\");\n\nconst extractNumberFromElement = (\n  element: NonDeletedExcalidrawElement,\n  key: string\n) => {\n  const match = element.id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return (match && Number(match[1])) || 0;\n};\n\nconst sortSvgNodes = (\n  nodes: SVGElement[],\n  elements: readonly NonDeletedExcalidrawElement[]\n) =>\n  [...nodes].sort((a, b) => {\n    const aIndex = nodes.indexOf(a);\n    const bIndex = nodes.indexOf(b);\n    const aOrder = extractNumberFromElement(elements[aIndex], \"animateOrder\");\n    const bOrder = extractNumberFromElement(elements[bIndex], \"animateOrder\");\n    return aOrder - bOrder;\n  });\n\nexport const animateSvg = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[],\n  options: AnimateOptions = {}\n) => {\n  let finishedMs;\n  const groups = createGroups(svg, elements);\n  const finished = new Map();\n  let current = options.startMs ?? 1000; // 1 sec margin\n  const groupDur = 5000;\n  const individualDur = 500;\n  const groupNodes = filterGroupNodes(svg.childNodes as NodeListOf<SVGElement>);\n  if (groupNodes.length !== elements.length) {\n    throw new Error(\"element length mismatch\");\n  }\n  const groupElement2Element = new Map(\n    groupNodes.map((ele, index) => [ele, elements[index]])\n  );\n  sortSvgNodes(groupNodes, elements).forEach((ele) => {\n    const element = groupElement2Element.get(\n      ele\n    ) as NonDeletedExcalidrawElement;\n    const { groupIds } = element;\n    if (!finished.has(ele)) {\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        const group = groups[groupId];\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") ||\n          groupDur / (group.length + 1);\n        patchSvgEle(svg, ele, element, current, dur, options);\n        current += dur;\n        finished.set(ele, true);\n        group.forEach(([childEle, childIndex]) => {\n          const dur =\n            extractNumberFromElement(elements[childIndex], \"animateDuration\") ||\n            groupDur / (group.length + 1);\n          if (!finished.has(childEle)) {\n            patchSvgEle(\n              svg,\n              childEle,\n              elements[childIndex],\n              current,\n              dur,\n              options\n            );\n            current += dur;\n            finished.set(childEle, true);\n          }\n        });\n        delete groups[groupId];\n      } else {\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") || individualDur;\n        patchSvgEle(svg, ele, element, current, dur, options);\n        current += dur;\n        finished.set(ele, true);\n      }\n    }\n  });\n  finishedMs = current + 1000; // 1 sec margin\n  return { finishedMs };\n};\n\nexport const getBeginTimeList = (svg: SVGSVGElement) => {\n  const beginTimeList: number[] = [];\n  const tmpTimeList: number[] = [];\n  const findAnimate = (ele: SVGElement) => {\n    if (ele.tagName === \"animate\") {\n      const match = /([0-9.]+)ms/.exec(ele.getAttribute(\"begin\") || \"\");\n      if (match) {\n        tmpTimeList.push(Number(match[1]));\n      }\n    }\n    (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n      findAnimate(ele);\n    });\n  };\n  (svg.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      findAnimate(ele);\n      if (tmpTimeList.length) {\n        beginTimeList.push(Math.min(...tmpTimeList));\n        tmpTimeList.splice(0);\n      }\n    } else if (ele.tagName === \"defs\") {\n      (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n        findAnimate(ele);\n        if (tmpTimeList.length) {\n          beginTimeList.push(Math.min(...tmpTimeList));\n          tmpTimeList.splice(0);\n        }\n      });\n    }\n  });\n  return beginTimeList;\n};\n","import { fileSave } from \"browser-fs-access\";\n\nexport const exportToSvgFile = async (svg: SVGSVGElement) => {\n  const savedMs = svg.getCurrentTime();\n  svg.setCurrentTime(0);\n  const svgStr = new XMLSerializer().serializeToString(svg);\n  svg.setCurrentTime(savedMs);\n  await fileSave(new Blob([svgStr], { type: \"image/svg+xml\" }), {\n    fileName: \"excalidraw-animate.svg\",\n    extensions: [\".svg\"],\n  });\n};\n\nexport const exportToWebmFile = async (data: Blob) => {\n  await fileSave(new Blob([data], { type: \"video/webm\" }), {\n    fileName: \"excalidraw-animate.webm\",\n    extensions: [\".webm\"],\n  });\n};\n\nexport const prepareWebmData = (\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[]\n) =>\n  new Promise<Blob>(async (resolve, reject) => {\n    try {\n      const stream = (await (navigator.mediaDevices as any).getDisplayMedia({\n        video: {\n          cursor: \"never\",\n          displaySurface: \"browser\",\n        },\n      })) as MediaStream;\n      const recorder = new MediaRecorder(stream);\n      recorder.ondataavailable = (e) => {\n        resolve(e.data);\n      };\n      let maxFinishedMs = 0;\n      svgList.forEach(({ svg, finishedMs }) => {\n        maxFinishedMs = Math.max(maxFinishedMs, finishedMs);\n        svg.pauseAnimations();\n        svg.setCurrentTime(0);\n      });\n      recorder.start();\n      svgList.forEach(({ svg }) => {\n        svg.unpauseAnimations();\n      });\n      setTimeout(() => {\n        recorder.stop();\n        stream.getVideoTracks()[0].stop();\n      }, maxFinishedMs);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","import { restore } from \"@excalidraw/excalidraw\";\nimport type {\n  ImportedDataState\n} from \"@excalidraw/excalidraw/types/data/types\";\n\nconst t = (s: string) => s;\n\nconst BACKEND_GET = \"https://json.excalidraw.com/api/v1/\";\nconst BACKEND_V2_GET = \"https://json.excalidraw.com/api/v2/\";\nconst IV_LENGTH_BYTES = 12; // 96 bits\n\nconst getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\nconst decryptImported = async (\n  iv: ArrayBuffer,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n\n      let decrypted: ArrayBuffer;\n      try {\n        // Buffer should contain both the IV (fixed length) and encrypted data\n        const iv = buffer.slice(0, IV_LENGTH_BYTES);\n        const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n        decrypted = await decryptImported(iv, encrypted, privateKey);\n      } catch (error) {\n        // Fixed IV (old format, backward compatibility)\n        const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n        decrypted = await decryptImported(fixedIv, buffer, privateKey);\n      }\n\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data: ReturnType<typeof restore>;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n      null,\n    );\n  } else {\n    data = restore(localDataState || null, null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport {\n  exportToSvg,\n  restoreElements,\n  loadLibraryFromBlob,\n} from \"@excalidraw/excalidraw\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\n\nimport { loadScene } from \"./vendor/loadScene\";\n\nimport { animateSvg } from \"./animate\";\n\nexport const getNonDeletedElements = (\n  elements: readonly ExcalidrawElement[]\n): NonDeletedExcalidrawElement[] =>\n  elements.filter(\n    (element): element is NonDeletedExcalidrawElement => !element.isDeleted\n  );\n\nconst importLibraryFromUrl = async (url: string) => {\n  try {\n    const request = await fetch(url);\n    const blob = await request.blob();\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      throw new Error();\n    }\n    return libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem, null))\n    );\n  } catch (error) {\n    window.alert(\"Unable to load library\");\n    return [];\n  }\n};\n\nexport const useLoadSvg = () => {\n  const [loading, setLoading] = useState(true);\n  const [loadedSvgList, setLoadedSvgList] = useState<\n    {\n      svg: SVGSVGElement;\n      finishedMs: number;\n    }[]\n  >([]);\n\n  const loadDataList = useCallback(\n    async (\n      dataList: {\n        elements: readonly ExcalidrawElement[];\n      }[],\n      inSequence?: boolean\n    ) => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const options = {\n        startMs: undefined as number | undefined,\n        pointerImg: searchParams.get(\"pointerImg\") || undefined,\n        pointerWidth: searchParams.get(\"pointerWidth\") || undefined,\n        pointerHeight: searchParams.get(\"pointerHeight\") || undefined,\n      };\n      const svgList = await Promise.all(\n        dataList.map(async (data) => {\n          const elements = getNonDeletedElements(data.elements);\n          const svg = await exportToSvg({\n            elements,\n            appState: {\n              exportBackground: true,\n              viewBackgroundColor: \"white\",\n            },\n            exportPadding: 30,\n          });\n          const result = animateSvg(svg, elements, options);\n          console.log(svg);\n          if (inSequence) {\n            options.startMs = result.finishedMs;\n          }\n          return { svg, finishedMs: result.finishedMs };\n        })\n      );\n      setLoadedSvgList(svgList);\n      return svgList;\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const matchIdKey = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (matchIdKey) {\n        const [, id, key] = matchIdKey;\n        const data = await loadScene(id, key, null);\n        const [{ svg, finishedMs }] = await loadDataList([data]);\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svg.setCurrentTime(finishedMs);\n        }\n      }\n      const matchLibrary = /(.*\\.excalidrawlib)/.exec(\n        searchParams.get(\"library\") || \"\"\n      );\n      if (matchLibrary) {\n        const [, url] = matchLibrary;\n        const dataList = await importLibraryFromUrl(url);\n        const svgList = await loadDataList(\n          dataList.map((elements) => ({ elements })),\n          searchParams.has(\"sequence\")\n        );\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svgList.forEach(({ svg, finishedMs }) => {\n            svg.setCurrentTime(finishedMs);\n          });\n        }\n      }\n      setLoading(false);\n    })();\n  }, [loadDataList]);\n\n  return { loading, loadedSvgList, loadDataList };\n};\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { fileOpen } from \"browser-fs-access\";\n\nimport {\n  restoreElements,\n  loadLibraryFromBlob,\n  loadFromBlob,\n} from \"@excalidraw/excalidraw\";\nimport type { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\n\nimport \"./Toolbar.css\";\nimport GitHubCorner from \"./GitHubCorner\";\nimport { getBeginTimeList } from \"./animate\";\nimport { exportToSvgFile, exportToWebmFile, prepareWebmData } from \"./export\";\nimport { getNonDeletedElements } from \"./useLoadSvg\";\n\nconst loadFromJSON = async () => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n  });\n  return loadFromBlob(blob, null, null);\n};\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)|^http.*\\.excalidrawlib$/;\n\nconst getCombinedBeginTimeList = (svgList: Props[\"svgList\"]) => {\n  const beginTimeList = ([] as number[]).concat(\n    ...svgList.map(({ svg }) =>\n      getBeginTimeList(svg).map((n) => Math.floor(n * 100) / 100)\n    )\n  );\n  return [...new Set(beginTimeList)].sort((a, b) => a - b);\n};\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n  loadDataList: (data: { elements: readonly ExcalidrawElement[] }[]) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ svgList, loadDataList }) => {\n  const [showToolbar, setShowToolbar] = useState<boolean | \"never\">(false);\n  const [paused, setPaused] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [link, setLink] = useState(\"\");\n  const [webmData, setWebmData] = useState<Blob>();\n  useEffect(() => {\n    setWebmData(undefined);\n  }, [svgList]);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (paused) {\n        svg.pauseAnimations();\n      } else {\n        svg.unpauseAnimations();\n      }\n    });\n  }, [svgList, paused]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    } else {\n      setShowToolbar(\"never\");\n    }\n  }, []);\n\n  const loadFile = async () => {\n    const data = await loadFromJSON();\n    loadDataList([data]);\n  };\n\n  const loadLibrary = async () => {\n    const blob = await fileOpen({\n      description: \"Excalidraw library files\",\n      extensions: [\".json\", \".excalidrawlib\"],\n      mimeTypes: [\"application/json\"],\n    });\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      window.alert(\"Unable to load library\");\n      return;\n    }\n    const dataList = libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem, null))\n    );\n    loadDataList(dataList.map((elements) => ({ elements })));\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    if (match[1]) {\n      window.location.hash = match[0];\n    } else {\n      window.location.hash = `library=${match[0]}`;\n    }\n    window.location.reload();\n  };\n\n  const togglePausedAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    setPaused((p) => !p);\n  }, [svgList]);\n\n  const timer = useRef<NodeJS.Timeout>();\n  const stepForwardAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    const beginTimeList = getCombinedBeginTimeList(svgList);\n    const currentTime = svgList[0].svg.getCurrentTime() * 1000;\n    let nextTime = beginTimeList.find((t) => t >= currentTime + 100);\n    if (!nextTime) {\n      nextTime = currentTime + 500;\n    }\n    clearTimeout(timer.current as NodeJS.Timeout);\n    svgList.forEach(({ svg }) => {\n      svg.unpauseAnimations();\n    });\n    timer.current = setTimeout(() => {\n      svgList.forEach(({ svg }) => {\n        svg.pauseAnimations();\n        svg.setCurrentTime((nextTime as number) / 1000);\n      });\n      setPaused(true);\n    }, nextTime - currentTime);\n  }, [svgList]);\n\n  const resetAnimations = useCallback(() => {\n    svgList.forEach(({ svg }) => {\n      svg.setCurrentTime(0);\n    });\n  }, [svgList]);\n\n  useEffect(() => {\n    const onKeydown = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === \"p\") {\n        togglePausedAnimations();\n      } else if (e.key.toLowerCase() === \"s\") {\n        stepForwardAnimations();\n      } else if (e.key.toLowerCase() === \"r\") {\n        resetAnimations();\n      } else if (e.key.toLowerCase() === \"q\") {\n        // toggle toolbar\n        setShowToolbar((s) => (typeof s === \"boolean\" ? !s : s));\n      } else {\n        // show toolbar otherwise\n        setShowToolbar((s) => (typeof s === \"boolean\" ? true : s));\n      }\n    };\n    document.addEventListener(\"keydown\", onKeydown);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeydown);\n    };\n  }, [togglePausedAnimations, stepForwardAnimations, resetAnimations]);\n\n  const hideToolbar = () => {\n    setShowToolbar((s) => (typeof s === \"boolean\" ? false : s));\n  };\n\n  const exportToSvg = () => {\n    if (!svgList.length) {\n      return;\n    }\n    svgList.forEach(({ svg }) => {\n      exportToSvgFile(svg);\n    });\n  };\n\n  const exportToWebm = async () => {\n    if (!svgList.length) {\n      return;\n    }\n    if (webmData) {\n      await exportToWebmFile(webmData);\n      return;\n    }\n    setProcessing(true);\n    setShowToolbar(false);\n    try {\n      const data = await prepareWebmData(svgList);\n      setWebmData(data);\n    } catch (e) {\n      console.log(e);\n    }\n    setShowToolbar(true);\n    setProcessing(false);\n  };\n\n  if (showToolbar !== true) {\n    return null;\n  }\n\n  return (\n    <div className=\"Toolbar\">\n      <div className=\"Toolbar-loader\">\n        <button type=\"button\" onClick={loadFile}>\n          Load File\n        </button>\n        <span>OR</span>\n        <button type=\"button\" onClick={loadLibrary}>\n          Load Library\n        </button>\n        <span>OR</span>\n        <form onSubmit={loadLink}>\n          <input\n            placeholder=\"Enter link...\"\n            value={link}\n            onChange={(e) => setLink(e.target.value)}\n          />\n          <button type=\"submit\" disabled={!linkRegex.test(link)}>\n            Animate!\n          </button>\n        </form>\n      </div>\n      {!!svgList.length && (\n        <div className=\"Toolbar-controller\">\n          <button type=\"button\" onClick={togglePausedAnimations}>\n            {paused ? \"Play (P)\" : \"Pause (P)\"}\n          </button>\n          <button type=\"button\" onClick={stepForwardAnimations}>\n            Step (S)\n          </button>\n          <button type=\"button\" onClick={resetAnimations}>\n            Reset (R)\n          </button>\n          <button type=\"button\" onClick={hideToolbar}>\n            Hide Toolbar (Q)\n          </button>\n          <button type=\"button\" onClick={exportToSvg}>\n            Export to SVG\n          </button>\n          <button type=\"button\" onClick={exportToWebm} disabled={processing}>\n            {processing\n              ? \"Processing...\"\n              : webmData\n              ? \"Export to WebM\"\n              : \"Prepare WebM\"}\n          </button>\n        </div>\n      )}\n      <GitHubCorner\n        link=\"https://github.com/dai-shi/excalidraw-animate\"\n        size={40}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n};\n\nconst Viewer: React.FC<Props> = ({ svgList }) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (ref.current) {\n        ref.current.appendChild(svg);\n      }\n    });\n    return () => {\n      svgList.forEach(({ svg }) => {\n        svg.remove();\n      });\n    };\n  }, [svgList]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"autoplay\") === \"no\") {\n      if (ref.current) {\n        const ele = ref.current;\n        const callback = () => {\n          svgList.forEach(({ svg }) => {\n            svg.setCurrentTime(0);\n            svg.unpauseAnimations();\n          });\n        };\n        ele.addEventListener(\"click\", callback);\n        return () => {\n          ele.removeEventListener(\"click\", callback);\n        };\n      }\n    }\n  }, [svgList]);\n\n  const repeat = Math.ceil(Math.sqrt(svgList.length));\n  const grids = `repeat(${repeat}, ${100 / repeat}%)`;\n\n  return (\n    <div\n      className=\"Viewer\"\n      style={{\n        gridTemplateColumns: grids,\n        gridTemplateRows: grids,\n      }}\n      ref={ref}\n    ></div>\n  );\n};\n\nexport default Viewer;\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadSvg } from \"./useLoadSvg\";\n\nconst App: React.FC = () => {\n  const { loading, loadedSvgList, loadDataList } = useLoadSvg();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      <Toolbar svgList={loadedSvgList} loadDataList={loadDataList} />\n      {!!loadedSvgList.length && <Viewer svgList={loadedSvgList} />}\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}