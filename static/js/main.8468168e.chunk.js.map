{"version":3,"sources":["excalidraw/src/css/variables.module.scss","excalidraw/src/constants.ts","excalidraw/src/locales lazy /^/.//.*/.json$/ groupOptions: {} namespace object","GitHubCorner.tsx","excalidraw/src/colors.ts","excalidraw/src/utils.ts","excalidraw/src/keys.ts","excalidraw/src/element/typeChecks.ts","excalidraw/src/math.ts","excalidraw/src/element/bounds.ts","excalidraw/src/i18n.ts","excalidraw/src/appState.ts","excalidraw/src/renderer/renderElement.ts","animate.ts","export.ts","excalidraw/src/scene/Scene.ts","excalidraw/src/random.ts","excalidraw/src/element/mutateElement.ts","excalidraw/src/points.ts","excalidraw/src/element/sizeHelpers.ts","excalidraw/src/scene/scroll.ts","excalidraw/src/element/newElement.ts","excalidraw/src/ga.ts","excalidraw/src/galines.ts","excalidraw/src/gapoints.ts","excalidraw/src/gadirections.ts","excalidraw/src/gatransforms.ts","excalidraw/src/element/collision.ts","excalidraw/src/element/linearElementEditor.ts","excalidraw/src/element/binding.ts","excalidraw/src/types.ts","excalidraw/src/scene/comparisons.ts","excalidraw/src/element/index.ts","excalidraw/src/data/restore.ts","excalidraw/src/errors.ts","excalidraw/src/data/blob.ts","excalidraw/src/data/json.ts","Toolbar.tsx","Viewer.tsx","excalidraw/src/excalidraw-app/data/index.ts","excalidraw/src/renderer/renderScene.ts","excalidraw/src/scene/export.ts","useLoadSvg.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","EVENT","LINE_CONFIRM_THRESHOLD","SHIFT_LOCKING_ANGLE","Math","PI","CURSOR_TYPE","TEXT","CROSSHAIR","GRABBING","POINTER","MOVE","AUTO","ENV","TEST","DEVELOPMENT","CLASSES","SHAPE_ACTIONS_MENU","FONT_FAMILY","1","2","3","WINDOWS_EMOJI_FALLBACK_FONT","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","DEFAULT_VERSION","MIME_TYPES","excalidraw","excalidrawlib","EXPORT_DATA_TYPES","excalidrawClipboard","excalidrawLibrary","EXPORT_SOURCE","window","location","origin","THEME_FILTER","cssVariables","themeFilter","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","t","keys","Object","GitHubCorner","link","size","fill","color","href","className","aria-label","target","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","shades","index","oc","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","white","gray","black","SVG_NS","test","navigator","platform","mockDateTime","getDateTime","date","Date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","min","getMinutes","getFontFamilyString","fontFamily","getFontString","fontSize","measureText","text","font","line","document","createElement","body","whiteSpace","appendChild","innerText","split","x","join","offsetWidth","offsetHeight","span","display","overflow","baseline","offsetTop","removeChild","distance","y","abs","viewportCoordsToSceneCoords","clientX","clientY","zoom","offsetLeft","scrollX","scrollY","invScale","value","translation","sceneCoordsToViewportCoords","sceneX","sceneY","RE_RTL_CHECK","RegExp","isRTL","tupleToCoors","xyTuple","isTextElement","element","type","isFreeDrawElement","isFreeDrawElementType","elementType","isLinearElement","isLinearElementType","isBindingElement","isBindingElementType","isBindableElement","rotate","x1","y1","x2","y2","angle","cos","sin","rotatePoint","point","center","distance2d","xd","yd","hypot","isPathALoop","points","zoomValue","length","first","last","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","i","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","val","p1","q1","p2","q2","o1","o2","o3","o4","getElementAbsoluteCoords","getFreeDrawElementAbsoluteCoords","getLinearElementAbsoluteCoords","getCurvePathOps","shape","sets","set","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","reduce","limits","op","data","p3","p0","equation","idx","pow","minY","minX","maxX","maxY","Infinity","getBoundsFromPoints","coords","getShapeForElement","getElementBounds","bounds","cx","cy","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","w","h","ww","hh","getCommonBounds","elements","forEach","getElementPointsCoords","sharpness","gen","rough","generator","curve","linearPath","generateRoughOptions","defaultLang","label","languages","rtl","concat","sort","left","filter","lang","percentages","TEST_LANG_CODE","process","unshift","currentLang","currentLangData","findPartsForData","parts","part","undefined","path","replacement","startsWith","name","JSON","stringify","fallbackLangData","key","replace","getDefaultAppState","theme","collaborators","Map","currentChartType","currentItemBackgroundColor","currentItemEndArrowhead","currentItemFillStyle","currentItemFontFamily","currentItemFontSize","currentItemLinearStrokeSharpness","currentItemOpacity","currentItemRoughness","currentItemStartArrowhead","currentItemStrokeColor","currentItemStrokeSharpness","currentItemStrokeStyle","currentItemStrokeWidth","currentItemTextAlign","cursorButton","draggingElement","editingElement","editingGroupId","editingLinearElement","elementLocked","errorMessage","exportBackground","exportEmbedScene","exportWithDarkMode","fileHandle","gridSize","isBindingEnabled","isLibraryOpen","isLoading","isResizing","isRotating","lastPointerDownWith","multiElement","openMenu","pasteDialog","shown","previousSelectedElementIds","resizingElement","scrolledOutside","selectedElementIds","selectedGroupIds","selectionElement","shouldAddWatermark","shouldCacheIgnoreZoom","showHelpDialog","showStats","startBoundElement","suggestedBindings","toastMessage","viewBackgroundColor","zenModeEnabled","viewModeEnabled","APP_STATE_STORAGE_CONF","browser","export","_clearAppStateForStorage","appState","exportType","stateForExport","propConfig","cleanAppStateForExport","getDashArrayDashed","strokeWidth","getDashArrayDotted","elementWithCanvasCache","WeakMap","shapeCache","get","continuousPath","options","seed","strokeLineDash","strokeStyle","disableMultiStroke","fillWeight","hachureGap","roughness","stroke","strokeColor","preserveVertices","fillStyle","backgroundColor","curveFitting","generateElementShape","delete","strokeSharpness","rectangle","topX","floor","rightX","rightY","getDiamondPoints","topY","bottomX","bottomY","leftX","leftY","polygon","ellipse","startArrowhead","endArrowhead","getArrowheadShapes","arrowhead","arrowheadPoints","prevOp","nx","ny","arrow","bar","dot","total","px","py","minSize","xs","ys","x3","y3","getArrowheadPoints","circle","x4","y4","dash","shapes","push","generateFreeDrawShape","renderElementToSvg","rsvg","svgRoot","offsetX","offsetY","degree","node","draw","opacity","setAttribute","group","ownerDocument","createElementNS","getFreeDrawSvgPath","lines","lineHeight","verticalOffset","horizontalOffset","textAlign","direction","textAnchor","textContent","pathsCache","svgPathData","Path2D","inputPoints","simulatePressure","pressures","thinning","smoothing","streamline","easing","getFreeDrawShape","hideBeforeAnimation","svg","ele","currentMs","durationMs","freeze","animate","animatePointer","pointer","hash","searchParams","URLSearchParams","img","getPointer","animateMotion","items","match","prev","item","pickOnePathItem","parentNode","animatePath","dTo","getAttribute","mCount","repeat","dLast","dFrom","a","animateFillPath","includes","animatePolygon","cCount","dups","Array","pathForTextIndex","animateFromToPath","patchSvgText","childNodes","len","child","toOpacity","textPath","tagName","findNode","animateText","patchSvgEle","excalidraElement","animateLine","patchSvgLine","numParts","numChildren","j","patchSvgArrow","patchSvgRectangle","patchSvgEllipse","freeDrawElement","childNode","patchSvgFreedraw","extractNumberFromElement","animateSvg","startMs","nodes","groups","groupIds","groupId","createGroups","finished","groupNodes","groupElement2Element","b","aIndex","indexOf","bIndex","sortSvgNodes","has","dur","childEle","childIndex","finishedMs","exportToSvgFile","savedMs","getCurrentTime","setCurrentTime","svgStr","XMLSerializer","serializeToString","fileSave","Blob","fileName","extensions","exportToWebmFile","prepareWebmData","svgList","reject","mediaDevices","getDisplayMedia","video","cursor","displaySurface","stream","recorder","MediaRecorder","ondataavailable","maxFinishedMs","pauseAnimations","start","unpauseAnimations","setTimeout","stop","getVideoTracks","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elementsMap","this","getElement","isNonDeletedElement","result","getNonDeletedElement","nextElements","clear","mapElementToScene","getNonDeletedElements","informMutation","from","callback","cb","add","sceneMapById","scene","sceneMapByElement","random","Random","now","randomInteger","randomId","nanoid","mutateElement","updates","didChange","getSizeFromPoints","prevPoints","nextPoints","didChangePoints","prevPoint","nextPoint","invalidateShapeForElement","version","versionNonce","getScene","newElementWith","isInvisiblySmallElement","calculateScrollCenter","canvas","getVisibleElements","cords","viewportX1","viewportY1","viewportX2","viewportY2","isOutsideViewPort","minDistance","closestElement","getClosestElementBounds","scenePoint","viewportDimensions","centerScrollOn","_newElementBase","boundElementIds","rest","isDeleted","getTextElementPositionOffsets","opts","metrics","verticalAlign","nvector","reverse","isNumber","sub","mul","mulScalar","joinScalar","norm","sqrt","normalized","n","sign","c","GA","through","to","orthogonal","toTuple","distanceToLine","rotation","pivot","apply","motor","bindingBorderTest","threshold","maxBindingGap","hitTestPointAgainstElement","check","isOutsideCheck","elementWidth","elementHeight","smallerDimension","args","distanceToBindableElement","distanceToRectangle","hitTestFreeDrawElement","hitTestLinear","console","warn","distanceToDiamond","distanceToEllipse","isInsideCheck","pointRelativeToElement","pointRel","hwidth","hheight","GAPoint","GALine","side","ellipseParamsForTest","tangent","tx","ty","_","xx","yy","ex","ey","rx","ry","qx","qy","intersection","closestPoint","rotatedPoint","P","A","B","delta","U","C","da","db","pointAbs","side1","side2","relX","relY","some","subshape","hitTestCurveInside","hitTestRoughShape","pointTuple","elementCoords","coordsCenter","GATransform","pointRotated","pointRelToCenterAbs","GADirection","elementPos","pointRelToPos","ax","ay","relativizationToElementCenter","translate","bx","by","determineFocusDistance","relateToCenter","aRel","bRel","m","mabs","nabs","drawable","odd","operation","polygonPoints","pointsOnBezierCurves","lineThreshold","mx","my","pointInBezierEquation","LinearElementEditor","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","normalizePoints","setState","scenePointerX","scenePointerY","maybeSuggestBinding","newPoint","createPointAt","movePoint","event","binding","bindingElement","getHoveredElementForBinding","getPointAtIndexGlobalCoordinates","history","scenePointer","ret","didAddPoint","hitElement","altKey","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","bindOrUnbindLinearElement","targetPoint","lastPoint","indexMaybeFromEnd","absoluteCoords","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","pointerOnGrid","round","getGridPoint","rotatedX","rotatedY","_idx","pointIndex","offset","targetPosition","otherUpdates","splice","deltaX","deltaY","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","rotated","UserIdleState","linearElement","boundToElementIds","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","unbound","unbindLinearElement","hoveredElement","calculateFocusAndGap","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","field","pointerCoords","isAtPositionFn","getElementAtPosition","getElements","edgePointIndex","adjacentPointIndex","edgePoint","adjacentPoint","focus","gap","el","_clearElements","lastCommittedPoint","clearElementsForExport","AllowedExcalidrawElementTypes","selection","diamond","freedraw","restoreElementWithProperties","extra","base","nextWidth","nextHeight","getNormalizedDimensions","restoreElement","fontPx","_fontFamily","parseInt","fontFamilyName","entries","getFontFamilyByName","startBinding","endBinding","isArray","restoreElements","migratedElement","restoreAppState","localAppState","defaultAppState","nextAppState","restoredValue","localValue","restore","parseFileContents","blob","decodePngMetadata","message","contents","reader","FileReader","readAsText","onloadend","readyState","DONE","decodeSvgMetadata","loadFromBlob","parse","isValidExcalidrawData","handle","error","loadLibraryFromBlob","loadFromJSON","fileOpen","description","isValidLibrary","json","linkRegex","getCombinedBeginTimeList","beginTimeList","tmpTimeList","findAnimate","exec","getBeginTimeList","Toolbar","loadDataList","useState","showToolbar","setShowToolbar","paused","setPaused","processing","setProcessing","setLink","webmData","setWebmData","useEffect","loadFile","loadLibrary","mimeTypes","libraryFile","library","alert","dataList","libraryItem","togglePausedAnimations","useCallback","timer","useRef","stepForwardAnimations","currentTime","nextTime","find","clearTimeout","resetAnimations","onKeydown","toLowerCase","s","addEventListener","removeEventListener","exportToWebm","log","onClick","onSubmit","preventDefault","reload","placeholder","onChange","disabled","Viewer","ref","remove","ceil","grids","gridTemplateColumns","gridTemplateRows","getImportedKey","usage","crypto","subtle","importKey","alg","ext","k","key_ops","kty","decryptImported","iv","encrypted","privateKey","decrypt","importFromBackend","fetch","response","ok","arrayBuffer","buffer","byteLength","decrypted","fixedIv","Uint8Array","string","TextDecoder","decode","loadScene","localDataState","commitToHistory","ctx","getContext","textBaseline","fillText","getImageData","supportsEmoji","exportToSvg","exportPadding","scale","metadata","sceneElements","getElementsAndWatermark","getCanvasSize","innerHTML","rect","renderSceneToSvg","_elements","getWatermarkElement","offsets","newTextElement","importLibraryFromUrl","url","request","App","loading","setLoading","loadedSvgList","setLoadedSvgList","inSequence","matchIdKey","matchLibrary","useLoadSvg","Boolean","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.8468168e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"themeFilter\":\"invert(93%) hue-rotate(180deg)\"};","import { FontFamily } from \"./element/types\";\nimport cssVariables from \"./css/variables.module.scss\";\nimport { AppProps } from \"./types\";\n\nexport const APP_NAME = \"Excalidraw\";\n\nexport const DRAGGING_THRESHOLD = 10; // px\nexport const LINE_CONFIRM_THRESHOLD = 8; // px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  POINTER: \"pointer\",\n  MOVE: \"move\",\n  AUTO: \"\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n  HASHCHANGE = \"hashchange\",\n  VISIBILITY_CHANGE = \"visibilitychange\",\n  SCROLL = \"scroll\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  1: \"Virgil\",\n  2: \"Helvetica\",\n  3: \"Cascadia\",\n} as const;\n\nexport const WINDOWS_EMOJI_FALLBACK_FONT = \"Segoe UI Emoji\";\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamily = 1;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\nexport const DEFAULT_VERSION = \"{version}\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n\nexport const MIME_TYPES = {\n  excalidraw: \"application/vnd.excalidraw+json\",\n  excalidrawlib: \"application/vnd.excalidrawlib+json\",\n};\n\nexport const EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nexport const EXPORT_SOURCE = window.location.origin;\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_LIBRARY: \"excalidraw-library\",\n} as const;\n\n// time in milliseconds\nexport const TAP_TWICE_TIMEOUT = 300;\nexport const TOUCH_CTX_MENU_TIMEOUT = 500;\nexport const TITLE_TIMEOUT = 10000;\nexport const TOAST_TIMEOUT = 5000;\nexport const VERSION_TIMEOUT = 30000;\nexport const SCROLL_TIMEOUT = 100;\nexport const ZOOM_STEP = 0.1;\n\n// Report a user inactive after IDLE_THRESHOLD milliseconds\nexport const IDLE_THRESHOLD = 60_000;\n// Report a user active each ACTIVE_THRESHOLD milliseconds\nexport const ACTIVE_THRESHOLD = 3_000;\n\nexport const MODES = {\n  VIEW: \"viewMode\",\n  ZEN: \"zenMode\",\n  GRID: \"gridMode\",\n};\n\nexport const THEME_FILTER = cssVariables.themeFilter;\n\nexport const URL_QUERY_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const URL_HASH_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const DEFAULT_UI_OPTIONS: AppProps[\"UIOptions\"] = {\n  canvasActions: {\n    changeViewBackgroundColor: true,\n    clearCanvas: true,\n    export: true,\n    loadScene: true,\n    saveAsScene: true,\n    saveScene: true,\n    theme: true,\n  },\n};\n\nexport const MQ_MAX_WIDTH_PORTRAIT = 730;\nexport const MQ_MAX_WIDTH_LANDSCAPE = 1000;\nexport const MQ_MAX_HEIGHT_LANDSCAPE = 500;\n","var map = {\n\t\"./ar-SA.json\": [\n\t\t50,\n\t\t0\n\t],\n\t\"./bg-BG.json\": [\n\t\t51,\n\t\t1\n\t],\n\t\"./ca-ES.json\": [\n\t\t52,\n\t\t2\n\t],\n\t\"./de-DE.json\": [\n\t\t53,\n\t\t3\n\t],\n\t\"./el-GR.json\": [\n\t\t54,\n\t\t4\n\t],\n\t\"./en.json\": [\n\t\t30\n\t],\n\t\"./es-ES.json\": [\n\t\t55,\n\t\t5\n\t],\n\t\"./fa-IR.json\": [\n\t\t56,\n\t\t6\n\t],\n\t\"./fi-FI.json\": [\n\t\t57,\n\t\t7\n\t],\n\t\"./fr-FR.json\": [\n\t\t58,\n\t\t8\n\t],\n\t\"./he-IL.json\": [\n\t\t59,\n\t\t9\n\t],\n\t\"./hi-IN.json\": [\n\t\t60,\n\t\t10\n\t],\n\t\"./hu-HU.json\": [\n\t\t61,\n\t\t11\n\t],\n\t\"./id-ID.json\": [\n\t\t62,\n\t\t12\n\t],\n\t\"./it-IT.json\": [\n\t\t63,\n\t\t13\n\t],\n\t\"./ja-JP.json\": [\n\t\t64,\n\t\t14\n\t],\n\t\"./kab-KAB.json\": [\n\t\t65,\n\t\t15\n\t],\n\t\"./ko-KR.json\": [\n\t\t66,\n\t\t16\n\t],\n\t\"./lv-LV.json\": [\n\t\t67,\n\t\t17\n\t],\n\t\"./my-MM.json\": [\n\t\t68,\n\t\t18\n\t],\n\t\"./nb-NO.json\": [\n\t\t69,\n\t\t19\n\t],\n\t\"./nl-NL.json\": [\n\t\t70,\n\t\t20\n\t],\n\t\"./nn-NO.json\": [\n\t\t71,\n\t\t21\n\t],\n\t\"./oc-FR.json\": [\n\t\t72,\n\t\t22\n\t],\n\t\"./pa-IN.json\": [\n\t\t73,\n\t\t23\n\t],\n\t\"./percentages.json\": [\n\t\t31\n\t],\n\t\"./pl-PL.json\": [\n\t\t74,\n\t\t24\n\t],\n\t\"./pt-BR.json\": [\n\t\t75,\n\t\t25\n\t],\n\t\"./pt-PT.json\": [\n\t\t76,\n\t\t26\n\t],\n\t\"./ro-RO.json\": [\n\t\t77,\n\t\t27\n\t],\n\t\"./ru-RU.json\": [\n\t\t78,\n\t\t28\n\t],\n\t\"./sk-SK.json\": [\n\t\t79,\n\t\t29\n\t],\n\t\"./sv-SE.json\": [\n\t\t80,\n\t\t30\n\t],\n\t\"./tr-TR.json\": [\n\t\t81,\n\t\t31\n\t],\n\t\"./uk-UA.json\": [\n\t\t82,\n\t\t32\n\t],\n\t\"./zh-CN.json\": [\n\t\t83,\n\t\t33\n\t],\n\t\"./zh-TW.json\": [\n\t\t84,\n\t\t34\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, 3);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 47;\nmodule.exports = webpackAsyncContext;","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\ntype Props = {\n  link: string;\n  size?: number;\n  fill?: string;\n  color?: string;\n};\n\n// http://tholman.com/github-corners/\nconst GitHubCorner: React.FC<Props> = ({ link, size, fill, color }) => (\n  <a\n    href={link}\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n);\n\nexport default GitHubCorner;\n","import oc from \"open-color\";\n\nconst shades = (index: number) => [\n  oc.red[index],\n  oc.pink[index],\n  oc.grape[index],\n  oc.violet[index],\n  oc.indigo[index],\n  oc.blue[index],\n  oc.cyan[index],\n  oc.teal[index],\n  oc.green[index],\n  oc.lime[index],\n  oc.yellow[index],\n  oc.orange[index],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","import colors from \"./colors\";\nimport {\n  CURSOR_TYPE,\n  DEFAULT_VERSION,\n  FONT_FAMILY,\n  WINDOWS_EMOJI_FALLBACK_FONT,\n} from \"./constants\";\nimport { FontFamily, FontString } from \"./element/types\";\nimport { Zoom } from \"./types\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { isDarwin } from \"./keys\";\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamily;\n}) => {\n  return `${FONT_FAMILY[fontFamily]}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamily;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T | null = null;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => {\n      lastArgs = null;\n      fn(...args);\n    }, timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    if (lastArgs) {\n      const _lastArgs = lastArgs;\n      lastArgs = null;\n      fn(..._lastArgs);\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = null;\n    clearTimeout(handle);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = (canvas: HTMLCanvasElement | null) => {\n  if (canvas) {\n    canvas.style.cursor = \"\";\n  }\n};\n\nexport const setCursor = (canvas: HTMLCanvasElement | null, cursor: string) => {\n  if (canvas) {\n    canvas.style.cursor = cursor;\n  }\n};\n\nexport const setCursorForShape = (\n  canvas: HTMLCanvasElement | null,\n  shape: string,\n) => {\n  if (!canvas) {\n    return;\n  }\n  if (shape === \"selection\") {\n    resetCursor(canvas);\n  } else {\n    canvas.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  shortcut = shortcut\n    .replace(/\\bAlt\\b/i, \"Alt\")\n    .replace(/\\bShift\\b/i, \"Shift\")\n    .replace(/\\b(Enter|Return)\\b/i, \"Enter\")\n    .replace(/\\bDel\\b/i, \"Delete\");\n\n  if (isDarwin) {\n    return shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\");\n  }\n  return shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\");\n};\n\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const invScale = 1 / zoom.value;\n  const x = (clientX - zoom.translation.x - offsetLeft) * invScale - scrollX;\n  const y = (clientY - zoom.translation.y - offsetTop) * invScale - scrollY;\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const x = (sceneX + scrollX + offsetLeft) * zoom.value + zoom.translation.x;\n  const y = (sceneY + scrollY + offsetTop) * zoom.value + zoom.translation.y;\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => RE_RTL_CHECK.test(text);\n\nexport const tupleToCoors = (\n  xyTuple: readonly [number, number],\n): { x: number; y: number } => {\n  const [x, y] = xyTuple;\n  return { x, y };\n};\n\n/** use as a rejectionHandler to mute filesystem Abort errors */\nexport const muteFSAbortError = (error?: Error) => {\n  if (error?.name === \"AbortError\") {\n    return;\n  }\n  throw error;\n};\n\nexport const findIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = 0,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));\n  let index = fromIndex - 1;\n  while (++index < array.length) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const findLastIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = array.length - 1,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));\n  let index = fromIndex + 1;\n  while (--index > -1) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const isTransparent = (color: string) => {\n  const isRGBTransparent = color.length === 5 && color.substr(4, 1) === \"0\";\n  const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === \"00\";\n  return (\n    isRGBTransparent ||\n    isRRGGBBTransparent ||\n    color === colors.elementBackground[0]\n  );\n};\n\nexport type ResolvablePromise<T> = Promise<T> & {\n  resolve: [T] extends [undefined] ? (value?: T) => void : (value: T) => void;\n  reject: (error: Error) => void;\n};\nexport const resolvablePromise = <T>() => {\n  let resolve!: any;\n  let reject!: any;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  (promise as any).resolve = resolve;\n  (promise as any).reject = reject;\n  return promise as ResolvablePromise<T>;\n};\n\n/**\n * @param func handler taking at most single parameter (event).\n */\nexport const withBatchedUpdates = <\n  TFunction extends ((event: any) => void) | (() => void)\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) =>\n  ((event) => {\n    unstable_batchedUpdates(func as TFunction, event);\n  }) as TFunction;\n\n//https://stackoverflow.com/a/9462382/8418\nexport const nFormatter = (num: number, digits: number): string => {\n  const si = [\n    { value: 1, symbol: \"b\" },\n    { value: 1e3, symbol: \"k\" },\n    { value: 1e6, symbol: \"M\" },\n    { value: 1e9, symbol: \"G\" },\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  let index;\n  for (index = si.length - 1; index > 0; index--) {\n    if (num >= si[index].value) {\n      break;\n    }\n  }\n  return (\n    (num / si[index].value).toFixed(digits).replace(rx, \"$1\") + si[index].symbol\n  );\n};\n\nexport const getVersion = () => {\n  return (\n    document.querySelector<HTMLMetaElement>('meta[name=\"version\"]')?.content ||\n    DEFAULT_VERSION\n  );\n};\n\n// Adapted from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/emoji.js\nexport const supportsEmoji = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return false;\n  }\n  const offset = 12;\n  ctx.fillStyle = \"#f00\";\n  ctx.textBaseline = \"top\";\n  ctx.font = \"32px Arial\";\n  // Modernizr used , but it is sort of supported on Windows 7.\n  // Luckily  isn't supported.\n  ctx.fillText(\"\", 0, 0);\n  return ctx.getImageData(offset, offset, 1, 1).data[0] !== 0;\n};\n\nexport const getNearestScrollableContainer = (\n  element: HTMLElement,\n): HTMLElement | Document => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent === document.body) {\n      return document;\n    }\n    const { overflowY } = window.getComputedStyle(parent);\n    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;\n    if (\n      hasScrollableContent &&\n      (overflowY === \"auto\" || overflowY === \"scroll\")\n    ) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  return document;\n};\n\nexport const focusNearestParent = (element: HTMLInputElement) => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent.tabIndex > -1) {\n      parent.focus();\n      return;\n    }\n    parent = parent.parentElement;\n  }\n};\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\nexport const isWindows = /^Win/.test(window.navigator.platform);\n\nexport const CODES = {\n  EQUAL: \"Equal\",\n  MINUS: \"Minus\",\n  NUM_ADD: \"NumpadAdd\",\n  NUM_SUBTRACT: \"NumpadSubtract\",\n  NUM_ZERO: \"Numpad0\",\n  BRACKET_RIGHT: \"BracketRight\",\n  BRACKET_LEFT: \"BracketLeft\",\n  ONE: \"Digit1\",\n  TWO: \"Digit2\",\n  NINE: \"Digit9\",\n  QUOTE: \"Quote\",\n  ZERO: \"Digit0\",\n  C: \"KeyC\",\n  D: \"KeyD\",\n  G: \"KeyG\",\n  F: \"KeyF\",\n  H: \"KeyH\",\n  V: \"KeyV\",\n  X: \"KeyX\",\n  Z: \"KeyZ\",\n  R: \"KeyR\",\n} as const;\n\nexport const KEYS = {\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_UP: \"ArrowUp\",\n  BACKSPACE: \"Backspace\",\n  ALT: \"Alt\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  DELETE: \"Delete\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  QUESTION_MARK: \"?\",\n  SPACE: \" \",\n  TAB: \"Tab\",\n\n  A: \"a\",\n  D: \"d\",\n  E: \"e\",\n  L: \"l\",\n  O: \"o\",\n  P: \"p\",\n  Q: \"q\",\n  R: \"r\",\n  S: \"s\",\n  T: \"t\",\n  V: \"v\",\n  X: \"x\",\n  Y: \"y\",\n  Z: \"z\",\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (key: string) =>\n  key === KEYS.ARROW_LEFT ||\n  key === KEYS.ARROW_RIGHT ||\n  key === KEYS.ARROW_DOWN ||\n  key === KEYS.ARROW_UP;\n\nexport const getResizeCenterPointKey = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey;\n\nexport const getResizeWithSidesSameLengthKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n\nexport const getRotateWithDiscreteAngleKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawGenericElement,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\n\nexport const isGenericElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawGenericElement => {\n  return (\n    element != null &&\n    (element.type === \"selection\" ||\n      element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLinearElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isBindingElementType(element.type);\n};\n\nexport const isBindingElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"text\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"freedraw\" ||\n    element?.type === \"line\"\n  );\n};\n","import { NormalizedZoomValue, Point, Zoom } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // =()cos()sin+\n  // =()sin+()cos+.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nconst isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [number, number, number, number];\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): Bounds => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): [number, number, number, number] => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  let coords: [number, number, number, number];\n\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const shape = getShapeForElement(element) as Drawable[];\n\n    // first element is always the curve\n    const ops = getCurvePathOps(shape[0]);\n\n    const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  return coords;\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  const length = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the whole length of the\n  // arrowhead instead of last segment of the arrowhead.\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\n// We could cache this stuff\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  let bounds: [number, number, number, number];\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isFreeDrawElement(element)) {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n      element.points.map(([x, y]) =>\n        rotate(x, y, cx - element.x, cy - element.y, element.angle),\n      ),\n    );\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else if (isLinearElement(element)) {\n    bounds = getLinearElementRotatedBounds(element, cx, cy);\n  } else if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  } else if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  let bounds: [number, number, number, number];\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve =\n      element.strokeSharpness === \"sharp\"\n        ? gen.linearPath(\n            points as [number, number][],\n            generateRoughOptions(element),\n          )\n        : gen.curve(\n            points as [number, number][],\n            generateRoughOptions(element),\n          );\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    sharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import fallbackLangData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\nimport { ENV } from \"./constants\";\n\nconst COMPLETION_THRESHOLD = 85;\n\nexport interface Language {\n  code: string;\n  label: string;\n  rtl?: boolean;\n}\n\nexport const defaultLang = { code: \"en\", label: \"English\" };\n\nconst allLanguages: Language[] = [\n  { code: \"ar-SA\", label: \"\", rtl: true },\n  { code: \"bg-BG\", label: \"\" },\n  { code: \"ca-ES\", label: \"Catal\" },\n  { code: \"de-DE\", label: \"Deutsch\" },\n  { code: \"el-GR\", label: \"\" },\n  { code: \"es-ES\", label: \"Espaol\" },\n  { code: \"fa-IR\", label: \"\", rtl: true },\n  { code: \"fi-FI\", label: \"Suomi\" },\n  { code: \"fr-FR\", label: \"Franais\" },\n  { code: \"he-IL\", label: \"\", rtl: true },\n  { code: \"hi-IN\", label: \"\" },\n  { code: \"hu-HU\", label: \"Magyar\" },\n  { code: \"id-ID\", label: \"Bahasa Indonesia\" },\n  { code: \"it-IT\", label: \"Italiano\" },\n  { code: \"ja-JP\", label: \"\" },\n  { code: \"kab-KAB\", label: \"Taqbaylit\" },\n  { code: \"ko-KR\", label: \"\" },\n  { code: \"my-MM\", label: \"Burmese\" },\n  { code: \"nb-NO\", label: \"Norsk bokml\" },\n  { code: \"nl-NL\", label: \"Nederlands\" },\n  { code: \"nn-NO\", label: \"Norsk nynorsk\" },\n  { code: \"oc-FR\", label: \"Occitan\" },\n  { code: \"pa-IN\", label: \"\" },\n  { code: \"pl-PL\", label: \"Polski\" },\n  { code: \"pt-BR\", label: \"Portugus Brasileiro\" },\n  { code: \"pt-PT\", label: \"Portugus\" },\n  { code: \"ro-RO\", label: \"Romn\" },\n  { code: \"ru-RU\", label: \"\" },\n  { code: \"sk-SK\", label: \"Slovenina\" },\n  { code: \"sv-SE\", label: \"Svenska\" },\n  { code: \"tr-TR\", label: \"Trke\" },\n  { code: \"uk-UA\", label: \"\" },\n  { code: \"zh-CN\", label: \"\" },\n  { code: \"zh-TW\", label: \"\" },\n  { code: \"lv-LV\", label: \"Latvieu\" },\n].concat([defaultLang]);\n\nexport const languages: Language[] = allLanguages\n  .sort((left, right) => (left.label > right.label ? 1 : -1))\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.code] >=\n      COMPLETION_THRESHOLD,\n  );\n\nconst TEST_LANG_CODE = \"__test__\";\nif (process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  languages.unshift(\n    { code: TEST_LANG_CODE, label: \"test language\" },\n    {\n      code: `${TEST_LANG_CODE}.rtl`,\n      label: \"\\u{202a}test language (rtl)\\u{202c}\",\n      rtl: true,\n    },\n  );\n}\n\nlet currentLang: Language = defaultLang;\nlet currentLangData = {};\n\nexport const setLanguage = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n  document.documentElement.lang = currentLang.code;\n\n  if (lang.code.startsWith(TEST_LANG_CODE)) {\n    currentLangData = {};\n  } else {\n    currentLangData = await import(\n      /* webpackChunkName: \"i18n-[request]\" */ `./locales/${currentLang.code}.json`\n    );\n  }\n};\n\nexport const getLanguage = () => currentLang;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (let index = 0; index < parts.length; ++index) {\n    const part = parts[index];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  if (currentLang.code.startsWith(TEST_LANG_CODE)) {\n    const name = replacement\n      ? `${path}(${JSON.stringify(replacement).slice(1, -1)})`\n      : path;\n    return `\\u{202a}[[${name}]]\\u{202c}`;\n  }\n\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLangData, parts) ||\n    findPartsForData(fallbackLangData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (const key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n","import oc from \"open-color\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n} from \"./constants\";\nimport { t } from \"./i18n\";\nimport { AppState, NormalizedZoomValue } from \"./types\";\nimport { getDateTime } from \"./utils\";\n\nexport const getDefaultAppState = (): Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n> => {\n  return {\n    theme: \"light\",\n    collaborators: new Map(),\n    currentChartType: \"bar\",\n    currentItemBackgroundColor: \"transparent\",\n    currentItemEndArrowhead: \"arrow\",\n    currentItemFillStyle: \"hachure\",\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemLinearStrokeSharpness: \"round\",\n    currentItemOpacity: 100,\n    currentItemRoughness: 1,\n    currentItemStartArrowhead: null,\n    currentItemStrokeColor: oc.black,\n    currentItemStrokeSharpness: \"sharp\",\n    currentItemStrokeStyle: \"solid\",\n    currentItemStrokeWidth: 1,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    cursorButton: \"up\",\n    draggingElement: null,\n    editingElement: null,\n    editingGroupId: null,\n    editingLinearElement: null,\n    elementLocked: false,\n    elementType: \"selection\",\n    errorMessage: null,\n    exportBackground: true,\n    exportEmbedScene: false,\n    exportWithDarkMode: false,\n    fileHandle: null,\n    gridSize: null,\n    isBindingEnabled: true,\n    isLibraryOpen: false,\n    isLoading: false,\n    isResizing: false,\n    isRotating: false,\n    lastPointerDownWith: \"mouse\",\n    multiElement: null,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    openMenu: null,\n    pasteDialog: { shown: false, data: null },\n    previousSelectedElementIds: {},\n    resizingElement: null,\n    scrolledOutside: false,\n    scrollX: 0,\n    scrollY: 0,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    selectionElement: null,\n    shouldAddWatermark: false,\n    shouldCacheIgnoreZoom: false,\n    showHelpDialog: false,\n    showStats: false,\n    startBoundElement: null,\n    suggestedBindings: [],\n    toastMessage: null,\n    viewBackgroundColor: oc.white,\n    zenModeEnabled: false,\n    zoom: { value: 1 as NormalizedZoomValue, translation: { x: 0, y: 0 } },\n    viewModeEnabled: false,\n  };\n};\n\n/**\n * Config containing all AppState keys. Used to determine whether given state\n *  prop should be stripped when exporting to given storage type.\n */\nconst APP_STATE_STORAGE_CONF = (<\n  Values extends {\n    /** whether to keep when storing to browser storage (localStorage/IDB) */\n    browser: boolean;\n    /** whether to keep when exporting to file/database */\n    export: boolean;\n  },\n  T extends Record<keyof AppState, Values>\n>(\n  config: { [K in keyof T]: K extends keyof AppState ? T[K] : never },\n) => config)({\n  theme: { browser: true, export: false },\n  collaborators: { browser: false, export: false },\n  currentChartType: { browser: true, export: false },\n  currentItemBackgroundColor: { browser: true, export: false },\n  currentItemEndArrowhead: { browser: true, export: false },\n  currentItemFillStyle: { browser: true, export: false },\n  currentItemFontFamily: { browser: true, export: false },\n  currentItemFontSize: { browser: true, export: false },\n  currentItemLinearStrokeSharpness: { browser: true, export: false },\n  currentItemOpacity: { browser: true, export: false },\n  currentItemRoughness: { browser: true, export: false },\n  currentItemStartArrowhead: { browser: true, export: false },\n  currentItemStrokeColor: { browser: true, export: false },\n  currentItemStrokeSharpness: { browser: true, export: false },\n  currentItemStrokeStyle: { browser: true, export: false },\n  currentItemStrokeWidth: { browser: true, export: false },\n  currentItemTextAlign: { browser: true, export: false },\n  cursorButton: { browser: true, export: false },\n  draggingElement: { browser: false, export: false },\n  editingElement: { browser: false, export: false },\n  editingGroupId: { browser: true, export: false },\n  editingLinearElement: { browser: false, export: false },\n  elementLocked: { browser: true, export: false },\n  elementType: { browser: true, export: false },\n  errorMessage: { browser: false, export: false },\n  exportBackground: { browser: true, export: false },\n  exportEmbedScene: { browser: true, export: false },\n  exportWithDarkMode: { browser: true, export: false },\n  fileHandle: { browser: false, export: false },\n  gridSize: { browser: true, export: true },\n  height: { browser: false, export: false },\n  isBindingEnabled: { browser: false, export: false },\n  isLibraryOpen: { browser: false, export: false },\n  isLoading: { browser: false, export: false },\n  isResizing: { browser: false, export: false },\n  isRotating: { browser: false, export: false },\n  lastPointerDownWith: { browser: true, export: false },\n  multiElement: { browser: false, export: false },\n  name: { browser: true, export: false },\n  offsetLeft: { browser: false, export: false },\n  offsetTop: { browser: false, export: false },\n  openMenu: { browser: true, export: false },\n  pasteDialog: { browser: false, export: false },\n  previousSelectedElementIds: { browser: true, export: false },\n  resizingElement: { browser: false, export: false },\n  scrolledOutside: { browser: true, export: false },\n  scrollX: { browser: true, export: false },\n  scrollY: { browser: true, export: false },\n  selectedElementIds: { browser: true, export: false },\n  selectedGroupIds: { browser: true, export: false },\n  selectionElement: { browser: false, export: false },\n  shouldAddWatermark: { browser: true, export: false },\n  shouldCacheIgnoreZoom: { browser: true, export: false },\n  showHelpDialog: { browser: false, export: false },\n  showStats: { browser: true, export: false },\n  startBoundElement: { browser: false, export: false },\n  suggestedBindings: { browser: false, export: false },\n  toastMessage: { browser: false, export: false },\n  viewBackgroundColor: { browser: true, export: true },\n  width: { browser: false, export: false },\n  zenModeEnabled: { browser: true, export: false },\n  zoom: { browser: true, export: false },\n  viewModeEnabled: { browser: false, export: false },\n});\n\nconst _clearAppStateForStorage = <ExportType extends \"export\" | \"browser\">(\n  appState: Partial<AppState>,\n  exportType: ExportType,\n) => {\n  type ExportableKeys = {\n    [K in keyof typeof APP_STATE_STORAGE_CONF]: typeof APP_STATE_STORAGE_CONF[K][ExportType] extends true\n      ? K\n      : never;\n  }[keyof typeof APP_STATE_STORAGE_CONF];\n  const stateForExport = {} as { [K in ExportableKeys]?: typeof appState[K] };\n  for (const key of Object.keys(appState) as (keyof typeof appState)[]) {\n    const propConfig = APP_STATE_STORAGE_CONF[key];\n    if (propConfig?.[exportType]) {\n      // @ts-ignore see https://github.com/microsoft/TypeScript/issues/31445\n      stateForExport[key] = appState[key];\n    }\n  }\n  return stateForExport;\n};\n\nexport const clearAppStateForLocalStorage = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"browser\");\n};\n\nexport const cleanAppStateForExport = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"export\");\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n} from \"../element/types\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n} from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\nimport getFreeDrawShape from \"perfect-freehand\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nconst getCanvasPadding = (element: ExcalidrawElement) =>\n  element.type === \"freedraw\" ? element.strokeWidth * 12 : 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: Zoom[\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n  }\n\n  context.translate(padding * zoom.value, padding * zoom.value);\n\n  context.scale(\n    window.devicePixelRatio * zoom.value,\n    window.devicePixelRatio * zoom.value,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  drawElementOnCanvas(element, rc, context);\n\n  context.translate(-(padding * zoom.value), -(padding * zoom.value));\n  context.scale(\n    1 / (window.devicePixelRatio * zoom.value),\n    1 / (window.devicePixelRatio * zoom.value),\n  );\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n  };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    preserveVertices: continuousPath,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"freedraw\":\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\n/**\n * Generates the element's shape and puts it into the cache.\n * @param element\n * @param generator\n */\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element, true),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (element.strokeSharpness === \"sharp\") {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          const getArrowheadShapes = (\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) => {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                  stroke: \"none\",\n                }),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              const dash = getDashArrayDotted(element.strokeWidth - 1);\n              options.strokeLineDash = [dash[0], dash[1] - 1];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          };\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n\n        break;\n      }\n      case \"freedraw\": {\n        generateFreeDrawShape(element);\n        shape = [];\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom: Zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom.value &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Free draw elements will otherwise \"shuffle\" as the min x and y change\n  if (isFreeDrawElement(element)) {\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n  }\n\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"freedraw\": {\n      generateElementShape(element, generator);\n\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\"stroke-linecap\", \"round\");\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      group.setAttribute(\"stroke-linecap\", \"round\");\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          element.type === \"line\" &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    case \"freedraw\": {\n      generateFreeDrawShape(element);\n      const opacity = element.opacity / 100;\n      const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      const path = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"path\");\n      node.setAttribute(\"stroke\", \"none\");\n      node.setAttribute(\"fill\", element.strokeColor);\n      path.setAttribute(\"d\", getFreeDrawSvgPath(element));\n      node.appendChild(path);\n      svgRoot.appendChild(node);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 6,\n    thinning: 0.5,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t: number) => t * (2 - t),\n    last: true,\n  };\n\n  const points = getFreeDrawShape(inputPoints as number[][], options);\n  const d: (string | number)[] = [];\n\n  let [p0, p1] = points;\n\n  d.push(\"M\", p0[0], p0[1], \"Q\");\n\n  for (let i = 0; i < points.length; i++) {\n    d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n    p0 = p1;\n    p1 = points[i];\n  }\n\n  p1 = points[0];\n  d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n\n  d.push(\"Z\");\n\n  return d.join(\" \");\n}\n","import { SVG_NS } from \"./excalidraw/src/utils\";\nimport {\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"./excalidraw/src/element/types\";\nimport { getFreeDrawSvgPath } from \"./excalidraw/src/renderer/renderElement\";\n\nconst findNode = (ele: SVGElement, name: string) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  for (let i = 0; i < childNodes.length; ++i) {\n    if (childNodes[i].tagName === name) {\n      return childNodes[i];\n    }\n  }\n  return null;\n};\n\nconst hideBeforeAnimation = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number,\n  freeze?: boolean\n) => {\n  ele.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"1\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  if (freeze) {\n    animate.setAttribute(\"fill\", \"freeze\");\n  }\n  ele.appendChild(animate);\n};\n\nconst getPointer = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const img = searchParams.get(\"pointerImg\");\n  const width = searchParams.get(\"pointerWidth\");\n  const height = searchParams.get(\"pointerHeight\");\n  if (!img) {\n    return null;\n  }\n  return {\n    img,\n    width,\n    height,\n  };\n};\n\nconst pickOnePathItem = (path: string) => {\n  const items = path.match(/(M[^C]*C[^M]*)/g);\n  if (!items) {\n    return path;\n  }\n  if (items.length <= 2) {\n    return items[items.length - 1];\n  }\n  const [longestIndex] = items.reduce(\n    (prev, item, index) => {\n      const [, x1, y1, x2, y2] =\n        item.match(/M([\\d.-]+) ([\\d.-]+) C([\\d.-]+) ([\\d.-]+)/) || [];\n      const d = Math.hypot(Number(x2) - Number(x1), Number(y2) - Number(y1));\n      if (d > prev[1]) {\n        return [index, d];\n      }\n      return prev;\n    },\n    [0, 0]\n  );\n  return items[longestIndex];\n};\n\nconst animatePointer = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  path: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const pointer = getPointer();\n  if (!pointer) return;\n  const img = svg.ownerDocument.createElementNS(SVG_NS, \"image\");\n  img.setAttribute(\"href\", pointer.img);\n  if (pointer.width) {\n    img.setAttribute(\"width\", pointer.width);\n  }\n  if (pointer.height) {\n    img.setAttribute(\"height\", pointer.height);\n  }\n  hideBeforeAnimation(svg, img, currentMs, durationMs);\n  const animateMotion = svg.ownerDocument.createElementNS(\n    SVG_NS,\n    \"animateMotion\"\n  );\n  animateMotion.setAttribute(\"path\", pickOnePathItem(path));\n  animateMotion.setAttribute(\"begin\", `${currentMs}ms`);\n  animateMotion.setAttribute(\"dur\", `${durationMs}ms`);\n  img.appendChild(animateMotion);\n  ele.parentNode?.appendChild(img);\n};\n\nconst animatePath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  const repeat = cCount / mCount;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"M(\\\\S+) (\\\\S+)\",\n          \"((?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){\",\n          `${i}`, // skip count\n          \"})\",\n          \"(?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){1,}\",\n        ].join(\"\"),\n        \"g\"\n      ),\n      (...a) => {\n        const [x, y] = a[3]\n          ? a[3].match(/.* (\\S+) (\\S+)$/).slice(1, 3)\n          : [a[1], a[2]];\n        return (\n          `M${a[1]} ${a[2]}${a[3]}` +\n          ` C${x} ${y}, ${x} ${y}, ${x} ${y}`.repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n  animatePointer(svg, ele, dTo, currentMs, durationMs);\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nconst animateFillPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  if (dTo.includes(\"C\")) {\n    animatePath(svg, ele, currentMs, durationMs);\n    return;\n  }\n  const dFrom = dTo.replace(\n    new RegExp([\"M(\\\\S+) (\\\\S+)\", \"((?: L\\\\S+ \\\\S+){1,})\"].join(\"\")),\n    (...a) => {\n      return `M${a[1]} ${a[2]}` + a[3].replace(/L\\S+ \\S+/g, `L${a[1]} ${a[2]}`);\n    }\n  );\n  ele.setAttribute(\"d\", dFrom);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  ele.appendChild(animate);\n};\n\nconst animatePolygon = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  let dTo = ele.getAttribute(\"d\") || \"\";\n  let mCount = dTo.match(/M/g)?.length || 0;\n  let cCount = dTo.match(/C/g)?.length || 0;\n  if (mCount === cCount + 1) {\n    // workaround for round rect\n    dTo = dTo.replace(/^M\\S+ \\S+ M/, \"M\");\n    mCount = dTo.match(/M/g)?.length || 0;\n    cCount = dTo.match(/C/g)?.length || 0;\n  }\n  if (mCount !== cCount) throw new Error(\"unexpected m/c counts\");\n  const dups = Math.min(2, mCount);\n  const repeat = mCount / dups;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"((?:\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \"){\",\n          `${i}`, // skip count\n          \"})\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \".*\",\n        ].join(\"\")\n      ),\n      (...a) => {\n        return (\n          `${a[1]}` +\n          [...Array(dups).keys()]\n            .map((d) => {\n              const [x, y] = a.slice(2 + dups * 2 + d * 2);\n              return `M${x} ${y} C${x} ${y}, ${x} ${y}, ${x} ${y} `;\n            })\n            .join(\"\")\n            .repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n    animatePointer(\n      svg,\n      ele,\n      dTo.replace(\n        new RegExp(\n          [\n            \"(?:\",\n            \"M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n            \"){\",\n            `${i}`, // skip count\n            \"}\",\n            \"(M\\\\S+ \\\\S+ C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+) ?\".repeat(dups),\n            \".*\",\n          ].join(\"\")\n        ),\n        \"$1\"\n      ),\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n  }\n  hideBeforeAnimation(svg, ele, currentMs, durationMs, true);\n};\n\nlet pathForTextIndex = 0;\n\nconst animateText = (\n  svg: SVGSVGElement,\n  width: number,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const anchor = ele.getAttribute(\"text-anchor\") || \"start\";\n  if (anchor !== \"start\") {\n    // Not sure how to support it, fallback with opacity\n    const toOpacity = ele.getAttribute(\"opacity\") || \"1.0\";\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"opacity\");\n    animate.setAttribute(\"from\", \"0.0\");\n    animate.setAttribute(\"to\", toOpacity);\n    animate.setAttribute(\"begin\", `${currentMs}ms`);\n    animate.setAttribute(\"dur\", `${durationMs}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    ele.setAttribute(\"opacity\", \"0.0\");\n    return;\n  }\n  const x = Number(ele.getAttribute(\"x\") || 0);\n  const y = Number(ele.getAttribute(\"y\") || 0);\n  pathForTextIndex += 1;\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  path.setAttribute(\"id\", \"pathForText\" + pathForTextIndex);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", `m${x} ${y} h0`);\n  animate.setAttribute(\"to\", `m${x} ${y} h${width}`);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  path.appendChild(animate);\n  const textPath = svg.ownerDocument.createElementNS(SVG_NS, \"textPath\");\n  textPath.setAttribute(\"href\", \"#pathForText\" + pathForTextIndex);\n  textPath.textContent = ele.textContent;\n  ele.textContent = \" \"; // HACK for Firebox as `null` does not work\n  findNode(svg, \"defs\")?.appendChild(path);\n  ele.appendChild(textPath);\n  animatePointer(svg, ele, `m${x} ${y} h${width}`, currentMs, durationMs);\n};\n\nconst animateFromToPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  dFrom: string,\n  dTo: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  path.appendChild(animate);\n  ele.appendChild(path);\n};\n\nconst patchSvgLine = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  if (childNodes[0].getAttribute(\"fill-rule\")) {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animateLine(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs\n    );\n  }\n};\n\nconst patchSvgArrow = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  strokeSharpness: string,\n  currentMs: number,\n  durationMs: number\n) => {\n  const animateLine =\n    strokeSharpness !== \"sharp\" ? animatePath : animatePolygon;\n  const numParts = ele.childNodes.length;\n  animateLine(\n    svg,\n    ele.childNodes[0].childNodes[0] as SVGElement,\n    currentMs,\n    (durationMs / (numParts + 2)) * 3\n  );\n  currentMs += (durationMs / (numParts + 2)) * 3;\n  for (let i = 1; i < numParts; i += 1) {\n    const numChildren = ele.childNodes[i].childNodes.length;\n    for (let j = 0; j < numChildren; j += 1) {\n      animatePath(\n        svg,\n        ele.childNodes[i].childNodes[j] as SVGElement,\n        currentMs,\n        durationMs / (numParts + 2) / numChildren\n      );\n      currentMs += durationMs / (numParts + 2) / numChildren;\n    }\n  }\n};\n\nconst patchSvgRectangle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animatePolygon(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePolygon(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgEllipse = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animatePath(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePath(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgText = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  width: number,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  const len = childNodes.length;\n  childNodes.forEach((child) => {\n    animateText(svg, width, child, currentMs, durationMs / len);\n    currentMs += durationMs / len;\n  });\n};\n\nconst patchSvgFreedraw = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  freeDrawElement: NonDeleted<ExcalidrawFreeDrawElement>,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNode = ele.childNodes[0] as SVGPathElement;\n  childNode.setAttribute(\"opacity\", \"0\");\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"opacity\");\n  animate.setAttribute(\"from\", \"0\");\n  animate.setAttribute(\"to\", \"1\");\n  animate.setAttribute(\"calcMode\", \"discrete\");\n  animate.setAttribute(\"begin\", `${currentMs + durationMs - 1}ms`);\n  animate.setAttribute(\"dur\", `${1}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  childNode.appendChild(animate);\n\n  // interporation\n  const repeat = freeDrawElement.points.length;\n  let dTo = childNode.getAttribute(\"d\") as string;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom =\n      i > 0\n        ? getFreeDrawSvgPath({\n            ...freeDrawElement,\n            points: freeDrawElement.points.slice(0, i),\n          })\n        : \"M 0 0\";\n    animateFromToPath(\n      svg,\n      ele,\n      dFrom,\n      dTo,\n      currentMs + i * (durationMs / repeat),\n      durationMs / repeat\n    );\n    dTo = dFrom;\n  }\n};\n\nconst patchSvgEle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  excalidraElement: NonDeletedExcalidrawElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const { type, strokeSharpness, width } = excalidraElement;\n  if (type === \"line\") {\n    patchSvgLine(svg, ele, strokeSharpness, currentMs, durationMs);\n  } else if (type === \"arrow\") {\n    patchSvgArrow(svg, ele, strokeSharpness, currentMs, durationMs);\n  } else if (type === \"rectangle\" || type === \"diamond\") {\n    patchSvgRectangle(svg, ele, currentMs, durationMs);\n  } else if (type === \"ellipse\") {\n    patchSvgEllipse(svg, ele, currentMs, durationMs);\n  } else if (type === \"text\") {\n    patchSvgText(svg, ele, width, currentMs, durationMs);\n  } else if (excalidraElement.type === \"freedraw\") {\n    patchSvgFreedraw(svg, ele, excalidraElement, currentMs, durationMs);\n  }\n};\n\nconst createGroups = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  const groups: { [groupId: string]: (readonly [SVGElement, number])[] } = {};\n  let index = 0;\n  const childNodes = svg.childNodes as NodeListOf<SVGElement>;\n  childNodes.forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { groupIds } = elements[index];\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        groups[groupId] = groups[groupId] || [];\n        groups[groupId].push([ele, index] as const);\n      }\n      index += 1;\n    }\n  });\n  return groups;\n};\n\nconst filterGroupNodes = (nodes: NodeListOf<SVGElement>) =>\n  [...nodes].filter((node) => node.tagName === \"g\");\n\nconst extractNumberFromElement = (\n  element: NonDeletedExcalidrawElement,\n  key: string\n) => {\n  const match = element.id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return (match && Number(match[1])) || 0;\n};\n\nconst sortSvgNodes = (\n  nodes: SVGElement[],\n  elements: readonly NonDeletedExcalidrawElement[]\n) =>\n  [...nodes].sort((a, b) => {\n    const aIndex = nodes.indexOf(a);\n    const bIndex = nodes.indexOf(b);\n    const aOrder = extractNumberFromElement(elements[aIndex], \"animateOrder\");\n    const bOrder = extractNumberFromElement(elements[bIndex], \"animateOrder\");\n    return aOrder - bOrder;\n  });\n\nexport const animateSvg = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[],\n  startMs?: number\n) => {\n  let finishedMs;\n  const groups = createGroups(svg, elements);\n  const finished = new Map();\n  let current = startMs ?? 1000; // 1 sec margin\n  const groupDur = 5000;\n  const individualDur = 500;\n  const groupNodes = filterGroupNodes(svg.childNodes as NodeListOf<SVGElement>);\n  if (groupNodes.length !== elements.length) {\n    throw new Error(\"element length mismatch\");\n  }\n  const groupElement2Element = new Map(\n    groupNodes.map((ele, index) => [ele, elements[index]])\n  );\n  sortSvgNodes(groupNodes, elements).forEach((ele) => {\n    const element = groupElement2Element.get(\n      ele\n    ) as NonDeletedExcalidrawElement;\n    const { groupIds } = element;\n    if (!finished.has(ele)) {\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        const group = groups[groupId];\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") ||\n          groupDur / (group.length + 1);\n        patchSvgEle(svg, ele, element, current, dur);\n        current += dur;\n        finished.set(ele, true);\n        group.forEach(([childEle, childIndex]) => {\n          const dur =\n            extractNumberFromElement(elements[childIndex], \"animateDuration\") ||\n            groupDur / (group.length + 1);\n          if (!finished.has(childEle)) {\n            patchSvgEle(svg, childEle, elements[childIndex], current, dur);\n            current += dur;\n            finished.set(childEle, true);\n          }\n        });\n        delete groups[groupId];\n      } else {\n        const dur =\n          extractNumberFromElement(element, \"animateDuration\") || individualDur;\n        patchSvgEle(svg, ele, element, current, dur);\n        current += dur;\n        finished.set(ele, true);\n      }\n    }\n  });\n  finishedMs = current + 1000; // 1 sec margin\n  return { finishedMs };\n};\n\nexport const getBeginTimeList = (svg: SVGSVGElement) => {\n  const beginTimeList: number[] = [];\n  const tmpTimeList: number[] = [];\n  const findAnimate = (ele: SVGElement) => {\n    if (ele.tagName === \"animate\") {\n      const match = /([0-9.]+)ms/.exec(ele.getAttribute(\"begin\") || \"\");\n      if (match) {\n        tmpTimeList.push(Number(match[1]));\n      }\n    }\n    (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n      findAnimate(ele);\n    });\n  };\n  (svg.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      findAnimate(ele);\n      if (tmpTimeList.length) {\n        beginTimeList.push(Math.min(...tmpTimeList));\n        tmpTimeList.splice(0);\n      }\n    } else if (ele.tagName === \"defs\") {\n      (ele.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n        findAnimate(ele);\n        if (tmpTimeList.length) {\n          beginTimeList.push(Math.min(...tmpTimeList));\n          tmpTimeList.splice(0);\n        }\n      });\n    }\n  });\n  return beginTimeList;\n};\n","import { fileSave } from \"browser-fs-access\";\n\nexport const exportToSvgFile = async (svg: SVGSVGElement) => {\n  const savedMs = svg.getCurrentTime();\n  svg.setCurrentTime(0);\n  const svgStr = new XMLSerializer().serializeToString(svg);\n  svg.setCurrentTime(savedMs);\n  await fileSave(new Blob([svgStr], { type: \"image/svg+xml\" }), {\n    fileName: \"excalidraw-animate.svg\",\n    extensions: [\".svg\"],\n  });\n};\n\nexport const exportToWebmFile = async (data: Blob) => {\n  await fileSave(new Blob([data], { type: \"video/webm\" }), {\n    fileName: \"excalidraw-animate.webm\",\n    extensions: [\".webm\"],\n  });\n};\n\nexport const prepareWebmData = (\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[]\n) =>\n  new Promise<Blob>(async (resolve, reject) => {\n    try {\n      const stream = (await (navigator.mediaDevices as any).getDisplayMedia({\n        video: {\n          cursor: \"never\",\n          displaySurface: \"browser\",\n        },\n      })) as MediaStream;\n      const recorder = new MediaRecorder(stream);\n      recorder.ondataavailable = (e) => {\n        resolve(e.data);\n      };\n      let maxFinishedMs = 0;\n      svgList.forEach(({ svg, finishedMs }) => {\n        maxFinishedMs = Math.max(maxFinishedMs, finishedMs);\n        svg.pauseAnimations();\n        svg.setCurrentTime(0);\n      });\n      recorder.start();\n      svgList.forEach(({ svg }) => {\n        svg.unpauseAnimations();\n      });\n      setTimeout(() => {\n        recorder.stop();\n        stream.getVideoTracks()[0].stop();\n      }, maxFinishedMs);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  // TODO: getAllNonDeletedElements\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  // TODO: Rename methods here, this is confusing\n  getNonDeletedElements(\n    ids: readonly ExcalidrawElement[\"id\"][],\n  ): NonDeleted<ExcalidrawElement>[] {\n    const result: NonDeleted<ExcalidrawElement>[] = [];\n    ids.forEach((id) => {\n      const element = this.getNonDeletedElement(id);\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n","import { Random } from \"roughjs/bin/math\";\nimport { nanoid } from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  Scene.getScene(element)?.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: element.version + 1,\n    versionNonce: randomInteger(),\n  };\n};\n\n/**\n * Mutates element and updates `version` & `versionNonce`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = (element: Mutable<ExcalidrawElement>) => {\n  element.version = element.version + 1;\n  element.versionNonce = randomInteger();\n  return element;\n};\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import { AppState, PointerCoords, Zoom } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport {\n  getCommonBounds,\n  getClosestElementBounds,\n  getVisibleElements,\n} from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nconst isOutsideViewPort = (\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) => {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom,\n}: {\n  scenePoint: PointerCoords;\n  viewportDimensions: { height: number; width: number };\n  zoom: Zoom;\n}) => {\n  return {\n    scrollX:\n      (viewportDimensions.width / 2) * (1 / zoom.value) -\n      scenePoint.x -\n      zoom.translation.x * (1 / zoom.value),\n    scrollY:\n      (viewportDimensions.height / 2) * (1 / zoom.value) -\n      scenePoint.y -\n      zoom.translation.y * (1 / zoom.value),\n  };\n};\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: number; scrollY: number } => {\n  elements = getVisibleElements(elements);\n\n  if (!elements.length) {\n    return {\n      scrollX: 0,\n      scrollY: 0,\n    };\n  }\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: { width: appState.width, height: appState.height },\n    zoom: appState.zoom,\n  });\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  FontFamily,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"boundElementIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    strokeSharpness,\n    boundElementIds = null,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  strokeSharpness,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n  boundElementIds,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamily;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n  const { textAlign, verticalAlign } = element;\n\n  let x: number;\n  let y: number;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  copy.id = process.env.NODE_ENV === \"test\" ? `${copy.id}_copy` : randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","/**\n * This is a 2D Projective Geometric Algebra implementation.\n *\n * For wider context on geometric algebra visit see https://bivector.net.\n *\n * For this specific algebra see cheatsheet https://bivector.net/2DPGA.pdf.\n *\n * Converted from generator written by enki, with a ton of added on top.\n *\n * This library uses 8-vectors to represent points, directions and lines\n * in 2D space.\n *\n * An array `[a, b, c, d, e, f, g, h]` represents a n(8)vector:\n *   a + b*e0 + c*e1 + d*e2 + e*e01 + f*e20 + g*e12 + h*e012\n *\n * See GAPoint, GALine, GADirection and GATransform modules for common\n * operations.\n */\n\nexport type Point = NVector;\nexport type Direction = NVector;\nexport type Line = NVector;\nexport type Transform = NVector;\n\nexport const point = (x: number, y: number): Point => [0, 0, 0, 0, y, x, 1, 0];\n\nexport const origin = (): Point => [0, 0, 0, 0, 0, 0, 1, 0];\n\nexport const direction = (x: number, y: number): Direction => {\n  const norm = Math.hypot(x, y); // same as `inorm(direction(x, y))`\n  return [0, 0, 0, 0, y / norm, x / norm, 0, 0];\n};\n\nexport const offset = (x: number, y: number): Direction => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  0,\n  0,\n];\n\n/// This is the \"implementation\" part of the library\n\ntype NVector = readonly [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n];\n\n// These are labels for what each number in an nvector represents\nconst NVECTOR_BASE = [\"1\", \"e0\", \"e1\", \"e2\", \"e01\", \"e20\", \"e12\", \"e012\"];\n\n// Used to represent points, lines and transformations\nexport const nvector = (value: number = 0, index: number = 0): NVector => {\n  const result = [0, 0, 0, 0, 0, 0, 0, 0];\n  if (index < 0 || index > 7) {\n    throw new Error(`Expected \\`index\\` betwen 0 and 7, got \\`${index}\\``);\n  }\n  if (value !== 0) {\n    result[index] = value;\n  }\n  return (result as unknown) as NVector;\n};\n\nconst STRING_EPSILON = 0.000001;\nexport const toString = (nvector: NVector): string => {\n  const result = nvector\n    .map((value, index) =>\n      Math.abs(value) > STRING_EPSILON\n        ? value.toFixed(7).replace(/(\\.|0+)$/, \"\") +\n          (index > 0 ? NVECTOR_BASE[index] : \"\")\n        : null,\n    )\n    .filter((representation) => representation != null)\n    .join(\" + \");\n  return result === \"\" ? \"0\" : result;\n};\n\n// Reverse the order of the basis blades.\nexport const reverse = (nvector: NVector): NVector => [\n  nvector[0],\n  nvector[1],\n  nvector[2],\n  nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  -nvector[7],\n];\n\n// Poincare duality operator.\nexport const dual = (nvector: NVector): NVector => [\n  nvector[7],\n  nvector[6],\n  nvector[5],\n  nvector[4],\n  nvector[3],\n  nvector[2],\n  nvector[1],\n  nvector[0],\n];\n\n// Clifford Conjugation\nexport const conjugate = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  nvector[7],\n];\n\n// Main involution\nexport const involute = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  nvector[4],\n  nvector[5],\n  nvector[6],\n  -nvector[7],\n];\n\n// Multivector addition\nexport const add = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] + b[0],\n    a[1] + b[1],\n    a[2] + b[2],\n    a[3] + b[3],\n    a[4] + b[4],\n    a[5] + b[5],\n    a[6] + b[6],\n    a[7] + b[7],\n  ];\n};\n\n// Multivector subtraction\nexport const sub = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] - b[0],\n    a[1] - b[1],\n    a[2] - b[2],\n    a[3] - b[3],\n    a[4] - b[4],\n    a[5] - b[5],\n    a[6] - b[6],\n    a[7] - b[7],\n  ];\n};\n\n// The geometric product.\nexport const mul = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [\n      a[0] * b,\n      a[1] * b,\n      a[2] * b,\n      a[3] * b,\n      a[4] * b,\n      a[5] * b,\n      a[6] * b,\n      a[7] * b,\n    ];\n  }\n  return [\n    mulScalar(a, b),\n    b[1] * a[0] +\n      b[0] * a[1] -\n      b[4] * a[2] +\n      b[5] * a[3] +\n      b[2] * a[4] -\n      b[3] * a[5] -\n      b[7] * a[6] -\n      b[6] * a[7],\n    b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n    b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n    b[4] * a[0] +\n      b[2] * a[1] -\n      b[1] * a[2] +\n      b[7] * a[3] +\n      b[0] * a[4] +\n      b[6] * a[5] -\n      b[5] * a[6] +\n      b[3] * a[7],\n    b[5] * a[0] -\n      b[3] * a[1] +\n      b[7] * a[2] +\n      b[1] * a[3] -\n      b[6] * a[4] +\n      b[0] * a[5] +\n      b[4] * a[6] +\n      b[2] * a[7],\n    b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n    b[7] * a[0] +\n      b[6] * a[1] +\n      b[5] * a[2] +\n      b[4] * a[3] +\n      b[3] * a[4] +\n      b[2] * a[5] +\n      b[1] * a[6] +\n      b[0] * a[7],\n  ];\n};\n\nexport const mulScalar = (a: NVector, b: NVector): number =>\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];\n\n// The outer/exterior/wedge product.\nexport const meet = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0],\n  b[1] * a[0] + b[0] * a[1],\n  b[2] * a[0] + b[0] * a[2],\n  b[3] * a[0] + b[0] * a[3],\n  b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],\n  b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],\n  b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n  b[7] * a[0] +\n    b[6] * a[1] +\n    b[5] * a[2] +\n    b[4] * a[3] +\n    b[3] * a[4] +\n    b[2] * a[5] +\n    b[1] * a[6],\n];\n\n// The regressive product.\nexport const join = (a: NVector, b: NVector): NVector => [\n  joinScalar(a, b),\n  a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],\n  a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],\n  a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],\n  a[4] * b[7] + a[7] * b[4],\n  a[5] * b[7] + a[7] * b[5],\n  a[6] * b[7] + a[7] * b[6],\n  a[7] * b[7],\n];\n\nexport const joinScalar = (a: NVector, b: NVector): number =>\n  a[0] * b[7] +\n  a[1] * b[6] +\n  a[2] * b[5] +\n  a[3] * b[4] +\n  a[4] * b[3] +\n  a[5] * b[2] +\n  a[6] * b[1] +\n  a[7] * b[0];\n\n// The inner product.\nexport const dot = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],\n  b[1] * a[0] +\n    b[0] * a[1] -\n    b[4] * a[2] +\n    b[5] * a[3] +\n    b[2] * a[4] -\n    b[3] * a[5] -\n    b[7] * a[6] -\n    b[6] * a[7],\n  b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n  b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n  b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],\n  b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],\n  b[6] * a[0] + b[0] * a[6],\n  b[7] * a[0] + b[0] * a[7],\n];\n\nexport const norm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));\n\nexport const inorm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));\n\nexport const normalized = (a: NVector): NVector => {\n  const n = norm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  const sign = a[6] < 0 ? -1 : 1;\n  return mul(a, sign / n);\n};\n\nexport const inormalized = (a: NVector): NVector => {\n  const n = inorm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  return mul(a, 1 / n);\n};\n\nconst isNumber = (a: any): a is number => typeof a === \"number\";\n\nexport const E0: NVector = nvector(1, 1);\nexport const E1: NVector = nvector(1, 2);\nexport const E2: NVector = nvector(1, 3);\nexport const E01: NVector = nvector(1, 4);\nexport const E20: NVector = nvector(1, 5);\nexport const E12: NVector = nvector(1, 6);\nexport const E012: NVector = nvector(1, 7);\nexport const I = E012;\n","import * as GA from \"./ga\";\nimport { Line, Point } from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n\n// Returns line with direction (x, y) through origin\nexport const vector = (x: number, y: number): Line =>\n  GA.normalized([0, 0, -y, x, 0, 0, 0, 0]);\n\n// For equation ax + by + c = 0.\nexport const equation = (a: number, b: number, c: number): Line =>\n  GA.normalized([0, c, a, b, 0, 0, 0, 0]);\n\nexport const through = (from: Point, to: Point): Line =>\n  GA.normalized(GA.join(to, from));\n\nexport const orthogonal = (line: Line, point: Point): Line =>\n  GA.dot(line, point);\n\n// Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\nexport const orthogonalThrough = (against: Point, intersection: Point): Line =>\n  orthogonal(through(against, intersection), intersection);\n\nexport const parallel = (line: Line, distance: number): Line => {\n  const result = line.slice();\n  result[1] -= distance;\n  return (result as unknown) as Line;\n};\n\nexport const parallelThrough = (line: Line, point: Point): Line =>\n  orthogonal(orthogonal(point, line), point);\n\nexport const distance = (line1: Line, line2: Line): number =>\n  GA.inorm(GA.meet(line1, line2));\n\nexport const angle = (line1: Line, line2: Line): number =>\n  Math.acos(GA.dot(line1, line2)[0]);\n\n// The orientation of the line\nexport const sign = (line: Line): number => Math.sign(line[1]);\n","import * as GA from \"./ga\";\nimport * as GALine from \"./galines\";\nimport { Point, Line, join } from \"./ga\";\n\nexport const from = ([x, y]: readonly [number, number]): Point => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  1,\n  0,\n];\n\nexport const toTuple = (point: Point): [number, number] => [point[5], point[4]];\n\nexport const abs = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  Math.abs(point[4]),\n  Math.abs(point[5]),\n  1,\n  0,\n];\n\nexport const intersect = (line1: Line, line2: Line): Point =>\n  GA.normalized(GA.meet(line1, line2));\n\n// Projects `point` onto the `line`.\n// The returned point is the closest point on the `line` to the `point`.\nexport const project = (point: Point, line: Line): Point =>\n  intersect(GALine.orthogonal(line, point), line);\n\nexport const distance = (point1: Point, point2: Point): number =>\n  GA.norm(join(point1, point2));\n\nexport const distanceToLine = (point: Point, line: Line): number =>\n  GA.joinScalar(point, line);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point } from \"./ga\";\n\n/**\n * A direction is stored as an array `[0, 0, 0, 0, y, x, 0, 0]` representing\n * vector `(x, y)`.\n */\n\nexport const from = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  point[4],\n  point[5],\n  0,\n  0,\n];\n\nexport const fromTo = (from: Point, to: Point): Direction =>\n  GA.inormalized([0, 0, 0, 0, to[4] - from[4], to[5] - from[5], 0, 0]);\n\nexport const orthogonal = (direction: Direction): Direction =>\n  GA.inormalized([0, 0, 0, 0, -direction[5], direction[4], 0, 0]);\n\nexport const orthogonalToLine = (line: Line): Direction => GA.mul(line, GA.I);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point, Transform } from \"./ga\";\nimport * as GADirection from \"./gadirections\";\n\n/**\n * TODO: docs\n */\n\nexport const rotation = (pivot: Point, angle: number): Transform =>\n  GA.add(GA.mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));\n\nexport const translation = (direction: Direction): Transform => [\n  1,\n  0,\n  0,\n  0,\n  -(0.5 * direction[5]),\n  0.5 * direction[4],\n  0,\n  0,\n];\n\nexport const translationOrthogonal = (\n  direction: Direction,\n  distance: number,\n): Transform => {\n  const scale = 0.5 * distance;\n  return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];\n};\n\nexport const translationAlong = (line: Line, distance: number): Transform =>\n  GA.add(GA.mul(GADirection.orthogonalToLine(line), 0.5 * distance), 1);\n\nexport const compose = (motor1: Transform, motor2: Transform): Transform =>\n  GA.mul(motor2, motor1);\n\nexport const apply = (\n  motor: Transform,\n  nvector: Point | Direction | Line,\n): Point | Direction | Line =>\n  GA.normalized(GA.mul(GA.mul(motor, nvector), GA.reverse(motor)));\n","import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport {\n  distance2d,\n  rotatePoint,\n  isPathALoop,\n  isPointInPolygon,\n  rotate,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords, getCurvePathOps, Bounds } from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside;\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) &&\n    isPointHittingElementBoundingBox(element, [x, y], threshold)\n  );\n};\n\nconst isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  const check =\n    element.type === \"text\"\n      ? isStrictlyInside\n      : isElementDraggableFromInside(element)\n      ? isInsideCheck\n      : isNearCheck;\n\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\": {\n      if (\n        !args.check(\n          distanceToRectangle(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return false;\n      }\n\n      return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n    }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawTextElement\n    | ExcalidrawFreeDrawElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestFreeDrawElement = (\n  element: ExcalidrawFreeDrawElement,\n  point: Point,\n  threshold: number,\n): boolean => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x: number;\n  let y: number;\n\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(\n      point,\n      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],\n      -element.angle,\n    );\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n\n  let [A, B] = element.points;\n  let P: readonly [number, number];\n\n  // For freedraw dots\n  if (element.points.length === 2) {\n    return (\n      distance2d(A[0], A[1], x, y) < threshold ||\n      distance2d(B[0], B[1], x, y) < threshold\n    );\n  }\n\n  // For freedraw lines\n  for (let i = 1; i < element.points.length - 1; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n\n    A = B;\n    B = element.points[i + 1];\n  }\n\n  return false;\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(subshape, relX, relY, element.strokeSharpness),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]: Bounds): GA.Point => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  const n = (-m * px - 1) / py;\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport History from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n  public startBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      startOrEnd: \"start\" | \"end\",\n    ) => void,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n    if (\n      isDragging &&\n      (activePointIndex === 0 || activePointIndex === element.points.length - 1)\n    ) {\n      if (isPathALoop(element.points, appState.zoom.value)) {\n        LinearElementEditor.movePoint(\n          element,\n          activePointIndex,\n          activePointIndex === 0\n            ? element.points[element.points.length - 1]\n            : element.points[0],\n        );\n      }\n      const bindingElement = isBindingEnabled(appState)\n        ? getHoveredElementForBinding(\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                activePointIndex!,\n              ),\n            ),\n            Scene.getScene(element)!,\n          )\n        : null;\n      binding = {\n        [activePointIndex === 0\n          ? \"startBindingElement\"\n          : \"endBindingElement\"]: bindingElement,\n      };\n    }\n    return {\n      ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: History,\n    scenePointer: { x: number; y: number },\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(\n            scenePointer,\n            Scene.getScene(element)!,\n          ),\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointer.x - targetPoint[0],\n              y: scenePointer.y - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return { ...editingLinearElement, lastUncommittedPoint: null };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    });\n  }\n\n  static movePointByOffset(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number,\n    offset: { x: number; y: number },\n  ) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [\n      x + offset.x,\n      y + offset.y,\n    ]);\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(\n      element,\n      nextPoints,\n      element.strokeSharpness || \"round\",\n    );\n    const prevCoords = getElementPointsCoords(\n      element,\n      points,\n      element.strokeSharpness || \"round\",\n    );\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLCanvasElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n  Scene.getScene(linearElement)!\n    .getNonDeletedElements(onlyUnbound)\n    .forEach((element) => {\n      mutateElement(element, {\n        boundElementIds: element.boundElementIds?.filter(\n          (id) => id !== linearElement.id,\n        ),\n      });\n    });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(\n    bindableElement,\n  ).forEach(([linearElement, where]) =>\n    bindOrUnbindLinearElement(\n      linearElement,\n      where === \"end\" ? \"keep\" : bindableElement,\n      where === \"start\" ? \"keep\" : bindableElement,\n    ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: Array.from(\n      new Set([...(hoveredElement.boundElementIds ?? []), linearElement.id]),\n    ),\n  });\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getElements(),\n    (element) =>\n      isBindableElement(element) && bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundElementIds = changedElement.boundElementIds ?? [];\n  if (boundElementIds.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n  (Scene.getScene(changedElement)!.getNonDeletedElements(\n    boundElementIds,\n  ) as NonDeleted<ExcalidrawLinearElement>[]).forEach((linearElement) => {\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElementIds are stale\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      linearElement,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      linearElement,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoint(\n    linearElement,\n    edgePointIndex,\n    LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint),\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getElements()\n    .map((element) => {\n      if (!isBindingElement(element)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElementIds } = oldElement;\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach((boundElementId) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (sceneElements.filter(({ id }) =>\n    allBoundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElementIds } = bindableElement;\n      if (boundElementIds != null && boundElementIds.length > 0) {\n        mutateElement(bindableElement, {\n          boundElementIds: boundElementIds.map(\n            (boundElementId) =>\n              oldIdToDuplicatedId.get(boundElementId) ?? boundElementId,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // Non deleted and need an update\n  const boundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElementIds?.forEach((id) => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  (sceneElements.filter(({ id }) =>\n    boundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach(\n    (element: ExcalidrawLinearElement) => {\n      const { startBinding, endBinding } = element;\n      mutateElement(element, {\n        startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n        endBinding: newBindingAfterDeletion(endBinding, deletedElementIds),\n      });\n    },\n  );\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n","import {\n  PointerType,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  TextAlign,\n  ExcalidrawElement,\n  FontFamily,\n  GroupId,\n  ExcalidrawBindableElement,\n  Arrowhead,\n  ChartType,\n} from \"./element/types\";\nimport { SHAPES } from \"./shapes\";\nimport { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport { LinearElementEditor } from \"./element/linearElementEditor\";\nimport { SuggestedBinding } from \"./element/binding\";\nimport { ImportedDataState } from \"./data/types\";\nimport { ExcalidrawImperativeAPI } from \"./components/App\";\nimport type { ResolvablePromise } from \"./utils\";\nimport { Spreadsheet } from \"./charts\";\nimport { Language } from \"./i18n\";\nimport { ClipboardData } from \"./clipboard\";\n\nexport type Point = Readonly<RoughPoint>;\n\nexport type Collaborator = {\n  pointer?: {\n    x: number;\n    y: number;\n  };\n  button?: \"up\" | \"down\";\n  selectedElementIds?: AppState[\"selectedElementIds\"];\n  username?: string | null;\n  userState?: UserIdleState;\n  color?: {\n    background: string;\n    stroke: string;\n  };\n};\n\nexport type AppState = {\n  isLoading: boolean;\n  errorMessage: string | null;\n  draggingElement: NonDeletedExcalidrawElement | null;\n  resizingElement: NonDeletedExcalidrawElement | null;\n  multiElement: NonDeleted<ExcalidrawLinearElement> | null;\n  selectionElement: NonDeletedExcalidrawElement | null;\n  isBindingEnabled: boolean;\n  startBoundElement: NonDeleted<ExcalidrawBindableElement> | null;\n  suggestedBindings: SuggestedBinding[];\n  // element being edited, but not necessarily added to elements array yet\n  // (e.g. text element when typing into the input)\n  editingElement: NonDeletedExcalidrawElement | null;\n  editingLinearElement: LinearElementEditor | null;\n  elementType: typeof SHAPES[number][\"value\"];\n  elementLocked: boolean;\n  exportBackground: boolean;\n  exportEmbedScene: boolean;\n  exportWithDarkMode: boolean;\n  shouldAddWatermark: boolean;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  currentItemFillStyle: ExcalidrawElement[\"fillStyle\"];\n  currentItemStrokeWidth: number;\n  currentItemStrokeStyle: ExcalidrawElement[\"strokeStyle\"];\n  currentItemRoughness: number;\n  currentItemOpacity: number;\n  currentItemFontFamily: FontFamily;\n  currentItemFontSize: number;\n  currentItemTextAlign: TextAlign;\n  currentItemStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  currentItemStartArrowhead: Arrowhead | null;\n  currentItemEndArrowhead: Arrowhead | null;\n  currentItemLinearStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  cursorButton: \"up\" | \"down\";\n  scrolledOutside: boolean;\n  name: string;\n  isResizing: boolean;\n  isRotating: boolean;\n  zoom: Zoom;\n  openMenu: \"canvas\" | \"shape\" | null;\n  lastPointerDownWith: PointerType;\n  selectedElementIds: { [id: string]: boolean };\n  previousSelectedElementIds: { [id: string]: boolean };\n  shouldCacheIgnoreZoom: boolean;\n  showHelpDialog: boolean;\n  toastMessage: string | null;\n  zenModeEnabled: boolean;\n  theme: \"light\" | \"dark\";\n  gridSize: number | null;\n  viewModeEnabled: boolean;\n\n  /** top-most selected groups (i.e. does not include nested groups) */\n  selectedGroupIds: { [groupId: string]: boolean };\n  /** group being edited when you drill down to its constituent element\n    (e.g. when you double-click on a group's element) */\n  editingGroupId: GroupId | null;\n  width: number;\n  height: number;\n  offsetTop: number;\n  offsetLeft: number;\n\n  isLibraryOpen: boolean;\n  fileHandle: import(\"browser-fs-access\").FileSystemHandle | null;\n  collaborators: Map<string, Collaborator>;\n  showStats: boolean;\n  currentChartType: ChartType;\n  pasteDialog:\n    | {\n        shown: false;\n        data: null;\n      }\n    | {\n        shown: true;\n        data: Spreadsheet;\n      };\n};\n\nexport type NormalizedZoomValue = number & { _brand: \"normalizedZoom\" };\n\nexport type Zoom = Readonly<{\n  value: NormalizedZoomValue;\n  translation: Readonly<{\n    x: number;\n    y: number;\n  }>;\n}>;\n\nexport type PointerCoords = Readonly<{\n  x: number;\n  y: number;\n}>;\n\nexport type Gesture = {\n  pointers: Map<number, PointerCoords>;\n  lastCenter: { x: number; y: number } | null;\n  initialDistance: number | null;\n  initialScale: number | null;\n};\n\nexport declare class GestureEvent extends UIEvent {\n  readonly rotation: number;\n  readonly scale: number;\n}\n\nexport type LibraryItem = readonly NonDeleted<ExcalidrawElement>[];\nexport type LibraryItems = readonly LibraryItem[];\n\n// NOTE ready/readyPromise props are optional for host apps' sake (our own\n// implem guarantees existence)\nexport type ExcalidrawAPIRefValue =\n  | ExcalidrawImperativeAPI\n  | {\n      readyPromise?: ResolvablePromise<ExcalidrawImperativeAPI>;\n      ready?: false;\n    };\n\nexport interface ExcalidrawProps {\n  onChange?: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n  ) => void;\n  initialData?: ImportedDataState | null | Promise<ImportedDataState | null>;\n  excalidrawRef?: ForwardRef<ExcalidrawAPIRefValue>;\n  onCollabButtonClick?: () => void;\n  isCollaborating?: boolean;\n  onPointerUpdate?: (payload: {\n    pointer: { x: number; y: number };\n    button: \"down\" | \"up\";\n    pointersMap: Gesture[\"pointers\"];\n  }) => void;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  onPaste?: (\n    data: ClipboardData,\n    event: ClipboardEvent | null,\n  ) => Promise<boolean> | boolean;\n  renderTopRight?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  renderFooter?: (isMobile: boolean) => JSX.Element;\n  langCode?: Language[\"code\"];\n  viewModeEnabled?: boolean;\n  zenModeEnabled?: boolean;\n  gridModeEnabled?: boolean;\n  libraryReturnUrl?: string;\n  theme?: \"dark\" | \"light\";\n  name?: string;\n  renderCustomStats?: (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n  ) => JSX.Element;\n  UIOptions?: UIOptions;\n  detectScroll?: boolean;\n  handleKeyboardGlobally?: boolean;\n  onLibraryChange?: (libraryItems: LibraryItems) => void | Promise<any>;\n}\n\nexport type SceneData = {\n  elements?: ImportedDataState[\"elements\"];\n  appState?: ImportedDataState[\"appState\"];\n  collaborators?: Map<string, Collaborator>;\n  commitToHistory?: boolean;\n};\n\nexport enum UserIdleState {\n  ACTIVE = \"active\",\n  AWAY = \"away\",\n  IDLE = \"idle\",\n}\n\ntype CanvasActions = {\n  changeViewBackgroundColor?: boolean;\n  clearCanvas?: boolean;\n  export?: boolean;\n  loadScene?: boolean;\n  saveAsScene?: boolean;\n  saveScene?: boolean;\n  theme?: boolean;\n};\n\nexport type UIOptions = {\n  canvasActions?: CanvasActions;\n};\n\nexport type AppProps = ExcalidrawProps & {\n  UIOptions: {\n    canvasActions: Required<CanvasActions>;\n  };\n  detectScroll: boolean;\n  handleKeyboardGlobally: boolean;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\";\n\nexport const hasStrokeWidth = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeSharpness = (type: string) =>\n  type === \"rectangle\" || type === \"arrow\" || type === \"line\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n\nexport const getElementContainingPosition = (\n  elements: readonly ExcalidrawElement[],\n  x: number,\n  y: number,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return hitElement;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowheadPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n} from \"./transformHandles\";\nexport {\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n} from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n} from \"./resizeTest\";\nexport {\n  transformElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getVisibleElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (el) => !el.isDeleted && !isInvisiblySmallElement(el),\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n","import {\n  ExcalidrawElement,\n  FontFamily,\n  ExcalidrawSelectionElement,\n} from \"../element/types\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { ImportedDataState } from \"./types\";\nimport { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  FONT_FAMILY,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\ntype RestoredAppState = Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n>;\n\nexport const AllowedExcalidrawElementTypes: Record<\n  ExcalidrawElement[\"type\"],\n  true\n> = {\n  selection: true,\n  text: true,\n  rectangle: true,\n  diamond: true,\n  ellipse: true,\n  line: true,\n  arrow: true,\n  freedraw: true,\n};\n\nexport type RestoredDataState = {\n  elements: ExcalidrawElement[];\n  appState: RestoredAppState;\n};\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamily => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id) as FontFamily;\n    }\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <T extends ExcalidrawElement>(\n  element: Required<T>,\n  extra: Omit<Required<T>, keyof ExcalidrawElement> & {\n    type?: ExcalidrawElement[\"type\"];\n  },\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: extra.type || element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    strokeSharpness:\n      element.strokeSharpness ??\n      (isLinearElementType(element.type) ? \"round\" : \"sharp\"),\n    boundElementIds: element.boundElementIds ?? [],\n  };\n\n  return ({\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown) as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"freedraw\": {\n      return restoreElementWithProperties(element, {\n        points: element.points,\n        lastCommittedPoint: null,\n        simulatePressure: element.simulatePressure,\n        pressures: element.pressures,\n      });\n    }\n    case \"line\":\n    // @ts-ignore LEGACY type\n    // eslint-disable-next-line no-fallthrough\n    case \"draw\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      return restoreElementWithProperties(element, {\n        type:\n          (element.type as ExcalidrawElement[\"type\"] | \"draw\") === \"draw\"\n            ? \"line\"\n            : element.type,\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        points:\n          // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2\n            ? [\n                [0, 0],\n                [element.width, element.height],\n              ]\n            : element.points,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n): ExcalidrawElement[] => {\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = restoreElement(element);\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n};\n\nexport const restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null,\n): RestoredAppState => {\n  appState = appState || {};\n\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  for (const [key, val] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    const restoredValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      restoredValue !== undefined\n        ? restoredValue\n        : localValue !== undefined\n        ? localValue\n        : val;\n  }\n\n  return {\n    ...nextAppState,\n    elementType: AllowedExcalidrawElementTypes[nextAppState.elementType]\n      ? nextAppState.elementType\n      : \"selection\",\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n            translation: defaultAppState.zoom.translation,\n          }\n        : appState.zoom || defaultAppState.zoom,\n  };\n};\n\nexport const restore = (\n  data: ImportedDataState | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n): RestoredDataState => {\n  return {\n    elements: restoreElements(data?.elements),\n    appState: restoreAppState(data?.appState, localAppState || null),\n  };\n};\n","type CANVAS_ERROR_NAMES = \"CANVAS_ERROR\" | \"CANVAS_POSSIBLY_TOO_BIG\";\nexport class CanvasError extends Error {\n  constructor(\n    message: string = \"Couldn't export canvas.\",\n    name: CANVAS_ERROR_NAMES = \"CANVAS_ERROR\",\n  ) {\n    super();\n    this.name = name;\n    this.message = message;\n  }\n}\n","import { cleanAppStateForExport } from \"../appState\";\nimport { EXPORT_DATA_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isValidExcalidrawData } from \"./json\";\nimport { restore } from \"./restore\";\nimport { ImportedLibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === \"image/png\") {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n      } else {\n        throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === \"image/svg+xml\") {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n        } else {\n          throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return \"application/json\";\n  } else if (/\\.png$/.test(name)) {\n    return \"image/png\";\n  } else if (/\\.jpe?g$/.test(name)) {\n    return \"image/jpeg\";\n  } else if (/\\.svg$/.test(name)) {\n    return \"image/svg+xml\";\n  }\n  return \"\";\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (!isValidExcalidrawData(data)) {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore(\n      {\n        elements: clearElementsForExport(data.elements || []),\n        appState: {\n          theme: localAppState?.theme,\n          fileHandle: (!blob.type.startsWith(\"image/\") && blob.handle) || null,\n          ...cleanAppStateForExport(data.appState || {}),\n          ...(localAppState\n            ? calculateScrollCenter(data.elements || [], localAppState, null)\n            : {}),\n        },\n      },\n      localAppState,\n    );\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: ImportedLibraryData = JSON.parse(contents);\n  if (data.type !== EXPORT_DATA_TYPES.excalidrawLibrary) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n","import { fileOpen, fileSave } from \"browser-fs-access\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport { EXPORT_DATA_TYPES, EXPORT_SOURCE, MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { loadFromBlob } from \"./blob\";\n\nimport {\n  ExportedDataState,\n  ImportedDataState,\n  ExportedLibraryData,\n} from \"./types\";\nimport Library from \"./library\";\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): string => {\n  const data: ExportedDataState = {\n    type: EXPORT_DATA_TYPES.excalidraw,\n    version: 2,\n    source: EXPORT_SOURCE,\n    elements: clearElementsForExport(elements),\n    appState: cleanAppStateForExport(appState),\n  };\n\n  return JSON.stringify(data, null, 2);\n};\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const serialized = serializeAsJSON(elements, appState);\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidraw,\n  });\n\n  const fileHandle = await fileSave(\n    blob,\n    {\n      fileName: `${appState.name}.excalidraw`,\n      description: \"Excalidraw file\",\n      extensions: [\".excalidraw\"],\n    },\n    appState.fileHandle,\n  );\n  return { fileHandle };\n};\n\nexport const loadFromJSON = async (localAppState: AppState) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    /*\n    extensions: [\".json\", \".excalidraw\", \".png\", \".svg\"],\n    mimeTypes: [\n      MIME_TYPES.excalidraw,\n      \"application/json\",\n      \"image/png\",\n      \"image/svg+xml\",\n    ],\n    */\n  });\n  return loadFromBlob(blob, localAppState);\n};\n\nexport const isValidExcalidrawData = (data?: {\n  type?: any;\n  elements?: any;\n  appState?: any;\n}): data is ImportedDataState => {\n  return (\n    data?.type === EXPORT_DATA_TYPES.excalidraw &&\n    (!data.elements ||\n      (Array.isArray(data.elements) &&\n        (!data.appState || typeof data.appState === \"object\")))\n  );\n};\n\nexport const isValidLibrary = (json: any) => {\n  return (\n    typeof json === \"object\" &&\n    json &&\n    json.type === EXPORT_DATA_TYPES.excalidrawLibrary &&\n    json.version === 1\n  );\n};\n\nexport const saveLibraryAsJSON = async (library: Library) => {\n  const libraryItems = await library.loadLibrary();\n  const data: ExportedLibraryData = {\n    type: EXPORT_DATA_TYPES.excalidrawLibrary,\n    version: 1,\n    source: EXPORT_SOURCE,\n    library: libraryItems,\n  };\n  const serialized = JSON.stringify(data, null, 2);\n  const fileName = \"library.excalidrawlib\";\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidrawlib,\n  });\n  await fileSave(blob, {\n    fileName,\n    description: \"Excalidraw library file\",\n    extensions: [\".excalidrawlib\"],\n  });\n};\n\nexport const importLibraryFromJSON = async (library: Library) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw library files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    /*\n    extensions: [\".json\", \".excalidrawlib\"],\n    */\n  });\n  await library.importLibrary(blob);\n};\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { fileOpen } from \"browser-fs-access\";\n\nimport \"./Toolbar.css\";\nimport GitHubCorner from \"./GitHubCorner\";\nimport { getBeginTimeList } from \"./animate\";\nimport { exportToSvgFile, exportToWebmFile, prepareWebmData } from \"./export\";\nimport { ExcalidrawElement } from \"./excalidraw/src/element/types\";\nimport { loadFromJSON } from \"./excalidraw/src/data/json\";\nimport { loadLibraryFromBlob } from \"./excalidraw/src/data/blob\";\nimport { getNonDeletedElements } from \"./excalidraw/src/element\";\nimport { restoreElements } from \"./excalidraw/src/data/restore\";\nimport { AppState } from \"./excalidraw/src/types\";\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)|^http.*\\.excalidrawlib$/;\n\nconst getCombinedBeginTimeList = (svgList: Props[\"svgList\"]) => {\n  const beginTimeList = ([] as number[]).concat(\n    ...svgList.map(({ svg }) =>\n      getBeginTimeList(svg).map((n) => Math.floor(n * 100) / 100)\n    )\n  );\n  return [...new Set(beginTimeList)].sort((a, b) => a - b);\n};\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n  loadDataList: (data: { elements: readonly ExcalidrawElement[] }[]) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ svgList, loadDataList }) => {\n  const [showToolbar, setShowToolbar] = useState<boolean | \"never\">(false);\n  const [paused, setPaused] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [link, setLink] = useState(\"\");\n  const [webmData, setWebmData] = useState<Blob>();\n  useEffect(() => {\n    setWebmData(undefined);\n  }, [svgList]);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (paused) {\n        svg.pauseAnimations();\n      } else {\n        svg.unpauseAnimations();\n      }\n    });\n  }, [svgList, paused]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    } else {\n      setShowToolbar(\"never\");\n    }\n  }, []);\n\n  const loadFile = async () => {\n    const data = await loadFromJSON((undefined as unknown) as AppState);\n    loadDataList([data]);\n  };\n\n  const loadLibrary = async () => {\n    const blob = await fileOpen({\n      description: \"Excalidraw library files\",\n      extensions: [\".json\", \".excalidrawlib\"],\n      mimeTypes: [\"application/json\"],\n    });\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      window.alert(\"Unable to load library\");\n      return;\n    }\n    const dataList = libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n    loadDataList(dataList.map((elements) => ({ elements })));\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    if (match[1]) {\n      window.location.hash = match[0];\n    } else {\n      window.location.hash = `library=${match[0]}`;\n    }\n    window.location.reload();\n  };\n\n  const togglePausedAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    setPaused((p) => !p);\n  }, [svgList]);\n\n  const timer = useRef<NodeJS.Timeout>();\n  const stepForwardAnimations = useCallback(() => {\n    if (!svgList.length) {\n      return;\n    }\n    const beginTimeList = getCombinedBeginTimeList(svgList);\n    const currentTime = svgList[0].svg.getCurrentTime() * 1000;\n    let nextTime = beginTimeList.find((t) => t >= currentTime + 100);\n    if (!nextTime) {\n      nextTime = currentTime + 500;\n    }\n    clearTimeout(timer.current as NodeJS.Timeout);\n    svgList.forEach(({ svg }) => {\n      svg.unpauseAnimations();\n    });\n    timer.current = setTimeout(() => {\n      svgList.forEach(({ svg }) => {\n        svg.pauseAnimations();\n        svg.setCurrentTime((nextTime as number) / 1000);\n      });\n      setPaused(true);\n    }, nextTime - currentTime);\n  }, [svgList]);\n\n  const resetAnimations = useCallback(() => {\n    svgList.forEach(({ svg }) => {\n      svg.setCurrentTime(0);\n    });\n  }, [svgList]);\n\n  useEffect(() => {\n    const onKeydown = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === \"p\") {\n        togglePausedAnimations();\n      } else if (e.key.toLowerCase() === \"s\") {\n        stepForwardAnimations();\n      } else if (e.key.toLowerCase() === \"r\") {\n        resetAnimations();\n      } else if (e.key.toLowerCase() === \"q\") {\n        // toggle toolbar\n        setShowToolbar((s) => (typeof s === \"boolean\" ? !s : s));\n      } else {\n        // show toolbar otherwise\n        setShowToolbar((s) => (typeof s === \"boolean\" ? true : s));\n      }\n    };\n    document.addEventListener(\"keydown\", onKeydown);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeydown);\n    };\n  }, [togglePausedAnimations, stepForwardAnimations, resetAnimations]);\n\n  const hideToolbar = () => {\n    setShowToolbar((s) => (typeof s === \"boolean\" ? false : s));\n  };\n\n  const exportToSvg = () => {\n    if (!svgList.length) {\n      return;\n    }\n    svgList.forEach(({ svg }) => {\n      exportToSvgFile(svg);\n    });\n  };\n\n  const exportToWebm = async () => {\n    if (!svgList.length) {\n      return;\n    }\n    if (webmData) {\n      await exportToWebmFile(webmData);\n      return;\n    }\n    setProcessing(true);\n    setShowToolbar(false);\n    try {\n      const data = await prepareWebmData(svgList);\n      setWebmData(data);\n    } catch (e) {\n      console.log(e);\n    }\n    setShowToolbar(true);\n    setProcessing(false);\n  };\n\n  if (showToolbar !== true) {\n    return null;\n  }\n\n  return (\n    <div className=\"Toolbar\">\n      <div className=\"Toolbar-loader\">\n        <button type=\"button\" onClick={loadFile}>\n          Load File\n        </button>\n        <span>OR</span>\n        <button type=\"button\" onClick={loadLibrary}>\n          Load Library\n        </button>\n        <span>OR</span>\n        <form onSubmit={loadLink}>\n          <input\n            placeholder=\"Enter link...\"\n            value={link}\n            onChange={(e) => setLink(e.target.value)}\n          />\n          <button type=\"submit\" disabled={!linkRegex.test(link)}>\n            Animate!\n          </button>\n        </form>\n      </div>\n      {!!svgList.length && (\n        <div className=\"Toolbar-controller\">\n          <button type=\"button\" onClick={togglePausedAnimations}>\n            {paused ? \"Play (P)\" : \"Pause (P)\"}\n          </button>\n          <button type=\"button\" onClick={stepForwardAnimations}>\n            Step (S)\n          </button>\n          <button type=\"button\" onClick={resetAnimations}>\n            Reset (R)\n          </button>\n          <button type=\"button\" onClick={hideToolbar}>\n            Hide Toolbar (Q)\n          </button>\n          <button type=\"button\" onClick={exportToSvg}>\n            Export to SVG\n          </button>\n          <button type=\"button\" onClick={exportToWebm} disabled={processing}>\n            {processing\n              ? \"Processing...\"\n              : webmData\n              ? \"Export to WebM\"\n              : \"Prepare WebM\"}\n          </button>\n        </div>\n      )}\n      <GitHubCorner\n        link=\"https://github.com/dai-shi/excalidraw-animate\"\n        size={40}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\n\ntype Props = {\n  svgList: {\n    svg: SVGSVGElement;\n    finishedMs: number;\n  }[];\n};\n\nconst Viewer: React.FC<Props> = ({ svgList }) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    svgList.forEach(({ svg }) => {\n      if (ref.current) {\n        ref.current.appendChild(svg);\n      }\n    });\n    return () => {\n      svgList.forEach(({ svg }) => {\n        svg.remove();\n      });\n    };\n  }, [svgList]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"autoplay\") === \"no\") {\n      if (ref.current) {\n        const ele = ref.current;\n        const callback = () => {\n          svgList.forEach(({ svg }) => {\n            svg.setCurrentTime(0);\n            svg.unpauseAnimations();\n          });\n        };\n        ele.addEventListener(\"click\", callback);\n        return () => {\n          ele.removeEventListener(\"click\", callback);\n        };\n      }\n    }\n  }, [svgList]);\n\n  const repeat = Math.ceil(Math.sqrt(svgList.length));\n  const grids = `repeat(${repeat}, ${100 / repeat}%)`;\n\n  return (\n    <div\n      className=\"Viewer\"\n      style={{\n        gridTemplateColumns: grids,\n        gridTemplateRows: grids,\n      }}\n      ref={ref}\n    ></div>\n  );\n};\n\nexport default Viewer;\n","import { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport { AppState, UserIdleState } from \"../../types\";\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n  IDLE_STATUS: {\n    type: \"IDLE_STATUS\";\n    payload: {\n      socketId: string;\n      userState: UserIdleState;\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData = SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n  _brand: \"socketUpdateData\";\n};\n\nconst IV_LENGTH_BYTES = 12; // 96 bits\n\nexport const createIV = () => {\n  const arr = new Uint8Array(IV_LENGTH_BYTES);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  const hash = new URL(link).hash;\n  const match = hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n  return match ? { roomId: match[1], roomKey: match[2] } : null;\n};\n\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRandomID();\n  const roomKey = await generateEncryptionKey();\n\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n\n  return { roomId, roomKey };\n};\n\nexport const getCollaborationLink = (data: {\n  roomId: string;\n  roomKey: string;\n}) => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\nexport const getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nconst decryptImported = async (\n  iv: ArrayBuffer,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n\n      let decrypted: ArrayBuffer;\n      try {\n        // Buffer should contain both the IV (fixed length) and encrypted data\n        const iv = buffer.slice(0, IV_LENGTH_BYTES);\n        const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n        decrypted = await decryptImported(iv, encrypted, privateKey);\n      } catch (error) {\n        // Fixed IV (old format, backward compatibility)\n        const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n        decrypted = await decryptImported(fixedIv, buffer, privateKey);\n      }\n\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n    );\n  } else {\n    data = restore(localDataState || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n\n  const iv = createIV();\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encoded,\n  );\n\n  // Concatenate IV with encrypted data (IV does not have to be secret).\n  const payloadBlob = new Blob([iv.buffer, encrypted]);\n  const payload = await new Response(payloadBlob).arrayBuffer();\n\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: payload,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n      window.prompt(`${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords, supportsEmoji } from \"../utils\";\nimport { UserIdleState } from \"../types\";\nimport { THEME_FILTER } from \"../constants\";\n\nconst hasEmojiSupport = supportsEmoji();\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      fillCircle(\n        context,\n        point[0],\n        point[1],\n        POINT_HANDLE_SIZE / 2 / sceneState.zoom.value,\n      );\n    },\n  );\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    // doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n  } = {},\n) => {\n  if (canvas === null) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  if (sceneState.exportWithDarkMode) {\n    context.filter = THEME_FILTER;\n  }\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom.value,\n      normalizedCanvasHeight / sceneState.zoom.value,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n      zoom: sceneState.zoom,\n      offsetLeft: appState.offsetLeft,\n      offsetTop: appState.offsetTop,\n      scrollX: sceneState.scrollX,\n      scrollY: sceneState.scrollY,\n    }),\n  );\n\n  visibleElements.forEach((element) => {\n    try {\n      renderElement(element, rc, context, renderOptimizations, sceneState);\n    } catch (error) {\n      console.error(error);\n    }\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    try {\n      renderElement(\n        selectionElement,\n        rc,\n        context,\n        renderOptimizations,\n        sceneState,\n      );\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(context, sceneState, suggestedBinding!);\n      });\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId, appState);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n        ] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    const addSelectionForGroupId = (groupId: GroupId) => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(\n        groupElements,\n      );\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach((selection) =>\n      renderSelectionBorder(context, sceneState, selection),\n    );\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize transformHandles\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n        \"mouse\", // when we render we don't know which pointer type so use mouse\n      );\n      if (!appState.viewModeEnabled) {\n        renderTransformHandles(\n          context,\n          sceneState,\n          transformHandles,\n          locallySelectedElements[0].angle,\n        );\n      }\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        \"mouse\",\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom.value, 1 / sceneState.zoom.value);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId, appState);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    const userState = sceneState.remotePointerUserStates[clientId];\n    if (isOutOfBounds || userState === UserIdleState.AWAY) {\n      context.globalAlpha = 0.48;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    let idleState = \"\";\n    if (userState === UserIdleState.AWAY) {\n      idleState = hasEmojiSupport ? \"\" : ` (${UserIdleState.AWAY})`;\n    } else if (userState === UserIdleState.IDLE) {\n      idleState = hasEmojiSupport ? \"\" : ` (${UserIdleState.IDLE})`;\n    } else if (userState === UserIdleState.ACTIVE) {\n      idleState = hasEmojiSupport ? \"\" : \"\";\n    }\n\n    const usernameAndIdleState = `${\n      username ? `${username} ` : \"\"\n    }${idleState}`;\n\n    if (!isOutOfBounds && usernameAndIdleState) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(usernameAndIdleState);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n\n      context.fillText(\n        usernameAndIdleState,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      if (key === \"rotation\") {\n        fillCircle(\n          context,\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          transformHandle[2] / 2,\n        );\n      } else {\n        strokeRectWithRotation(\n          context,\n          transformHandle[0],\n          transformHandle[1],\n          transformHandle[2],\n          transformHandle[3],\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.lineWidth = lineWidth;\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n  },\n) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const initialLineDash = context.getLineDash();\n  const lineWidth = context.lineWidth;\n  const lineDashOffset = context.lineDashOffset;\n  const strokeStyle = context.strokeStyle;\n\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([\n      dashWidth,\n      spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n    ]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - dashedLinePadding,\n      elementY1 - dashedLinePadding,\n      elementWidth + dashedLinePadding * 2,\n      elementHeight + dashedLinePadding * 2,\n      elementX1 + elementWidth / 2,\n      elementY1 + elementHeight / 2,\n      angle,\n    );\n  }\n  context.lineDashOffset = lineDashOffset;\n  context.strokeStyle = strokeStyle;\n  context.lineWidth = lineWidth;\n  context.setLineDash(initialLineDash);\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  suggestedBinding: SuggestedBinding,\n) => {\n  // preserve context settings to restore later\n  const originalStrokeStyle = context.strokeStyle;\n  const originalLineWidth = context.lineWidth;\n\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  // restore context settings\n  context.strokeStyle = originalStrokeStyle;\n  context.lineWidth = originalLineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      try {\n        renderElementToSvg(\n          element,\n          rsvg,\n          svgRoot,\n          element.x + offsetX,\n          element.y + offsetY,\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  });\n};\n","import rough from \"roughjs/bin/rough\";\nimport oc from \"open-color\";\nimport { newTextElement } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { AppState } from \"../types\";\nimport { t } from \"../i18n\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_VERTICAL_ALIGN,\n  THEME_FILTER,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\nconst WATERMARK_HEIGHT = 16;\n\nexport const exportToCanvas = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n  },\n  createCanvas: (\n    width: number,\n    height: number,\n  ) => { canvas: HTMLCanvasElement; scale: number } = (width, height) => {\n    const tempCanvas = document.createElement(\"canvas\");\n    tempCanvas.width = width * scale;\n    tempCanvas.height = height * scale;\n    return { canvas: tempCanvas, scale };\n  },\n) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  const { canvas: tempCanvas, scale: newScale = scale } = createCanvas(\n    width,\n    height,\n  );\n\n  renderScene(\n    sceneElements,\n    appState,\n    null,\n    newScale,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      exportWithDarkMode: appState.exportWithDarkMode,\n      scrollX: -minX + exportPadding,\n      scrollY: -minY + exportPadding,\n      zoom: getDefaultAppState().zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: false,\n      renderGrid: false,\n    },\n  );\n\n  return tempCanvas;\n};\n\nexport const exportToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    exportWithDarkMode,\n    scale = 1,\n    shouldAddWatermark,\n    metadata = \"\",\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    exportWithDarkMode?: boolean;\n    shouldAddWatermark: boolean;\n    metadata?: string;\n  },\n): SVGSVGElement => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * scale}`);\n  svgRoot.setAttribute(\"height\", `${height * scale}`);\n  if (exportWithDarkMode) {\n    svgRoot.setAttribute(\"filter\", THEME_FILTER);\n  }\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render background rect\n  if (exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(sceneElements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\nconst getElementsAndWatermark = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  shouldAddWatermark: boolean,\n): readonly NonDeletedExcalidrawElement[] => {\n  let _elements = [...elements];\n\n  if (shouldAddWatermark) {\n    const [, , maxX, maxY] = getCommonBounds(elements);\n    _elements = [..._elements, getWatermarkElement(maxX, maxY)];\n  }\n\n  return _elements;\n};\n\nconst getWatermarkElement = (maxX: number, maxY: number) => {\n  return newTextElement({\n    text: t(\"labels.madeWithExcalidraw\"),\n    fontSize: WATERMARK_HEIGHT,\n    fontFamily: DEFAULT_FONT_FAMILY,\n    textAlign: \"right\",\n    verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    x: maxX,\n    y: maxY + WATERMARK_HEIGHT,\n    strokeColor: oc.gray[5],\n    backgroundColor: \"transparent\",\n    fillStyle: \"hachure\",\n    strokeWidth: 1,\n    strokeStyle: \"solid\",\n    roughness: 1,\n    opacity: 100,\n    strokeSharpness: \"sharp\",\n  });\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height =\n    distance(minY, maxY) +\n    exportPadding +\n    (shouldAddWatermark ? 0 : exportPadding);\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n  scale: number,\n): [number, number] => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [, , width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  ).map((dimension) => Math.trunc(dimension * scale));\n\n  return [width, height];\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { loadScene } from \"./excalidraw/src/excalidraw-app/data\";\nimport { isValidLibrary } from \"./excalidraw/src/data/json\";\nimport { loadLibraryFromBlob } from \"./excalidraw/src/data/blob\";\nimport { restoreElements } from \"./excalidraw/src/data/restore\";\nimport { exportToSvg } from \"./excalidraw/src/scene/export\";\nimport { getNonDeletedElements } from \"./excalidraw/src/element\";\nimport { ExcalidrawElement } from \"./excalidraw/src/element/types\";\nimport { AppState } from \"./excalidraw/src/types\";\n\nimport { animateSvg } from \"./animate\";\n\ntype RestoredAppState = Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n>;\n\nconst importLibraryFromUrl = async (url: string) => {\n  try {\n    const request = await fetch(url);\n    const blob = await request.blob();\n    const json = JSON.parse(await blob.text());\n    if (!isValidLibrary(json)) {\n      throw new Error();\n    }\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      throw new Error();\n    }\n    return libraryFile.library.map((libraryItem) =>\n      getNonDeletedElements(restoreElements(libraryItem))\n    );\n  } catch (error) {\n    window.alert(\"Unable to load library\");\n    return [];\n  }\n};\n\nexport const useLoadSvg = () => {\n  const [loading, setLoading] = useState(true);\n  const [loadedSvgList, setLoadedSvgList] = useState<\n    {\n      svg: SVGSVGElement;\n      finishedMs: number;\n    }[]\n  >([]);\n\n  const loadDataList = useCallback(\n    (\n      dataList: {\n        elements: readonly ExcalidrawElement[];\n        appState?: RestoredAppState;\n      }[],\n      inSequence?: boolean\n    ) => {\n      let startMs: number | undefined;\n      const svgList = dataList.map((data) => {\n        const elements = getNonDeletedElements(data.elements);\n        const svg = exportToSvg(\n          elements,\n          data?.appState || {\n            exportBackground: true,\n            exportPadding: 30,\n            viewBackgroundColor: \"white\",\n            shouldAddWatermark: false,\n          }\n        );\n        const result = animateSvg(svg, elements, startMs);\n        console.log(svg);\n        if (inSequence) {\n          startMs = result.finishedMs;\n        }\n        return { svg, finishedMs: result.finishedMs };\n      });\n      setLoadedSvgList(svgList);\n      return svgList;\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const matchIdKey = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (matchIdKey) {\n        const [, id, key] = matchIdKey;\n        const data = await loadScene(id, key, null);\n        const [{ svg, finishedMs }] = loadDataList([data]);\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svg.setCurrentTime(finishedMs);\n        }\n      }\n      const matchLibrary = /(.*\\.excalidrawlib)/.exec(\n        searchParams.get(\"library\") || \"\"\n      );\n      if (matchLibrary) {\n        const [, url] = matchLibrary;\n        const dataList = await importLibraryFromUrl(url);\n        const svgList = loadDataList(\n          dataList.map((elements) => ({ elements })),\n          searchParams.has(\"sequence\")\n        );\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svgList.forEach(({ svg, finishedMs }) => {\n            svg.setCurrentTime(finishedMs);\n          });\n        }\n      }\n      setLoading(false);\n    })();\n  }, [loadDataList]);\n\n  return { loading, loadedSvgList, loadDataList };\n};\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadSvg } from \"./useLoadSvg\";\n\nconst App: React.FC = () => {\n  const { loading, loadedSvgList, loadDataList } = useLoadSvg();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      <Toolbar svgList={loadedSvgList} loadDataList={loadDataList} />\n      {!!loadedSvgList.length && <Viewer svgList={loadedSvgList} />}\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}