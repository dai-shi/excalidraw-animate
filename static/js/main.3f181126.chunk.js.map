{"version":3,"sources":["excalidraw/src/locales lazy /^/.//.*$/ groupOptions: {} namespace object","excalidraw/src/constants.ts","GitHubCorner.tsx","export.ts","excalidraw/src/element/typeChecks.ts","excalidraw/src/math.ts","excalidraw/src/element/bounds.ts","excalidraw/src/renderer/renderElement.ts","excalidraw/src/scene/Scene.ts","excalidraw/src/random.ts","excalidraw/src/element/mutateElement.ts","excalidraw/src/points.ts","excalidraw/src/element/sizeHelpers.ts","excalidraw/src/element/newElement.ts","excalidraw/src/element/index.ts","excalidraw/src/keys.ts","excalidraw/src/i18n.ts","excalidraw/src/scene/scrollbars.ts","excalidraw/src/scene/scroll.ts","excalidraw/src/scene/zoom.ts","excalidraw/src/utils.ts","excalidraw/src/appState.ts","excalidraw/src/data/restore.ts","excalidraw/src/data/blob.ts","excalidraw/src/data/json.ts","Toolbar.tsx","Viewer.tsx","excalidraw/src/colors.ts","excalidraw/src/element/linearElementEditor.ts","excalidraw/src/renderer/renderScene.ts","excalidraw/src/scene/export.ts","excalidraw/src/clipboard.ts","excalidraw/src/data/index.ts","animate.ts","useLoadSvg.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","t","keys","Object","module","exports","SCENE","EVENT","GitHubCorner","link","size","fill","color","href","className","aria-label","target","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","resourceCache","Map","embedUrlResources","text","a","urls","match","url","reject","has","get","fetch","response","blob","reader","FileReader","onload","resource","result","set","onerror","readAsDataURL","catch","resources","replace","shift","generateImagesFromSvg","container","svg","finishedMs","fps","pauseAnimations","images","loop","unpauseAnimations","setCurrentTime","innerHTML","html","img","Image","src","btoa","push","err","window","alert","exportToSvgFile","savedMs","getCurrentTime","svgStr","XMLSerializer","serializeToString","fileSave","Blob","type","fileName","exportToWebmFile","parentNode","getAttribute","canvas","document","createElement","setAttribute","ctx","getContext","stream","captureStream","recorder","MediaRecorder","ondataavailable","data","start","index","drawSvg","length","stop","drawImage","setTimeout","isTextElement","element","isLinearElement","Math","PI","FONT_FAMILY","1","2","3","rotate","x1","y1","x2","y2","angle","cos","sin","distance2d","xd","yd","hypot","isPathALoop","points","firstPoint","lastPoint","getElementAbsoluteCoords","getLinearElementAbsoluteCoords","x","y","getDiamondPoints","topX","floor","rightX","rightY","getCurvePathOps","shape","sets","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","reduce","limits","op","p1","p2","p3","p0","equation","idx","pow","minY","min","minX","maxX","max","maxY","Infinity","getShapeForElement","getElementBounds","cx","cy","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","w","h","ww","hh","getCommonBounds","elements","forEach","getElementPointsCoords","curve","rough","generator","generateRoughOptions","DASHARRAY_DASHED","DASHARRAY_DOTTED","elementWithCanvasCache","WeakMap","shapeCache","options","seed","strokeLineDash","strokeStyle","undefined","disableMultiStroke","strokeWidth","fillWeight","hachureGap","roughness","stroke","strokeColor","fillStyle","backgroundColor","curveFitting","generateElementShape","delete","rectangle","topY","bottomX","bottomY","leftX","leftY","polygon","ellipse","prevOp","distance","nx","ny","arrowLength","total","px","py","minSize","xs","ys","x3","y3","getArrowPoints","x4","y4","line","renderElementToSvg","rsvg","svgRoot","offsetX","offsetY","degree","node","draw","opacity","appendChild","group","ownerDocument","createElementNS","SVG_NS","lines","split","lineHeight","verticalOffset","baseline","horizontalOffset","textAlign","direction","isRTL","textAnchor","i","textContent","getFontFamilyString","fontSize","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elementsMap","this","getElement","isNonDeletedElement","nextElements","clear","mapElementToScene","getNonDeletedElements","informMutation","Array","from","callback","cb","add","sceneMapById","scene","sceneMapByElement","random","Random","Date","now","randomInteger","next","randomId","nanoid","mutateElement","updates","didChange","key","point","getSizeFromPoints","value","prevPoints","nextPoints","didChangePoints","prevPoint","nextPoint","invalidateShapeForElement","version","versionNonce","getScene","newElementWith","isInvisiblySmallElement","_newElementBase","groupIds","rest","isDeleted","getTextElementPositionOffsets","opts","metrics","verticalAlign","newTextElement","measureText","getFontString","offsets","fontFamily","test","navigator","platform","filter","languages","lng","label","concat","rtl","sort","left","lang","percentages","currentLanguageData","findPartsForData","parts","part","path","replacement","translation","fallbackLanguageData","languageDetector","LanguageDetector","init","languageUtils","formatLanguageCode","isWhitelisted","checkWhitelist","normalizeScroll","pos","calculateScrollCenter","appState","scrollX","scrollY","scale","devicePixelRatio","cords","sceneCoordsToViewportCoords","sceneX","sceneY","viewportX1","viewportY1","viewportX2","viewportY2","isOutsideViewPort","minDistance","closestElement","getClosestElementBounds","viewportCoordsToSceneCoords","clientX","clientY","centerX","centerY","getZoomOrigin","mockDateTime","getDateTime","date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","getMinutes","font","body","whiteSpace","innerText","join","offsetWidth","offsetHeight","span","display","overflow","offsetTop","removeChild","abs","zoomOrigin","clientXWithZoom","offsetLeft","zoom","clientYWithZoom","RE_RTL_CHECK","RegExp","getDefaultAppState","isLoading","errorMessage","draggingElement","resizingElement","multiElement","editingElement","editingLinearElement","elementType","elementLocked","exportBackground","shouldAddWatermark","currentItemStrokeColor","oc","black","currentItemBackgroundColor","currentItemFillStyle","currentItemStrokeWidth","currentItemStrokeStyle","currentItemRoughness","currentItemOpacity","currentItemFontSize","currentItemFontFamily","currentItemTextAlign","viewBackgroundColor","white","cursorX","cursorY","cursorButton","scrolledOutside","name","username","isCollaborating","isResizing","isRotating","selectionElement","openMenu","lastPointerDownWith","selectedElementIds","previousSelectedElementIds","collaborators","shouldCacheIgnoreZoom","showShortcutsDialog","zenModeEnabled","gridSize","editingGroupId","selectedGroupIds","innerWidth","innerHeight","isLibraryOpen","APP_STATE_STORAGE_CONF","browser","export","_clearAppStateForStorage","exportType","stateForExport","propConfig","console","error","cleanAppStateForExport","migrateElementWithProperties","extra","base","ret","nextWidth","nextHeight","getNormalizedDimensions","migrateElement","fontPx","_fontFamily","parseInt","fontFamilyName","entries","includes","getFontFamilyByName","isArray","lastCommittedPoint","restore","savedElements","savedState","migratedElement","loadFileContents","contents","readAsText","onloadend","readyState","DONE","loadFromBlob","handle","defaultAppState","_appState","JSON","parse","loadFromJSON","fileOpen","description","extensions","mimeTypes","linkRegex","Toolbar","loadData","useState","showToolbar","setShowToolbar","paused","setPaused","processing","setProcessing","setLink","useEffect","hash","location","URLSearchParams","loadFile","togglePausedAnimations","useCallback","p","resetAnimations","onKeydown","toLowerCase","s","addEventListener","removeEventListener","exportToWebm","onClick","onSubmit","event","preventDefault","exec","reload","placeholder","onChange","disabled","Viewer","ref","useRef","current","remove","ele","shades","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","LinearElementEditor","gray","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","normalizePoints","getNonDeletedElement","setState","scenePointerX","scenePointerY","newPoint","createPointAt","movePoint","history","didAddPoint","hitElement","altKey","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","targetPoint","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","pointerOnGrid","round","getGridPoint","rotatedX","rotatedY","_idx","pointIndex","targetPosition","splice","deltaX","deltaY","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","rotated","exportToSvg","exportPadding","sceneElements","getWatermarkElement","rect","renderSceneToSvg","clipboard","HTMLCanvasElement","prototype","getImportedKey","usage","crypto","subtle","importKey","alg","ext","k","key_ops","kty","importFromBackend","privateKey","process","ok","arrayBuffer","buffer","iv","Uint8Array","decrypt","decrypted","string","TextDecoder","decode","json","animatePath","currentMs","durationMs","dTo","mCount","repeat","dLast","dFrom","animate","animateFillPath","animateRect","dups","pathForTextIndex","patchSvgText","childNodes","len","child","textPath","tagName","findNode","animateText","patchSvgEle","patchSvgLine","patchSvgArrow","patchSvgRectangle","patchSvgEllipse","useLoadSvg","loading","setLoading","loadedSvg","setLoadedSvg","setFinishedMs","groups","groupId","createGroups","finished","dur","childEle","childIndex","childType","childWidth","animateSvg","log","searchParams","App","Boolean","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"o/NAAA,IAAIA,EAAM,CACT,cAAe,CACd,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,OAAQ,CACP,GACA,GAED,YAAa,CACZ,GACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,gBAAiB,CAChB,GACA,GAED,qBAAsB,CACrB,GACA,GAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,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","file":"static/js/main.3f181126.chunk.js","sourcesContent":["var map = {\n\t\"./README.md\": [\n\t\t69,\n\t\t7,\n\t\t31\n\t],\n\t\"./ar-SA\": [\n\t\t29,\n\t\t3,\n\t\t0\n\t],\n\t\"./ar-SA.json\": [\n\t\t29,\n\t\t3,\n\t\t0\n\t],\n\t\"./bg-BG\": [\n\t\t30,\n\t\t3,\n\t\t1\n\t],\n\t\"./bg-BG.json\": [\n\t\t30,\n\t\t3,\n\t\t1\n\t],\n\t\"./ca-ES\": [\n\t\t31,\n\t\t3,\n\t\t2\n\t],\n\t\"./ca-ES.json\": [\n\t\t31,\n\t\t3,\n\t\t2\n\t],\n\t\"./de-DE\": [\n\t\t32,\n\t\t3,\n\t\t3\n\t],\n\t\"./de-DE.json\": [\n\t\t32,\n\t\t3,\n\t\t3\n\t],\n\t\"./el-GR\": [\n\t\t33,\n\t\t3,\n\t\t4\n\t],\n\t\"./el-GR.json\": [\n\t\t33,\n\t\t3,\n\t\t4\n\t],\n\t\"./en\": [\n\t\t17,\n\t\t3\n\t],\n\t\"./en.json\": [\n\t\t17,\n\t\t3\n\t],\n\t\"./es-ES\": [\n\t\t34,\n\t\t3,\n\t\t5\n\t],\n\t\"./es-ES.json\": [\n\t\t34,\n\t\t3,\n\t\t5\n\t],\n\t\"./fa-IR\": [\n\t\t35,\n\t\t3,\n\t\t6\n\t],\n\t\"./fa-IR.json\": [\n\t\t35,\n\t\t3,\n\t\t6\n\t],\n\t\"./fi-FI\": [\n\t\t36,\n\t\t3,\n\t\t7\n\t],\n\t\"./fi-FI.json\": [\n\t\t36,\n\t\t3,\n\t\t7\n\t],\n\t\"./fr-FR\": [\n\t\t37,\n\t\t3,\n\t\t8\n\t],\n\t\"./fr-FR.json\": [\n\t\t37,\n\t\t3,\n\t\t8\n\t],\n\t\"./he-IL\": [\n\t\t38,\n\t\t3,\n\t\t9\n\t],\n\t\"./he-IL.json\": [\n\t\t38,\n\t\t3,\n\t\t9\n\t],\n\t\"./hi-IN\": [\n\t\t39,\n\t\t3,\n\t\t10\n\t],\n\t\"./hi-IN.json\": [\n\t\t39,\n\t\t3,\n\t\t10\n\t],\n\t\"./hu-HU\": [\n\t\t40,\n\t\t3,\n\t\t11\n\t],\n\t\"./hu-HU.json\": [\n\t\t40,\n\t\t3,\n\t\t11\n\t],\n\t\"./id-ID\": [\n\t\t41,\n\t\t3,\n\t\t12\n\t],\n\t\"./id-ID.json\": [\n\t\t41,\n\t\t3,\n\t\t12\n\t],\n\t\"./it-IT\": [\n\t\t42,\n\t\t3,\n\t\t13\n\t],\n\t\"./it-IT.json\": [\n\t\t42,\n\t\t3,\n\t\t13\n\t],\n\t\"./ja-JP\": [\n\t\t43,\n\t\t3,\n\t\t14\n\t],\n\t\"./ja-JP.json\": [\n\t\t43,\n\t\t3,\n\t\t14\n\t],\n\t\"./ko-KR\": [\n\t\t44,\n\t\t3,\n\t\t15\n\t],\n\t\"./ko-KR.json\": [\n\t\t44,\n\t\t3,\n\t\t15\n\t],\n\t\"./nb-NO\": [\n\t\t45,\n\t\t3,\n\t\t16\n\t],\n\t\"./nb-NO.json\": [\n\t\t45,\n\t\t3,\n\t\t16\n\t],\n\t\"./nl-NL\": [\n\t\t46,\n\t\t3,\n\t\t17\n\t],\n\t\"./nl-NL.json\": [\n\t\t46,\n\t\t3,\n\t\t17\n\t],\n\t\"./nn-NO\": [\n\t\t47,\n\t\t3,\n\t\t18\n\t],\n\t\"./nn-NO.json\": [\n\t\t47,\n\t\t3,\n\t\t18\n\t],\n\t\"./percentages\": [\n\t\t18,\n\t\t3\n\t],\n\t\"./percentages.json\": [\n\t\t18,\n\t\t3\n\t],\n\t\"./pl-PL\": [\n\t\t48,\n\t\t3,\n\t\t19\n\t],\n\t\"./pl-PL.json\": [\n\t\t48,\n\t\t3,\n\t\t19\n\t],\n\t\"./pt-PT\": [\n\t\t49,\n\t\t3,\n\t\t20\n\t],\n\t\"./pt-PT.json\": [\n\t\t49,\n\t\t3,\n\t\t20\n\t],\n\t\"./ru-RU\": [\n\t\t50,\n\t\t3,\n\t\t21\n\t],\n\t\"./ru-RU.json\": [\n\t\t50,\n\t\t3,\n\t\t21\n\t],\n\t\"./sq-AL\": [\n\t\t51,\n\t\t3,\n\t\t22\n\t],\n\t\"./sq-AL.json\": [\n\t\t51,\n\t\t3,\n\t\t22\n\t],\n\t\"./ta-IN\": [\n\t\t52,\n\t\t3,\n\t\t23\n\t],\n\t\"./ta-IN.json\": [\n\t\t52,\n\t\t3,\n\t\t23\n\t],\n\t\"./tr-TR\": [\n\t\t53,\n\t\t3,\n\t\t24\n\t],\n\t\"./tr-TR.json\": [\n\t\t53,\n\t\t3,\n\t\t24\n\t],\n\t\"./uk-UA\": [\n\t\t54,\n\t\t3,\n\t\t25\n\t],\n\t\"./uk-UA.json\": [\n\t\t54,\n\t\t3,\n\t\t25\n\t],\n\t\"./zh-CN\": [\n\t\t55,\n\t\t3,\n\t\t26\n\t],\n\t\"./zh-CN.json\": [\n\t\t55,\n\t\t3,\n\t\t26\n\t],\n\t\"./zh-TW\": [\n\t\t56,\n\t\t3,\n\t\t27\n\t],\n\t\"./zh-TW.json\": [\n\t\t56,\n\t\t3,\n\t\t27\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(2).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, ids[1])\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 24;\nmodule.exports = webpackAsyncContext;","import { FontFamily } from \"./element/types\";\n\nexport const DRAGGING_THRESHOLD = 10; // 10px\nexport const LINE_CONFIRM_THRESHOLD = 10; // 10px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  POINTER: \"pointer\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum SCENE {\n  INIT = \"SCENE_INIT\",\n  UPDATE = \"SCENE_UPDATE\",\n}\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n  HASHCHANGE = \"hashchange\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const BROADCAST = {\n  SERVER_VOLATILE: \"server-volatile-broadcast\",\n  SERVER: \"server-broadcast\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  1: \"Virgil\",\n  2: \"Helvetica\",\n  3: \"Cascadia\",\n} as const;\n\nexport const WINDOWS_EMOJI_FALLBACK_FONT = \"Segoe UI Emoji\";\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamily = 1;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n\nexport const LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG = \"collabLinkForceLoadFlag\";\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\ntype Props = {\n  link: string;\n  size?: number;\n  fill?: string;\n  color?: string;\n};\n\n// http://tholman.com/github-corners/\nconst GitHubCorner: React.FC<Props> = ({ link, size, fill, color }) => (\n  <a\n    href={link}\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n);\n\nexport default GitHubCorner;\n","import { fileSave } from \"browser-nativefs\";\n\nconst resourceCache = new Map<string, string>();\n\nconst embedUrlResources = async (text: string) => {\n  const urls = text.match(/url\\(\".*?\"\\);/g) || [];\n  const resources = await Promise.all<string>(\n    urls.map(\n      (url) =>\n        new Promise((resolve, reject) => {\n          url = url.slice(5, -3);\n          if (resourceCache.has(url)) {\n            resolve(resourceCache.get(url));\n            return;\n          }\n          fetch(url)\n            .then((response) => response.blob())\n            .then((blob) => {\n              const reader = new FileReader();\n              reader.onload = () => {\n                const resource = `url(${reader.result});`;\n                resourceCache.set(url, resource);\n                resolve(resource);\n              };\n              reader.onerror = reject;\n              reader.readAsDataURL(blob);\n            })\n            .catch(reject);\n        })\n    )\n  );\n  return text.replace(/url\\(\".*?\"\\);/g, () => resources.shift() as string);\n};\n\nconst generateImagesFromSvg = (\n  container: HTMLDivElement,\n  svg: SVGSVGElement,\n  finishedMs: number,\n  fps: number\n) =>\n  new Promise<HTMLImageElement[]>((resolve, reject) => {\n    svg.pauseAnimations();\n    const images: HTMLImageElement[] = [];\n    const loop = async (t: number) => {\n      if (t > finishedMs) {\n        svg.unpauseAnimations();\n        resolve(images);\n        return;\n      }\n      svg.setCurrentTime(t / 1000);\n      const html = await embedUrlResources(container.innerHTML);\n      const img = new Image();\n      img.src = \"data:image/svg+xml;base64,\" + btoa(html);\n      img.onload = () => {\n        images.push(img);\n        loop(t + 1000 / fps);\n      };\n      img.onerror = (err) => {\n        window.alert(\"Unexpected error while preparing images\");\n        reject(err);\n      };\n    };\n    loop(0);\n  });\n\nexport const exportToSvgFile = async (svg: SVGSVGElement) => {\n  const savedMs = svg.getCurrentTime();\n  svg.setCurrentTime(0);\n  const svgStr = new XMLSerializer().serializeToString(svg);\n  svg.setCurrentTime(savedMs);\n  await fileSave(new Blob([svgStr], { type: \"svg\" }), {\n    fileName: \"excalidraw-animate.svg\",\n  });\n};\n\nexport const exportToWebmFile = (svg: SVGSVGElement, finishedMs: number) =>\n  new Promise(async (resolve) => {\n    // This parentNode is not nice.\n    // We would like to export it off screen.\n    const container = svg.parentNode;\n    if (!container) {\n      window.alert(\"svg is not displayed\");\n      resolve();\n      return;\n    }\n    const images = await generateImagesFromSvg(\n      container as HTMLDivElement,\n      svg,\n      finishedMs,\n      60\n    );\n    const [, width, height] =\n      svg.getAttribute(\"viewBox\")?.match(/0 0 (\\S+) (\\S+)/) || [];\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"width\", `${width}px`);\n    canvas.setAttribute(\"height\", `${height}px`);\n    const ctx = canvas.getContext(\"2d\");\n    const stream = (canvas as any).captureStream();\n    const recorder = new MediaRecorder(stream);\n    recorder.ondataavailable = async (e) => {\n      await fileSave(new Blob([e.data], { type: e.data.type }), {\n        fileName: \"excalidraw-animate.webm\",\n      });\n    };\n    recorder.start();\n    let index = 0;\n    const drawSvg = () => {\n      if (index >= images.length) {\n        recorder.stop();\n        resolve();\n        return;\n      }\n      ctx?.drawImage(images[index], 0, 0);\n      index += 1;\n      setTimeout(drawSvg, 1000 / 60);\n    };\n    drawSvg();\n  });\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n} from \"./types\";\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return (\n    element != null &&\n    (element.type === \"arrow\" ||\n      element.type === \"line\" ||\n      element.type === \"draw\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"draw\" ||\n    element?.type === \"line\"\n  );\n};\n","import { Point } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\n// https://stackoverflow.com/a/6853926/232122\nexport const distanceBetweenPointAndSegment = (\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n) => {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n};\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getFlipAdjustment = (\n  side: \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\",\n  nextWidth: number,\n  nextHeight: number,\n  nextX1: number,\n  nextY1: number,\n  nextX2: number,\n  nextY2: number,\n  finalX1: number,\n  finalY1: number,\n  finalX2: number,\n  finalY2: number,\n  needsRotation: boolean,\n  angle: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  let flipDiffX = 0;\n  let flipDiffY = 0;\n  if (nextWidth < 0) {\n    if (side === \"e\" || side === \"ne\" || side === \"se\") {\n      if (needsRotation) {\n        flipDiffX += (finalX2 - nextX1) * cos;\n        flipDiffY += (finalX2 - nextX1) * sin;\n      } else {\n        flipDiffX += finalX2 - nextX1;\n      }\n    }\n    if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n      if (needsRotation) {\n        flipDiffX += (finalX1 - nextX2) * cos;\n        flipDiffY += (finalX1 - nextX2) * sin;\n      } else {\n        flipDiffX += finalX1 - nextX2;\n      }\n    }\n  }\n  if (nextHeight < 0) {\n    if (side === \"s\" || side === \"se\" || side === \"sw\") {\n      if (needsRotation) {\n        flipDiffY += (finalY2 - nextY1) * cos;\n        flipDiffX += (finalY2 - nextY1) * -sin;\n      } else {\n        flipDiffY += finalY2 - nextY1;\n      }\n    }\n    if (side === \"n\" || side === \"ne\" || side === \"nw\") {\n      if (needsRotation) {\n        flipDiffY += (finalY1 - nextY2) * cos;\n        flipDiffX += (finalY1 - nextY2) * -sin;\n      } else {\n        flipDiffY += finalY1 - nextY2;\n      }\n    }\n  }\n  return [flipDiffX, flipDiffY];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n): boolean => {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return (\n      distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <=\n      LINE_CONFIRM_THRESHOLD\n    );\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doIntersect(current, next, p, extreme)) {\n      if (orientation(current, p, next) === 0) {\n        return onSegment(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Check if q lies on the line segment pr\nconst onSegment = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are collinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orientation(p1, q1, p2);\n  const o2 = orientation(p1, q1, q2);\n  const o3 = orientation(p2, q2, p1);\n  const o4 = orientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && onSegment(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && onSegment(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import { ExcalidrawElement, ExcalidrawLinearElement } from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getArrowPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n) => {\n  const ops = getCurvePathOps(shape[0]);\n\n  const data = ops[ops.length - 1].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n  const prevOp = ops[ops.length - 2];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // we know the last point of the arrow\n  const [x2, y2] = p3;\n\n  // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // find the normalized direction vector based on the\n  // previously calculated points\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = 30; // pixels\n  const arrowLength = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n  const minSize = Math.min(size, arrowLength / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!isLinearElement(element)) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  const gen = rough.generator();\n  const curve = gen.curve(\n    points as [number, number][],\n    generateRoughOptions(element),\n  );\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve = gen.curve(\n    points as [number, number][],\n    generateRoughOptions(element),\n  );\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { isTextElement, isLinearElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getArrowPoints,\n  getElementAbsoluteCoords,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\n\nconst CANVAS_PADDING = 20;\n\nconst DASHARRAY_DASHED = [12, 8];\nconst DASHARRAY_DOTTED = [3, 6];\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: number;\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: number,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio\n        : 0;\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio\n        : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  context.scale(\n    1 / (window.devicePixelRatio * zoom),\n    1 / (window.devicePixelRatio * zoom),\n  );\n  return { element, canvas, canvasZoom: zoom, canvasOffsetX, canvasOffsetY };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"draw\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          //  to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let i = 0; i < lines.length; i++) {\n          context.fillText(\n            lines[i],\n            horizontalOffset,\n            (i + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (element: ExcalidrawElement): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? DASHARRAY_DASHED\n        : element.strokeStyle === \"dotted\"\n        ? DASHARRAY_DOTTED\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    //  dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    //  similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    //  hachureGap because if not specified, roughjs uses strokeWidth to\n    //  calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"draw\": {\n      // If shape is a line and is a closed shape,\n      // fill the shape if a color is set.\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(\n          0,\n          0,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"draw\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        shape = [generator.curve(points as [number, number][], options)];\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const [x2, y2, x3, y3, x4, y4] = getArrowPoints(element, shape);\n          // for dotted arrows caps, reduce gap to make it more legible\n          if (element.strokeStyle === \"dotted\") {\n            options.strokeLineDash = [3, 4];\n            // for solid/dashed, keep solid arrow cap\n          } else {\n            delete options.strokeLineDash;\n          }\n          shape.push(\n            ...[\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ],\n          );\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom = sceneState ? sceneState.zoom : 1;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"draw\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          (element.type === \"line\" || element.type === \"draw\") &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    //  (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n","import { Random } from \"roughjs/bin/math\";\nimport nanoid from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let i = prevPoints.length;\n          while (--i) {\n            const prevPoint: Point = prevPoints[i];\n            const nextPoint: Point = nextPoints[i];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  Scene.getScene(element)?.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => ({\n  ...element,\n  ...updates,\n  version: element.version + 1,\n  versionNonce: randomInteger(),\n});\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"draw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  FontFamily,\n  GroupId,\n  VerticalAlign,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nfunction getTextElementPositionOffsets(\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n}\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamily;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n\n  const { textAlign, verticalAlign } = element;\n\n  let x, y;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: [],\n    lastCommittedPoint: null,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n//  (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  copy.id = randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  handlerRectanglesFromCoords,\n  handlerRectangles,\n} from \"./handlerRectangles\";\nexport { hitTest } from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  normalizeResizeHandle,\n  getElementWithResizeHandler,\n  getResizeHandlerFromCoords,\n} from \"./resizeTest\";\nexport {\n  resizeElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getSyncableElements = (\n  elements: readonly ExcalidrawElement[], // There are places in Excalidraw where synthetic invisibly small elements are added and removed.\n) =>\n  // It's probably best to keep those local otherwise there might be a race condition that\n  // gets the app into an invalid state. I've never seen it happen but I'm worried about it :)\n  elements.filter((el) => el.isDeleted || !isInvisiblySmallElement(el));\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getDrawingVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nexport const KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  TAB: \"Tab\",\n  SPACE: \" \",\n  QUESTION_MARK: \"?\",\n  F_KEY_CODE: 70,\n  ALT_KEY_CODE: 18,\n  Z_KEY_CODE: 90,\n  GRID_KEY_CODE: 222,\n  G_KEY_CODE: 71,\n  C_KEY_CODE: 67,\n  V_KEY_CODE: 86,\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (keyCode: string) =>\n  keyCode === KEYS.ARROW_LEFT ||\n  keyCode === KEYS.ARROW_RIGHT ||\n  keyCode === KEYS.ARROW_DOWN ||\n  keyCode === KEYS.ARROW_UP;\n\nexport const getResizeCenterPointKey = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey || event.which === KEYS.ALT_KEY_CODE;\n\nexport const getResizeWithSidesSameLengthKey = (event: MouseEvent) =>\n  event.shiftKey;\n\nexport const getRotateWithDiscreteAngleKey = (event: MouseEvent) =>\n  event.shiftKey;\n","import LanguageDetector from \"i18next-browser-languagedetector\";\n\nimport fallbackLanguageData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\n\nconst COMPLETION_THRESHOLD_TO_EXCEED = 85;\n\ninterface Language {\n  lng: string;\n  label: string;\n  data: string;\n  rtl?: boolean;\n}\n\nconst allLanguages: Language[] = [\n  { lng: \"bg-BG\", label: \"Български\", data: \"bg-BG.json\" },\n  { lng: \"de-DE\", label: \"Deutsch\", data: \"de-DE.json\" },\n  { lng: \"es-ES\", label: \"Español\", data: \"es-ES.json\" },\n  { lng: \"ca-ES\", label: \"Catalan\", data: \"ca-ES.json\" },\n  { lng: \"el-GR\", label: \"Ελληνικά\", data: \"el-GR.json\" },\n  { lng: \"fr-FR\", label: \"Français\", data: \"fr-FR.json\" },\n  { lng: \"id-ID\", label: \"Bahasa Indonesia\", data: \"id-ID.json\" },\n  { lng: \"it-IT\", label: \"Italiano\", data: \"it-IT.json\" },\n  { lng: \"hu-HU\", label: \"Magyar\", data: \"hu-HU.json\" },\n  { lng: \"nl-NL\", label: \"Nederlands\", data: \"nl-NL.json\" },\n  { lng: \"nb-NO\", label: \"Norsk bokmål\", data: \"nb-NO.json\" },\n  { lng: \"nn-NO\", label: \"Norsk nynorsk\", data: \"nn-NO.json\" },\n  { lng: \"pl-PL\", label: \"Polski\", data: \"pl-PL.json\" },\n  { lng: \"pt-PT\", label: \"Português\", data: \"pt-PT.json\" },\n  { lng: \"ru-RU\", label: \"Русский\", data: \"ru-RU.json\" },\n  { lng: \"uk-UA\", label: \"Українська\", data: \"uk-UA.json\" },\n  { lng: \"fi-FI\", label: \"Suomi\", data: \"fi-FI.json\" },\n  { lng: \"tr-TR\", label: \"Türkçe\", data: \"tr-TR.json\" },\n  { lng: \"ja-JP\", label: \"日本語\", data: \"ja-JP.json\" },\n  { lng: \"ko-KR\", label: \"한국어\", data: \"ko-KR.json\" },\n  { lng: \"zh-TW\", label: \"繁體中文\", data: \"zh-TW.json\" },\n  { lng: \"zh-CN\", label: \"简体中文\", data: \"zh-CN.json\" },\n  { lng: \"ar-SA\", label: \"العربية\", data: \"ar-SA.json\", rtl: true },\n  { lng: \"he-IL\", label: \"עברית\", data: \"he-IL.json\", rtl: true },\n  { lng: \"hi-IN\", label: \"हिन्दी\", data: \"hi-IN.json\" },\n  { lng: \"ta-IN\", label: \"தமிழ்\", data: \"ta-IN.json\" },\n];\n\nexport const languages: Language[] = [\n  { lng: \"en\", label: \"English\", data: \"en.json\" },\n]\n  .concat(\n    allLanguages.sort((left, right) => (left.label > right.label ? 1 : -1)),\n  )\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.lng] >\n      COMPLETION_THRESHOLD_TO_EXCEED,\n  );\n\nlet currentLanguage = languages[0];\nlet currentLanguageData = {};\nconst fallbackLanguage = languages[0];\n\nexport const setLanguage = async (newLng: string | undefined) => {\n  currentLanguage =\n    languages.find((language) => language.lng === newLng) || fallbackLanguage;\n\n  document.documentElement.dir = currentLanguage.rtl ? \"rtl\" : \"ltr\";\n\n  currentLanguageData = await import(`./locales/${currentLanguage.data}`);\n\n  languageDetector.cacheUserLanguage(currentLanguage.lng);\n};\n\nexport const setLanguageFirstTime = async () => {\n  const newLng: string | undefined = languageDetector.detect();\n\n  currentLanguage =\n    languages.find((language) => language.lng === newLng) || fallbackLanguage;\n\n  document.documentElement.dir = currentLanguage.rtl ? \"rtl\" : \"ltr\";\n\n  currentLanguageData = await import(`./locales/${currentLanguage.data}`);\n\n  languageDetector.cacheUserLanguage(currentLanguage.lng);\n};\n\nexport const getLanguage = () => currentLanguage;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (var i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLanguageData, parts) ||\n    findPartsForData(fallbackLanguageData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (var key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n\nconst languageDetector = new LanguageDetector();\nlanguageDetector.init({\n  languageUtils: {\n    formatLanguageCode: (lng: string) => lng,\n    isWhitelisted: () => true,\n  },\n  checkWhitelist: false,\n});\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element\";\nimport { FlooredNumber } from \"../types\";\nimport { ScrollBars } from \"./types\";\nimport { getGlobalCSSVariable } from \"../utils\";\nimport { getLanguage } from \"../i18n\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport const getScrollBars = (\n  elements: readonly ExcalidrawElement[],\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n): ScrollBars => {\n  // This is the bounding box of all the elements\n  const [\n    elementsMinX,\n    elementsMinY,\n    elementsMaxX,\n    elementsMaxY,\n  ] = getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")),\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")),\n    left: parseInt(getGlobalCSSVariable(\"sal\")),\n    right: parseInt(getGlobalCSSVariable(\"sar\")),\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -scrollX + viewportWidthDiff / 2 + safeArea.left;\n  const viewportMinY = -scrollY + viewportHeightDiff / 2 + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // The scrollbar represents where the viewport is in relationship to the scene\n\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              ((viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width:\n              ((viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),\n            height: SCROLLBAR_WIDTH,\n          },\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              ((viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight +\n              Math.max(safeArea.top, SCROLLBAR_MARGIN),\n            width: SCROLLBAR_WIDTH,\n            height:\n              ((viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom),\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n): {\n  isOverEither: boolean;\n  isOverHorizontal: boolean;\n  isOverVertical: boolean;\n} => {\n  const [isOverHorizontal, isOverVertical] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar != null &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n  const isOverEither = isOverHorizontal || isOverVertical;\n  return { isOverEither, isOverHorizontal, isOverVertical };\n};\n","import { AppState, FlooredNumber } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds, getClosestElementBounds } from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nexport const normalizeScroll = (pos: number) =>\n  Math.floor(pos) as FlooredNumber;\n\nfunction isOutsideViewPort(\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n    canvas,\n    window.devicePixelRatio,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n    canvas,\n    window.devicePixelRatio,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n}\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: FlooredNumber; scrollY: FlooredNumber } => {\n  if (!elements.length) {\n    return {\n      scrollX: normalizeScroll(0),\n      scrollY: normalizeScroll(0),\n    };\n  }\n  const scale = window.devicePixelRatio;\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n        canvas,\n        scale,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return {\n    scrollX: normalizeScroll(appState.width / 2 - centerX),\n    scrollY: normalizeScroll(appState.height / 2 - centerY),\n  };\n};\n","export const getZoomOrigin = (\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  if (canvas === null) {\n    return { x: 0, y: 0 };\n  }\n  const context = canvas.getContext(\"2d\");\n  if (context === null) {\n    return { x: 0, y: 0 };\n  }\n\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  return {\n    x: normalizedCanvasWidth / 2,\n    y: normalizedCanvasHeight / 2,\n  };\n};\n\nexport const getNormalizedZoom = (zoom: number): number => {\n  const normalizedZoom = parseFloat(zoom.toFixed(2));\n  const clampedZoom = Math.max(0.1, Math.min(normalizedZoom, 2));\n  return clampedZoom;\n};\n","import { AppState } from \"./types\";\nimport { getZoomOrigin } from \"./scene\";\nimport {\n  CURSOR_TYPE,\n  FONT_FAMILY,\n  WINDOWS_EMOJI_FALLBACK_FONT,\n} from \"./constants\";\nimport { FontFamily, FontString } from \"./element/types\";\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamily;\n}) => {\n  return `${FONT_FAMILY[fontFamily]}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamily;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    //  lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => fn(...args), timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    fn(...lastArgs);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = () => {\n  document.documentElement.style.cursor = \"\";\n};\n\nexport const setCursorForShape = (shape: string) => {\n  if (shape === \"selection\") {\n    resetCursor();\n  } else {\n    document.documentElement.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  const isMac = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  if (isMac) {\n    return `${shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\")\n      .replace(/\\bDel\\b/i, \"Delete\")\n      .replace(/\\b(Enter|Return)\\b/i, \"Enter\")}`;\n  }\n  return `${shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\")}`;\n};\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  const zoomOrigin = getZoomOrigin(canvas, scale);\n  const clientXWithZoom =\n    zoomOrigin.x +\n    (clientX - zoomOrigin.x - appState.offsetLeft) / appState.zoom;\n  const clientYWithZoom =\n    zoomOrigin.y +\n    (clientY - zoomOrigin.y - appState.offsetTop) / appState.zoom;\n\n  const x = clientXWithZoom - appState.scrollX;\n  const y = clientYWithZoom - appState.scrollY;\n\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  const zoomOrigin = getZoomOrigin(canvas, scale);\n  const x =\n    zoomOrigin.x -\n    (zoomOrigin.x - sceneX - appState.scrollX - appState.offsetLeft) *\n      appState.zoom;\n  const y =\n    zoomOrigin.y -\n    (zoomOrigin.y - sceneY - appState.scrollY - appState.offsetTop) *\n      appState.zoom;\n\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => {\n  return RE_RTL_CHECK.test(text);\n};\n\nexport function tupleToCoors(\n  xyTuple: [number, number],\n): { x: number; y: number } {\n  const [x, y] = xyTuple;\n  return { x, y };\n}\n\n/** use as a rejectionHandler to mute filesystem Abort errors */\nexport const muteFSAbortError = (error?: Error) => {\n  if (error?.name === \"AbortError\") {\n    return;\n  }\n  throw error;\n};\n","import oc from \"open-color\";\nimport { AppState, FlooredNumber } from \"./types\";\nimport { getDateTime } from \"./utils\";\nimport { t } from \"./i18n\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"./constants\";\n\nexport const getDefaultAppState = (): Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\"\n> => {\n  return {\n    isLoading: false,\n    errorMessage: null,\n    draggingElement: null,\n    resizingElement: null,\n    multiElement: null,\n    editingElement: null,\n    editingLinearElement: null,\n    elementType: \"selection\",\n    elementLocked: false,\n    exportBackground: true,\n    shouldAddWatermark: false,\n    currentItemStrokeColor: oc.black,\n    currentItemBackgroundColor: \"transparent\",\n    currentItemFillStyle: \"hachure\",\n    currentItemStrokeWidth: 1,\n    currentItemStrokeStyle: \"solid\",\n    currentItemRoughness: 1,\n    currentItemOpacity: 100,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    viewBackgroundColor: oc.white,\n    scrollX: 0 as FlooredNumber,\n    scrollY: 0 as FlooredNumber,\n    cursorX: 0,\n    cursorY: 0,\n    cursorButton: \"up\",\n    scrolledOutside: false,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    username: \"\",\n    isCollaborating: false,\n    isResizing: false,\n    isRotating: false,\n    selectionElement: null,\n    zoom: 1,\n    openMenu: null,\n    lastPointerDownWith: \"mouse\",\n    selectedElementIds: {},\n    previousSelectedElementIds: {},\n    collaborators: new Map(),\n    shouldCacheIgnoreZoom: false,\n    showShortcutsDialog: false,\n    zenModeEnabled: false,\n    gridSize: null,\n    editingGroupId: null,\n    selectedGroupIds: {},\n    width: window.innerWidth,\n    height: window.innerHeight,\n    isLibraryOpen: false,\n  };\n};\n\n/**\n * Config containing all AppState keys. Used to determine whether given state\n *  prop should be stripped when exporting to given storage type.\n */\nconst APP_STATE_STORAGE_CONF = (<\n  Values extends {\n    /** whether to keep when storing to browser storage (localStorage/IDB) */\n    browser: boolean;\n    /** whether to keep when exporting to file/database */\n    export: boolean;\n  },\n  T extends Record<keyof AppState, Values>\n>(\n  config: { [K in keyof T]: K extends keyof AppState ? T[K] : never },\n) => config)({\n  collaborators: { browser: false, export: false },\n  currentItemBackgroundColor: { browser: true, export: false },\n  currentItemFillStyle: { browser: true, export: false },\n  currentItemFontFamily: { browser: true, export: false },\n  currentItemFontSize: { browser: true, export: false },\n  currentItemOpacity: { browser: true, export: false },\n  currentItemRoughness: { browser: true, export: false },\n  currentItemStrokeColor: { browser: true, export: false },\n  currentItemStrokeStyle: { browser: true, export: false },\n  currentItemStrokeWidth: { browser: true, export: false },\n  currentItemTextAlign: { browser: true, export: false },\n  cursorButton: { browser: true, export: false },\n  cursorX: { browser: true, export: false },\n  cursorY: { browser: true, export: false },\n  draggingElement: { browser: false, export: false },\n  editingElement: { browser: false, export: false },\n  editingGroupId: { browser: true, export: false },\n  editingLinearElement: { browser: false, export: false },\n  elementLocked: { browser: true, export: false },\n  elementType: { browser: true, export: false },\n  errorMessage: { browser: false, export: false },\n  exportBackground: { browser: true, export: false },\n  gridSize: { browser: true, export: true },\n  height: { browser: false, export: false },\n  isCollaborating: { browser: false, export: false },\n  isLibraryOpen: { browser: false, export: false },\n  isLoading: { browser: false, export: false },\n  isResizing: { browser: false, export: false },\n  isRotating: { browser: false, export: false },\n  lastPointerDownWith: { browser: true, export: false },\n  multiElement: { browser: false, export: false },\n  name: { browser: true, export: false },\n  openMenu: { browser: true, export: false },\n  previousSelectedElementIds: { browser: true, export: false },\n  resizingElement: { browser: false, export: false },\n  scrolledOutside: { browser: true, export: false },\n  scrollX: { browser: true, export: false },\n  scrollY: { browser: true, export: false },\n  selectedElementIds: { browser: true, export: false },\n  selectedGroupIds: { browser: true, export: false },\n  selectionElement: { browser: false, export: false },\n  shouldAddWatermark: { browser: true, export: false },\n  shouldCacheIgnoreZoom: { browser: true, export: false },\n  showShortcutsDialog: { browser: false, export: false },\n  username: { browser: true, export: false },\n  viewBackgroundColor: { browser: true, export: true },\n  width: { browser: false, export: false },\n  zenModeEnabled: { browser: true, export: false },\n  zoom: { browser: true, export: false },\n  offsetTop: { browser: false, export: false },\n  offsetLeft: { browser: false, export: false },\n});\n\nconst _clearAppStateForStorage = <ExportType extends \"export\" | \"browser\">(\n  appState: Partial<AppState>,\n  exportType: ExportType,\n) => {\n  type ExportableKeys = {\n    [K in keyof typeof APP_STATE_STORAGE_CONF]: typeof APP_STATE_STORAGE_CONF[K][ExportType] extends true\n      ? K\n      : never;\n  }[keyof typeof APP_STATE_STORAGE_CONF];\n  const stateForExport = {} as { [K in ExportableKeys]?: typeof appState[K] };\n  for (const key of Object.keys(appState) as (keyof typeof appState)[]) {\n    const propConfig = APP_STATE_STORAGE_CONF[key];\n    if (!propConfig) {\n      console.error(\n        `_clearAppStateForStorage: appState key \"${key}\" config doesn't exist for \"${exportType}\" export type`,\n      );\n    }\n    if (propConfig?.[exportType]) {\n      // @ts-ignore see https://github.com/microsoft/TypeScript/issues/31445\n      stateForExport[key] = appState[key];\n    }\n  }\n  return stateForExport;\n};\n\nexport const clearAppStateForLocalStorage = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"browser\");\n};\n\nexport const cleanAppStateForExport = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"export\");\n};\n","import {\n  ExcalidrawElement,\n  FontFamily,\n  ExcalidrawSelectionElement,\n} from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { DataState } from \"./types\";\nimport { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { randomId } from \"../random\";\nimport {\n  FONT_FAMILY,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n} from \"../constants\";\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamily => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id) as FontFamily;\n    }\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nfunction migrateElementWithProperties<T extends ExcalidrawElement>(\n  element: Required<T>,\n  extra: Omit<Required<T>, keyof ExcalidrawElement>,\n): T {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: element.type,\n    // all elements must have version > 0 so getDrawingVersion() will pick up\n    //  newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds || [],\n  };\n\n  return {\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as T;\n}\n\nconst migrateElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return migrateElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"draw\":\n    case \"line\":\n    case \"arrow\": {\n      return migrateElementWithProperties(element, {\n        points:\n          // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2\n            ? [\n                [0, 0],\n                [element.width, element.height],\n              ]\n            : element.points,\n        lastCommittedPoint: null,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n    case \"rectangle\":\n    case \"diamond\":\n      return migrateElementWithProperties(element, {});\n\n    // don't use default case so as to catch a missing an element type case\n    //  (we also don't want to throw, but instead return void so we\n    //   filter out these unsupported elements from the restored array)\n  }\n};\n\nexport const restore = (\n  savedElements: readonly ExcalidrawElement[],\n  savedState: MarkOptional<AppState, \"offsetTop\" | \"offsetLeft\"> | null,\n): DataState => {\n  const elements = savedElements.reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    //  and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = migrateElement(element);\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n\n  return {\n    elements: elements,\n    appState: savedState,\n  };\n};\n","import { getDefaultAppState, cleanAppStateForExport } from \"../appState\";\nimport { restore } from \"./restore\";\nimport { t } from \"../i18n\";\nimport { AppState } from \"../types\";\nimport { LibraryData } from \"./types\";\nimport { calculateScrollCenter } from \"../scene\";\n\nconst loadFileContents = async (blob: any) => {\n  let contents: string;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n  return contents;\n};\n\n/**\n * @param blob\n * @param appState if provided, used for centering scroll to restored scene\n */\nexport const loadFromBlob = async (blob: any, appState?: AppState) => {\n  if (blob.handle) {\n    (window as any).handle = blob.handle;\n  }\n\n  const contents = await loadFileContents(blob);\n  const defaultAppState = getDefaultAppState();\n  let elements = [];\n  let _appState = appState || defaultAppState;\n  try {\n    const data = JSON.parse(contents);\n    if (data.type !== \"excalidraw\") {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    elements = data.elements || [];\n    _appState = {\n      ...defaultAppState,\n      ...cleanAppStateForExport(data.appState as Partial<AppState>),\n      ...(appState ? calculateScrollCenter(elements, appState, null) : {}),\n    };\n  } catch {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n\n  return restore(elements, _appState);\n};\n\nexport const loadLibraryFromBlob = async (blob: any) => {\n  const contents = await loadFileContents(blob);\n  const data: LibraryData = JSON.parse(contents);\n  if (data.type !== \"excalidrawlib\") {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n","import { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { cleanAppStateForExport } from \"../appState\";\n\nimport { fileOpen, fileSave } from \"browser-nativefs\";\nimport { loadFromBlob } from \"./blob\";\nimport { loadLibrary } from \"./localStorage\";\nimport { Library } from \"./library\";\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): string =>\n  JSON.stringify(\n    {\n      type: \"excalidraw\",\n      version: 2,\n      source: window.location.origin,\n      elements: elements.filter((element) => !element.isDeleted),\n      appState: cleanAppStateForExport(appState),\n    },\n    null,\n    2,\n  );\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  fileHandle: any,\n) => {\n  const serialized = serializeAsJSON(elements, appState);\n  const blob = new Blob([serialized], {\n    type: \"application/json\",\n  });\n  const name = `${appState.name}.excalidraw`;\n  (window as any).handle = await fileSave(\n    blob,\n    {\n      fileName: name,\n      description: \"Excalidraw file\",\n      extensions: [\"excalidraw\"],\n    },\n    fileHandle || null,\n  );\n};\n\nexport const loadFromJSON = async (appState: AppState) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    extensions: [\"json\", \"excalidraw\"],\n    mimeTypes: [\"application/json\"],\n  });\n  return loadFromBlob(blob, appState);\n};\n\nexport const saveLibraryAsJSON = async () => {\n  const library = await loadLibrary();\n  const serialized = JSON.stringify(\n    {\n      type: \"excalidrawlib\",\n      version: 1,\n      library,\n    },\n    null,\n    2,\n  );\n  const fileName = `library.excalidrawlib`;\n  const blob = new Blob([serialized], {\n    type: \"application/vnd.excalidrawlib+json\",\n  });\n  await fileSave(blob, {\n    fileName,\n    description: \"Excalidraw library file\",\n    extensions: [\"excalidrawlib\"],\n  });\n};\n\nexport const importLibraryFromJSON = async () => {\n  const blob = await fileOpen({\n    description: \"Excalidraw library files\",\n    extensions: [\"json\", \"excalidrawlib\"],\n    mimeTypes: [\"application/json\"],\n  });\n  Library.importLibrary(blob);\n};\n","import React, { useCallback, useEffect, useState } from \"react\";\n\nimport \"./Toolbar.css\";\nimport GitHubCorner from \"./GitHubCorner\";\nimport { exportToSvgFile, exportToWebmFile } from \"./export\";\nimport { ExcalidrawElement } from \"./excalidraw/src/element/types\";\nimport { loadFromJSON } from \"./excalidraw/src/data/json\";\nimport { AppState } from \"./excalidraw/src/types\";\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)/;\n\ntype Props = {\n  svg?: SVGSVGElement;\n  finishedMs?: number;\n  loadData: (data: { elements: readonly ExcalidrawElement[] }) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ svg, finishedMs, loadData }) => {\n  const [showToolbar, setShowToolbar] = useState<boolean | \"never\">(false);\n  const [paused, setPaused] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [link, setLink] = useState(\"\");\n\n  useEffect(() => {\n    if (!svg) {\n      return;\n    }\n    if (paused) {\n      svg.pauseAnimations();\n    } else {\n      svg.unpauseAnimations();\n    }\n  }, [svg, paused]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    } else {\n      setShowToolbar(\"never\");\n    }\n  }, []);\n\n  const loadFile = async () => {\n    const data = await loadFromJSON((undefined as unknown) as AppState);\n    loadData(data);\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    window.location.hash = match[0];\n    window.location.reload();\n  };\n\n  const togglePausedAnimations = useCallback(() => {\n    if (!svg) {\n      return;\n    }\n    setPaused((p) => !p);\n  }, [svg]);\n\n  const resetAnimations = useCallback(() => {\n    if (!svg) {\n      return;\n    }\n    svg.setCurrentTime(0);\n  }, [svg]);\n\n  useEffect(() => {\n    const onKeydown = (e: KeyboardEvent) => {\n      if (e.key.toLowerCase() === \"p\") {\n        togglePausedAnimations();\n      } else if (e.key.toLowerCase() === \"r\") {\n        resetAnimations();\n      } else if (e.key.toLowerCase() === \"q\") {\n        // toggle toolbar\n        setShowToolbar((s) => (typeof s === \"boolean\" ? !s : s));\n      } else {\n        // show toolbar otherwise\n        setShowToolbar((s) => (typeof s === \"boolean\" ? true : s));\n      }\n    };\n    document.addEventListener(\"keydown\", onKeydown);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeydown);\n    };\n  }, [togglePausedAnimations, resetAnimations]);\n\n  const hideToolbar = () => {\n    setShowToolbar((s) => (typeof s === \"boolean\" ? false : s));\n  };\n\n  const exportToSvg = () => {\n    if (!svg) {\n      return;\n    }\n    exportToSvgFile(svg);\n  };\n\n  const exportToWebm = async () => {\n    if (!svg || !finishedMs) {\n      return;\n    }\n    setProcessing(true);\n    await exportToWebmFile(svg, finishedMs);\n    setProcessing(false);\n  };\n\n  if (showToolbar !== true) {\n    return null;\n  }\n\n  return (\n    <div className=\"Toolbar\">\n      <div className=\"Toolbar-loader\">\n        <button type=\"button\" onClick={loadFile}>\n          Load File\n        </button>\n        <span>OR</span>\n        <form onSubmit={loadLink}>\n          <input\n            placeholder=\"Enter shareable link...\"\n            value={link}\n            onChange={(e) => setLink(e.target.value)}\n          />\n          <button type=\"submit\" disabled={!linkRegex.test(link)}>\n            Animate!\n          </button>\n        </form>\n      </div>\n      {svg && (\n        <div className=\"Toolbar-controller\">\n          <button type=\"button\" onClick={togglePausedAnimations}>\n            {paused ? \"Play (P)\" : \"Pause (P)\"}\n          </button>\n          <button type=\"button\" onClick={resetAnimations}>\n            Reset (R)\n          </button>\n          <button type=\"button\" onClick={hideToolbar}>\n            Hide Toolbar (Q)\n          </button>\n          <button type=\"button\" onClick={exportToSvg}>\n            Export to SVG\n          </button>\n          <button type=\"button\" onClick={exportToWebm} disabled={processing}>\n            Export to WebM {processing && \"(Processing...)\"}\n          </button>\n        </div>\n      )}\n      <GitHubCorner\n        link=\"https://github.com/dai-shi/excalidraw-animate\"\n        size={40}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\n\ntype Props = {\n  svg: SVGSVGElement;\n};\n\nconst Viewer: React.FC<Props> = ({ svg }) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.appendChild(svg);\n      return () => {\n        svg.remove();\n      };\n    }\n  }, [svg]);\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"autoplay\") === \"no\") {\n      if (ref.current) {\n        const ele = ref.current;\n        const callback = () => {\n          svg.setCurrentTime(0);\n          svg.unpauseAnimations();\n        };\n        ele.addEventListener(\"click\", callback);\n        return () => {\n          ele.removeEventListener(\"click\", callback);\n        };\n      }\n    }\n  }, [svg]);\n\n  return <div className=\"Viewer\" ref={ref}></div>;\n};\n\nexport default Viewer;\n","import oc from \"open-color\";\n\nconst shades = (i: number) => [\n  oc.red[i],\n  oc.pink[i],\n  oc.grape[i],\n  oc.violet[i],\n  oc.indigo[i],\n  oc.blue[i],\n  oc.cyan[i],\n  oc.teal[i],\n  oc.green[i],\n  oc.lime[i],\n  oc.yellow[i],\n  oc.orange[i],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { SceneHistory } from \"../history\";\n\nimport Scene from \"../scene/Scene\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    editingLinearElement: LinearElementEditor,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    if (\n      isDragging &&\n      (activePointIndex === 0 ||\n        activePointIndex === element.points.length - 1) &&\n      isPathALoop(element.points)\n    ) {\n      LinearElementEditor.movePoint(\n        element,\n        activePointIndex,\n        activePointIndex === 0\n          ? element.points[element.points.length - 1]\n          : element.points[0],\n      );\n    }\n    return {\n      ...editingLinearElement,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: SceneHistory,\n    scenePointerX: number,\n    scenePointerY: number,\n  ): {\n    didAddPoint: boolean;\n    hitElement: ExcalidrawElement | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (!appState.editingLinearElement.lastUncommittedPoint) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointerX,\n              scenePointerY,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointerX,\n      scenePointerY,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    //  it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointerX - targetPoint[0],\n              y: scenePointerY - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return editingLinearElement;\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    //  points on the left, thus should take precedence when clicking, if they\n    //  overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    });\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    //  which would break the invariant of it being at [0,0], we move\n    //  all the other points in the opposite direction by delta to\n    //  offset it. We do the same with actual element.x/y position, so\n    //  this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        //  positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(element, nextPoints);\n    const prevCoords = getElementPointsCoords(element, points);\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { FlooredNumber, AppState } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  handlerRectanglesFromCoords,\n  handlerRectangles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\n\ntype HandlerRectanglesRet = keyof ReturnType<typeof handlerRectangles>;\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill?: boolean,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeCircle = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => {\n  context.beginPath();\n  context.arc(x + width / 2, y + height / 2, width / 2, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      strokeCircle(\n        context,\n        point[0] - POINT_HANDLE_SIZE / 2 / sceneState.zoom,\n        point[1] - POINT_HANDLE_SIZE / 2 / sceneState.zoom,\n        POINT_HANDLE_SIZE / sceneState.zoom,\n        POINT_HANDLE_SIZE / sceneState.zoom,\n      );\n    },\n  );\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    //  doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n  } = {},\n) => {\n  if (!canvas) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = (-normalizedCanvasWidth * (sceneState.zoom - 1)) / 2;\n  const zoomTranslationY =\n    (-normalizedCanvasHeight * (sceneState.zoom - 1)) / 2;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom, sceneState.zoom);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom,\n      normalizedCanvasHeight / sceneState.zoom,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(\n      element,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    ),\n  );\n\n  visibleElements.forEach((element) => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    renderElement(\n      selectionElement,\n      rc,\n      context,\n      renderOptimizations,\n      sceneState,\n    );\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n        ] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    function addSelectionForGroupId(groupId: GroupId) {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(\n        groupElements,\n      );\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    }\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach(\n      ({\n        angle,\n        elementX1,\n        elementY1,\n        elementX2,\n        elementY2,\n        selectionColors,\n      }) => {\n        const elementWidth = elementX2 - elementX1;\n        const elementHeight = elementY2 - elementY1;\n\n        const initialLineDash = context.getLineDash();\n        const lineWidth = context.lineWidth;\n        const lineDashOffset = context.lineDashOffset;\n        const strokeStyle = context.strokeStyle;\n\n        const dashedLinePadding = 4 / sceneState.zoom;\n        const dashWidth = 8 / sceneState.zoom;\n        const spaceWidth = 4 / sceneState.zoom;\n\n        context.lineWidth = 1 / sceneState.zoom;\n\n        const count = selectionColors.length;\n        for (var i = 0; i < count; ++i) {\n          context.strokeStyle = selectionColors[i];\n          context.setLineDash([\n            dashWidth,\n            spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n          ]);\n          context.lineDashOffset = (dashWidth + spaceWidth) * i;\n          strokeRectWithRotation(\n            context,\n            elementX1 - dashedLinePadding,\n            elementY1 - dashedLinePadding,\n            elementWidth + dashedLinePadding * 2,\n            elementHeight + dashedLinePadding * 2,\n            elementX1 + elementWidth / 2,\n            elementY1 + elementHeight / 2,\n            angle,\n          );\n        }\n        context.lineDashOffset = lineDashOffset;\n        context.strokeStyle = strokeStyle;\n        context.lineWidth = lineWidth;\n        context.setLineDash(initialLineDash);\n      },\n    );\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize handlers\n    if (locallySelectedElements.length === 1) {\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      context.fillStyle = oc.white;\n      const handlers = handlerRectangles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n      );\n      Object.keys(handlers).forEach((key) => {\n        const handler = handlers[key as HandlerRectanglesRet];\n        if (handler !== undefined) {\n          const lineWidth = context.lineWidth;\n          context.lineWidth = 1 / sceneState.zoom;\n          if (key === \"rotation\") {\n            strokeCircle(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n            );\n          } else {\n            strokeRectWithRotation(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n              handler[0] + handler[2] / 2,\n              handler[1] + handler[3] / 2,\n              locallySelectedElements[0].angle,\n              true, // fill before stroke\n            );\n          }\n          context.lineWidth = lineWidth;\n        }\n      });\n      context.translate(-sceneState.scrollX, -sceneState.scrollY);\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom;\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const handlers = handlerRectanglesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        undefined,\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      Object.keys(handlers).forEach((key) => {\n        const handler = handlers[key as HandlerRectanglesRet];\n        if (handler !== undefined) {\n          const lineWidth = context.lineWidth;\n          context.lineWidth = 1 / sceneState.zoom;\n          if (key === \"rotation\") {\n            strokeCircle(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n            );\n          } else {\n            strokeRectWithRotation(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n              handler[0] + handler[2] / 2,\n              handler[1] + handler[3] / 2,\n              0,\n              true, // fill before stroke\n            );\n          }\n          context.lineWidth = lineWidth;\n        }\n      });\n      context.translate(-sceneState.scrollX, -sceneState.scrollY);\n    }\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom, 1 / sceneState.zoom);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n    if (isOutOfBounds) {\n      context.globalAlpha = 0.2;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    if (!isOutOfBounds && username) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(username);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.globalAlpha = globalAlpha;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n      context.fillText(\n        username,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  return (\n    x2 + scrollX - viewportWidthDiff / 2 >= 0 &&\n    x1 + scrollX - viewportWidthDiff / 2 <= viewportWidthWithZoom &&\n    y2 + scrollY - viewportHeightDiff / 2 >= 0 &&\n    y1 + scrollY - viewportHeightDiff / 2 <= viewportHeightWithZoom\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      renderElementToSvg(\n        element,\n        rsvg,\n        svgRoot,\n        element.x + offsetX,\n        element.y + offsetY,\n      );\n    }\n  });\n};\n","import rough from \"roughjs/bin/rough\";\nimport oc from \"open-color\";\nimport { newTextElement } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { normalizeScroll } from \"./scroll\";\nimport { AppState } from \"../types\";\nimport { t } from \"../i18n\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_VERTICAL_ALIGN } from \"../constants\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\n\nexport const exportToCanvas = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n  },\n  createCanvas: (width: number, height: number) => any = (width, height) => {\n    const tempCanvas = document.createElement(\"canvas\");\n    tempCanvas.width = width * scale;\n    tempCanvas.height = height * scale;\n    return tempCanvas;\n  },\n) => {\n  let sceneElements = elements;\n  if (shouldAddWatermark) {\n    const [, , maxX, maxY] = getCommonBounds(elements);\n    sceneElements = [...sceneElements, getWatermarkElement(maxX, maxY)];\n  }\n\n  // calculate smallest area to fit the contents in\n  const [minX, minY, maxX, maxY] = getCommonBounds(sceneElements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height =\n    distance(minY, maxY) +\n    exportPadding +\n    (shouldAddWatermark ? 0 : exportPadding);\n\n  const tempCanvas: any = createCanvas(width, height);\n\n  renderScene(\n    sceneElements,\n    appState,\n    null,\n    scale,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: normalizeScroll(-minX + exportPadding),\n      scrollY: normalizeScroll(-minY + exportPadding),\n      zoom: 1,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: false,\n      renderGrid: false,\n    },\n  );\n\n  return tempCanvas;\n};\n\nexport const exportToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n  },\n): SVGSVGElement => {\n  let sceneElements = elements;\n  if (shouldAddWatermark) {\n    const [, , maxX, maxY] = getCommonBounds(elements);\n    sceneElements = [...sceneElements, getWatermarkElement(maxX, maxY)];\n  }\n\n  // calculate canvas dimensions\n  const [minX, minY, maxX, maxY] = getCommonBounds(sceneElements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height =\n    distance(minY, maxY) +\n    exportPadding +\n    (shouldAddWatermark ? 0 : exportPadding);\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/FG_Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render backgroiund rect\n  if (exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(sceneElements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\nconst getWatermarkElement = (maxX: number, maxY: number) => {\n  return newTextElement({\n    text: t(\"labels.madeWithExcalidraw\"),\n    fontSize: 16,\n    fontFamily: DEFAULT_FONT_FAMILY,\n    textAlign: \"right\",\n    verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    x: maxX,\n    y: maxY + 16,\n    strokeColor: oc.gray[5],\n    backgroundColor: \"transparent\",\n    fillStyle: \"hachure\",\n    strokeWidth: 1,\n    strokeStyle: \"solid\",\n    roughness: 1,\n    opacity: 100,\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, renderSpreadsheet } from \"./charts\";\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nexport const copyToAppClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  CLIPBOARD = JSON.stringify(getSelectedElements(elements, appState));\n  try {\n    // when copying to in-app clipboard, clear system clipboard so that if\n    //  system clip contains text on paste we know it was copied *after* user\n    //  copied elements, and thus we should prefer the text content.\n    await copyTextToSystemClipboard(null);\n    PREFER_APP_CLIPBOARD = false;\n  } catch {\n    // if clearing system clipboard didn't work, we should prefer in-app\n    //  clipboard even if there's text in system clipboard on paste, because\n    //  we can't be sure of the order of copy operations\n    PREFER_APP_CLIPBOARD = true;\n  }\n};\n\nexport const getAppClipboard = (): {\n  elements?: readonly ExcalidrawElement[];\n} => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    const clipboardElements = JSON.parse(CLIPBOARD);\n\n    if (\n      Array.isArray(clipboardElements) &&\n      clipboardElements.length > 0 &&\n      clipboardElements[0].type // need to implement a better check here...\n    ) {\n      return { elements: clipboardElements };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return {};\n};\n\nexport const getClipboardContent = async (\n  appState: AppState,\n  cursorX: number,\n  cursorY: number,\n  event: ClipboardEvent | null,\n): Promise<{\n  text?: string;\n  elements?: readonly ExcalidrawElement[];\n  error?: string;\n}> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    if (text && !PREFER_APP_CLIPBOARD && !text.includes(SVG_EXPORT_TAG)) {\n      const result = tryParseSpreadsheet(text);\n      if (result.type === \"spreadsheet\") {\n        return {\n          elements: renderSpreadsheet(\n            appState,\n            result.spreadsheet,\n            cursorX,\n            cursorY,\n          ),\n        };\n      } else if (result.type === \"malformed spreadsheet\") {\n        return { error: result.error };\n      }\n      return { text };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return getAppClipboard();\n};\n\nexport const copyCanvasToClipboardAsPng = async (canvas: HTMLCanvasElement) =>\n  new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(async (blob: any) => {\n        try {\n          await navigator.clipboard.write([\n            new window.ClipboardItem({ \"image/png\": blob }),\n          ]);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n\nexport const copyCanvasToClipboardAsSvg = async (svgroot: SVGSVGElement) => {\n  try {\n    await navigator.clipboard.writeText(svgroot.outerHTML);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      //  not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  //  clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getDefaultAppState } from \"../appState\";\n\nimport { AppState } from \"../types\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { fileSave } from \"browser-nativefs\";\n\nimport { t } from \"../i18n\";\nimport {\n  copyCanvasToClipboardAsPng,\n  copyCanvasToClipboardAsSvg,\n} from \"../clipboard\";\nimport { serializeAsJSON } from \"./json\";\n\nimport { ExportType } from \"../scene/types\";\nimport { restore } from \"./restore\";\nimport { restoreFromLocalStorage } from \"./localStorage\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { saveAsJSON, loadFromJSON } from \"./json\";\nexport { saveToLocalStorage } from \"./localStorage\";\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\n\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketID: string;\n      pointerCoords: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\n// TODO: Defined globally, since file handles aren't yet serializable.\n// Once `FileSystemFileHandle` can be serialized, make this\n// part of `AppState`.\n(window as any).handle = null;\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nconst createIV = () => {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  if (link.length === 0) {\n    return;\n  }\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n};\n\nexport const generateCollaborationLink = async () => {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n};\n\nconst getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n  const iv = new Uint8Array(12);\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    key,\n    encoded,\n  );\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n\n      window.prompt(`🔒${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n\nexport const importFromBackend = async (\n  id: string | null,\n  privateKey: string | undefined,\n) => {\n  let elements: readonly ExcalidrawElement[] = [];\n  let appState = getDefaultAppState();\n\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return restore(elements, appState);\n    }\n    let data;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv: iv,\n        },\n        key,\n        buffer,\n      );\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    elements = data.elements || elements;\n    appState = { ...appState, ...data.appState };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n  } finally {\n    return restore(elements, appState);\n  }\n};\n\nexport const exportCanvas = async (\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n    scale?: number;\n    shouldAddWatermark: boolean;\n  },\n) => {\n  if (elements.length === 0) {\n    return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = exportToSvg(elements, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding,\n      shouldAddWatermark,\n    });\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], { type: \"image/svg+xml\" }), {\n        fileName: `${name}.svg`,\n        extensions: [\"svg\"],\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      copyCanvasToClipboardAsSvg(tempSvg);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    scale,\n    shouldAddWatermark,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    tempCanvas.toBlob(async (blob: any) => {\n      if (blob) {\n        await fileSave(blob, {\n          fileName: fileName,\n          extensions: [\"png\"],\n        });\n      }\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      copyCanvasToClipboardAsPng(tempCanvas);\n    } catch {\n      window.alert(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  } else if (type === \"backend\") {\n    exportToBackend(elements, {\n      ...appState,\n      viewBackgroundColor: exportBackground\n        ? appState.viewBackgroundColor\n        : getDefaultAppState().viewBackgroundColor,\n    });\n  }\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) {\n    tempCanvas.remove();\n  }\n};\n\nexport const loadScene = async (id: string | null, privateKey?: string) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = await importFromBackend(id, privateKey);\n  } else {\n    data = restoreFromLocalStorage();\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n","import { SVG_NS } from \"./excalidraw/src/utils\";\nimport { NonDeletedExcalidrawElement } from \"./excalidraw/src/element/types\";\n\nconst findNode = (ele: SVGElement, name: string) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  for (let i = 0; i < childNodes.length; ++i) {\n    if (childNodes[i].tagName === name) {\n      return childNodes[i];\n    }\n  }\n  return null;\n};\n\nconst animatePath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  const repeat = cCount / mCount;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"M(\\\\S+) (\\\\S+)\",\n          \"((?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){\",\n          `${i}`, // skip count\n          \"})\",\n          \"(?: C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+){1,}\",\n        ].join(\"\"),\n        \"g\"\n      ),\n      (...a) => {\n        const [x, y] = a[3]\n          ? a[3].match(/.* (\\S+) (\\S+)$/).slice(1, 3)\n          : [a[1], a[2]];\n        return (\n          `M${a[1]} ${a[2]}${a[3]}` +\n          ` C${x} ${y}, ${x} ${y}, ${x} ${y}`.repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n};\n\nconst animateFillPath = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  if (dTo.includes(\"C\")) {\n    animatePath(svg, ele, currentMs, durationMs);\n    return;\n  }\n  const dFrom = dTo.replace(\n    new RegExp([\"M(\\\\S+) (\\\\S+)\", \"((?: L\\\\S+ \\\\S+){1,})\"].join(\"\")),\n    (...a) => {\n      return `M${a[1]} ${a[2]}` + a[3].replace(/L\\S+ \\S+/g, `L${a[1]} ${a[2]}`);\n    }\n  );\n  ele.setAttribute(\"d\", dFrom);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", dFrom);\n  animate.setAttribute(\"to\", dTo);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  ele.appendChild(animate);\n};\n\nconst animateRect = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const dTo = ele.getAttribute(\"d\") || \"\";\n  const mCount = dTo.match(/M/g)?.length || 0;\n  const cCount = dTo.match(/C/g)?.length || 0;\n  if (mCount !== cCount) throw new Error(\"unexpected m/c counts\");\n  const repeat = 4;\n  const dups = mCount / repeat;\n  let dLast = dTo;\n  for (let i = repeat - 1; i >= 0; i -= 1) {\n    const dFrom = dTo.replace(\n      new RegExp(\n        [\n          \"((?:\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \"){\",\n          `${i}`, // skip count\n          \"})\",\n          \"M(\\\\S+) (\\\\S+) C\\\\S+ \\\\S+, \\\\S+ \\\\S+, \\\\S+ \\\\S+ ?\".repeat(dups),\n          \".*\",\n        ].join(\"\")\n      ),\n      (...a) => {\n        return (\n          `${a[1]}` +\n          [...Array(dups).keys()]\n            .map((d) => {\n              const [x, y] = a.slice(2 + dups * 2 + d * 2);\n              return `M${x} ${y} C${x} ${y}, ${x} ${y}, ${x} ${y} `;\n            })\n            .join(\"\")\n            .repeat(repeat - i)\n        );\n      }\n    );\n    if (i === 0) {\n      ele.setAttribute(\"d\", dFrom);\n    }\n    const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n    animate.setAttribute(\"attributeName\", \"d\");\n    animate.setAttribute(\"from\", dFrom);\n    animate.setAttribute(\"to\", dLast);\n    animate.setAttribute(\"begin\", `${currentMs + i * (durationMs / repeat)}ms`);\n    animate.setAttribute(\"dur\", `${durationMs / repeat}ms`);\n    animate.setAttribute(\"fill\", \"freeze\");\n    ele.appendChild(animate);\n    dLast = dFrom;\n  }\n};\n\nlet pathForTextIndex = 0;\n\nconst animateText = (\n  svg: SVGSVGElement,\n  width: number,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const y = ele.getAttribute(\"y\");\n  pathForTextIndex += 1;\n  const path = svg.ownerDocument.createElementNS(SVG_NS, \"path\");\n  path.setAttribute(\"id\", \"pathForText\" + pathForTextIndex);\n  const animate = svg.ownerDocument.createElementNS(SVG_NS, \"animate\");\n  animate.setAttribute(\"attributeName\", \"d\");\n  animate.setAttribute(\"from\", `m0,${y} h0`);\n  animate.setAttribute(\"to\", `m0,${y} h${width}`);\n  animate.setAttribute(\"begin\", `${currentMs}ms`);\n  animate.setAttribute(\"dur\", `${durationMs}ms`);\n  animate.setAttribute(\"fill\", \"freeze\");\n  path.appendChild(animate);\n  const textPath = svg.ownerDocument.createElementNS(SVG_NS, \"textPath\");\n  textPath.setAttribute(\"href\", \"#pathForText\" + pathForTextIndex);\n  textPath.textContent = ele.textContent;\n  ele.textContent = \" \"; // HACK for Firebox as `null` does not work\n  findNode(svg, \"defs\")?.appendChild(path);\n  ele.appendChild(textPath);\n};\n\nconst patchSvgLine = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  if (childNodes[0].getAttribute(\"fill-rule\")) {\n    animatePath(\n      svg,\n      childNodes[0].childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePath(\n      svg,\n      childNodes[0].childNodes[0] as SVGElement,\n      currentMs,\n      durationMs\n    );\n  }\n};\n\nconst patchSvgArrow = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  animatePath(\n    svg,\n    ele.childNodes[0].childNodes[0] as SVGElement,\n    currentMs,\n    durationMs * 0.6\n  );\n  currentMs += durationMs * 0.6;\n  animatePath(\n    svg,\n    ele.childNodes[1].childNodes[0] as SVGElement,\n    currentMs,\n    durationMs * 0.2\n  );\n  currentMs += durationMs * 0.2;\n  animatePath(\n    svg,\n    ele.childNodes[2].childNodes[0] as SVGElement,\n    currentMs,\n    durationMs * 0.2\n  );\n};\n\nconst patchSvgRectangle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animateRect(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animateRect(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgEllipse = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (ele.childNodes[1]) {\n    animatePath(\n      svg,\n      ele.childNodes[1] as SVGElement,\n      currentMs,\n      durationMs * 0.75\n    );\n    currentMs += durationMs * 0.75;\n    animateFillPath(\n      svg,\n      ele.childNodes[0] as SVGElement,\n      currentMs,\n      durationMs * 0.25\n    );\n  } else {\n    animatePath(svg, ele.childNodes[0] as SVGElement, currentMs, durationMs);\n  }\n};\n\nconst patchSvgText = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  width: number,\n  currentMs: number,\n  durationMs: number\n) => {\n  const childNodes = ele.childNodes as NodeListOf<SVGElement>;\n  const len = childNodes.length;\n  childNodes.forEach((child) => {\n    animateText(svg, width, child, currentMs, durationMs / len);\n    currentMs += durationMs / len;\n  });\n};\n\nconst patchSvgEle = (\n  svg: SVGSVGElement,\n  ele: SVGElement,\n  type: string,\n  width: number,\n  currentMs: number,\n  durationMs: number\n) => {\n  if (type === \"line\" || type === \"draw\") {\n    patchSvgLine(svg, ele, currentMs, durationMs);\n  } else if (type === \"arrow\") {\n    patchSvgArrow(svg, ele, currentMs, durationMs);\n  } else if (type === \"rectangle\" || type === \"diamond\") {\n    patchSvgRectangle(svg, ele, currentMs, durationMs);\n  } else if (type === \"ellipse\") {\n    patchSvgEllipse(svg, ele, currentMs, durationMs);\n  } else if (type === \"text\") {\n    patchSvgText(svg, ele, width, currentMs, durationMs);\n  }\n};\n\nconst createGroups = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  const groups: { [groupId: string]: (readonly [SVGElement, number])[] } = {};\n  let index = 0;\n  const childNodes = svg.childNodes as NodeListOf<SVGElement>;\n  childNodes.forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { groupIds } = elements[index];\n      if (groupIds.length >= 1) {\n        const groupId = groupIds[0];\n        groups[groupId] = groups[groupId] || [];\n        groups[groupId].push([ele, index] as const);\n      }\n      index += 1;\n    }\n  });\n  return groups;\n};\n\nexport const animateSvg = (\n  svg: SVGSVGElement,\n  elements: readonly NonDeletedExcalidrawElement[]\n) => {\n  let finishedMs;\n  const groups = createGroups(svg, elements);\n  const finished = new Map();\n  let current = 1000; // 1 sec margin\n  const groupDur = 5000;\n  const individualDur = 500;\n  let index = 0;\n  (svg.childNodes as NodeListOf<SVGElement>).forEach((ele) => {\n    if (ele.tagName === \"g\") {\n      const { type, width, groupIds } = elements[index];\n      if (!finished.has(ele)) {\n        if (groupIds.length >= 1) {\n          const groupId = groupIds[0];\n          const group = groups[groupId];\n          const dur = groupDur / (group.length + 1);\n          patchSvgEle(svg, ele, type, width, current, dur);\n          current += dur;\n          finished.set(ele, true);\n          group.forEach(([childEle, childIndex]) => {\n            const { type: childType, width: childWidth } = elements[childIndex];\n            if (!finished.has(childEle)) {\n              patchSvgEle(svg, childEle, childType, childWidth, current, dur);\n              current += dur;\n              finished.set(childEle, true);\n            }\n          });\n          delete groups[groupId];\n        } else {\n          patchSvgEle(svg, ele, type, width, current, individualDur);\n          current += individualDur;\n          finished.set(ele, true);\n        }\n      }\n      index += 1;\n    }\n  });\n  finishedMs = current + 1000; // 1 sec margin\n  return { finishedMs };\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { importFromBackend } from \"./excalidraw/src/data\";\nimport { exportToSvg } from \"./excalidraw/src/scene/export\";\nimport { getNonDeletedElements } from \"./excalidraw/src/element\";\nimport { ExcalidrawElement } from \"./excalidraw/src/element/types\";\n\nimport { animateSvg } from \"./animate\";\n\nexport const useLoadSvg = () => {\n  const [loading, setLoading] = useState(true);\n  const [loadedSvg, setLoadedSvg] = useState<SVGSVGElement>();\n  const [finishedMs, setFinishedMs] = useState<number>();\n\n  const loadData = useCallback(\n    (data: { elements: readonly ExcalidrawElement[] }) => {\n      const elements = getNonDeletedElements(data.elements);\n      const svg = exportToSvg(elements, {\n        exportBackground: true,\n        exportPadding: 30,\n        viewBackgroundColor: \"white\",\n        shouldAddWatermark: false,\n      });\n      const result = animateSvg(svg, elements);\n      console.log(svg);\n      setLoadedSvg(svg);\n      setFinishedMs(result.finishedMs);\n      return { svg, finishedMs: result.finishedMs };\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const match = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (match) {\n        const [, id, key] = match;\n        const data = await importFromBackend(id, key);\n        const { svg, finishedMs } = loadData(data);\n        if (searchParams.get(\"autoplay\") === \"no\") {\n          svg.setCurrentTime(finishedMs);\n        }\n      }\n      setLoading(false);\n    })();\n  }, [loadData]);\n\n  return { loading, loadedSvg, finishedMs, loadData };\n};\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadSvg } from \"./useLoadSvg\";\n\nconst App: React.FC = () => {\n  const { loading, loadedSvg, finishedMs, loadData } = useLoadSvg();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      <Toolbar svg={loadedSvg} finishedMs={finishedMs} loadData={loadData} />\n      {loadedSvg && <Viewer svg={loadedSvg} />}\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}